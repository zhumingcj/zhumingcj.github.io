<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Usage of Trigonometric Decomposition</title>
      <link href="/2019/07/03/usage-of-trigonometric-decomposition/"/>
      <url>/2019/07/03/usage-of-trigonometric-decomposition/</url>
      
        <content type="html"><![CDATA[<h1 id="三角分解解线性方程组"><a href="#三角分解解线性方程组" class="headerlink" title="三角分解解线性方程组"></a>三角分解解线性方程组</h1><p>相比于高斯消元法，应用三角分解来解线性方程组在某些情况下能提高计算的效率。</p><a id="more"></a><h3 id="三角分解解线性方程的公式推导"><a href="#三角分解解线性方程的公式推导" class="headerlink" title="三角分解解线性方程的公式推导"></a>三角分解解线性方程的公式推导</h3><p>即，我们要解 LUx=b, 我们把这个方程拆为两个方程来解</p><script type="math/tex; mode=display">\left\{\begin{array}\Ly=b\\Ux=y\end{array}\right.</script><p>解方程组Ly=b的第一个方程为$y_{1}=b_{1}$，而第i个方程为</p><script type="math/tex; mode=display">\sum_{j=1}^{i-1}(l_{ij}y_{ij}+y_{i}=b_{i})\Longrightarrow\\\left\{\begin{array}\y_{1}=b_{1},\\y_{i}=b_{i}-\sum_{j=1}^{i-1}l_{ij}y_{j},\quad i=1,2,3,\dots,n\end{array}\right.</script><p>将解得的y代入Ux=y，由高斯消元法回代公式可得</p><script type="math/tex; mode=display">\left\{\begin{array}\x_{n}=\frac{y_{n}}{u_{nn}},\\x_{i}=\frac{y_{i}-\sum_{j=i+1}^{n}u_{ij}x_{j}}{u_{ii}},\quad i=n-1,n-2,\dots,2,1\end{array}\right.</script><hr><h3 id="一个LU分解的例子"><a href="#一个LU分解的例子" class="headerlink" title="一个LU分解的例子"></a>一个LU分解的例子</h3><script type="math/tex; mode=display">A=\begin{pmatrix}9&18&9&-27\\18&45&0&-45\\9&0&126&9\\-27&-45&9&135\end{pmatrix}\quad\quad\quad\quad\quad\quad b=\begin{pmatrix}1\\2\\16\\8\end{pmatrix}</script><p>现在对A进行分解</p><p><img src="http://pte2s6ppx.bkt.clouddn.com/blog/20190703/Vn9k4APAIbny.png?imageslim" alt="mark"></p><p>即可得</p><script type="math/tex; mode=display">L=\begin{pmatrix}1&\\2&1&\\1&-2&1\\-3&1&\frac{2}{3}&1\end{pmatrix}\quad\quad U=\begin{pmatrix}9&18&9&-27\\0&9&-18&9\\0&0&81&54\\0&0&0&9\end{pmatrix}\\\quad\\\quad\\y=\begin{pmatrix}1\\0\\15\\1\end{pmatrix}</script><h3 id="LU分解解线性方程组的算法分析"><a href="#LU分解解线性方程组的算法分析" class="headerlink" title="LU分解解线性方程组的算法分析"></a>LU分解解线性方程组的算法分析</h3><p>由矩阵LU分解公式可知，计算$u_{ij}$和$l_{ij}$各有</p><p>​                                                              $\sum_{j=2}^{n-1}(j(n-j)+n-1=\sum_{1}^{n-1}j(n-j)=1/6n^{3}-1/6n$</p><p>个乘除法，所以矩阵分解共有$1/3n^3-1/3n$个乘除法，而求解下三角方程Ly=b有$1/2n(n-1)$个乘除法，求解上三角方程Ux=y有$1/2n(n-1)+n$个乘除法，综上，用LU分解来解线性方程组共有$\frac{1}{3}n^{2}+n^{2}-\frac{1}{3}n$个乘除法，与高斯消元法的运算次数一样。</p><p>但是从LU分解的形式上看，不难发现如果我们要解一系列系数矩阵相同但右端不同的方程组时，LU分解可以大大减少计算量。</p><h3 id="编程实现LU分解"><a href="#编程实现LU分解" class="headerlink" title="编程实现LU分解"></a>编程实现LU分解</h3><ol><li>程序如下</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Trigonometric_Decomposition</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">           Matrix m= <span class="keyword">new</span> Matrix(<span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">            m.LuDecomposition();</span><br><span class="line">            m.DisPlay();</span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title">Matrix</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> column = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">float</span>[,] matrix;</span><br><span class="line">            \\矩阵的输入</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Matrix</span>(<span class="params"><span class="keyword">int</span> row, <span class="keyword">int</span> column</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">this</span>.row = row;</span><br><span class="line">                <span class="keyword">this</span>.column = column;</span><br><span class="line">                Console.WriteLine(<span class="string">$"Please enter a matrix with <span class="subst">&#123;<span class="keyword">this</span>.row&#125;</span>rows,<span class="subst">&#123;<span class="keyword">this</span>.column&#125;</span>colums"</span>);</span><br><span class="line">                matrix = <span class="keyword">new</span> <span class="keyword">float</span>[row, column];</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">string</span> mid = Console.ReadLine();</span><br><span class="line">                            <span class="keyword">var</span> rows = mid.Split(<span class="string">' '</span>);</span><br><span class="line">                            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> rows)</span><br><span class="line">                            &#123;</span><br><span class="line">                                matrix[i, j++] = <span class="keyword">float</span>.Parse(item);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    Console.WriteLine(<span class="string">"\r\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">$"something wrong!\n<span class="subst">&#123;e.Message&#125;</span>"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            \\输出矩阵</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisPlay</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.row; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.column; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.Write(matrix[i, j] + <span class="string">"   "</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Console.WriteLine(<span class="string">"\r"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            \\矩阵的LU分解</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LuDecomposition</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">            <span class="comment">//初始化第一行、第一列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.column; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i, <span class="number">0</span>] = matrix[i,<span class="number">0</span>] / matrix[<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.row; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="comment">//先计算对角元，避免重复计算（放在第二个循环内会计算两次）</span></span><br><span class="line">                    matrix[i, i] = matrix[i, i] - FigureTemp(i, i, i );</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; <span class="keyword">this</span>.column; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                    <span class="comment">//第i行i列的更新</span></span><br><span class="line">                        matrix[i, j] = matrix[i, j] - FigureTemp(i, j, i);</span><br><span class="line">                        matrix[j, i] = (matrix[j, i] - FigureTemp(i, j, i))/matrix[i,i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">FigureTemp</span>(<span class="params"><span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">            <span class="comment">//用于计算求和中间量</span></span><br><span class="line">                <span class="keyword">float</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; k; s++)</span><br><span class="line">                &#123;</span><br><span class="line">                    result += matrix[i, s] * matrix[s, j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>程序的验证</li></ol><p>当我们输入矩阵</p><script type="math/tex; mode=display">A=\begin{pmatrix}9&18&9&-27\\18&45&0&-45\\9&0&126&9\\-27&-45&9&135\end{pmatrix}</script><p>将得到输出如下</p><p><img src="http://pte2s6ppx.bkt.clouddn.com/blog/20190703/1k03XAqLqCjq.png?imageslim" alt="mark"></p><p>经对比，与上面计算的一致，程序无误。</p>]]></content>
      
      
      <categories>
          
          <category> Numerical Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/07/02/triangular-decomposition/"/>
      <url>/2019/07/02/triangular-decomposition/</url>
      
        <content type="html"><![CDATA[<h1 id="矩阵的LU分解"><a href="#矩阵的LU分解" class="headerlink" title="矩阵的LU分解"></a>矩阵的LU分解</h1><p><code>矩阵的分解在矩阵的研究中有着极其重要的地位，而LU分解则是矩阵分析中一种常见而又重要的分解.</code></p><a id="more"></a><h2 id="LU分解——从高斯消元法说起"><a href="#LU分解——从高斯消元法说起" class="headerlink" title="LU分解——从高斯消元法说起"></a>LU分解——从高斯消元法说起</h2><h4 id="LU分解的来龙去脉"><a href="#LU分解的来龙去脉" class="headerlink" title="LU分解的来龙去脉"></a>LU分解的来龙去脉</h4><p>在高斯消元法中，我们使用了多次倍加把主对角元以外的元素变为零，这个过程可以看成是用一系列的初等矩阵来左乘系数矩阵。</p><script type="math/tex; mode=display">A^{(0)}=A \quad\quad\quadA^{(1)}\triangleq\begin{pmatrix}a_{11}^{(0)}&a_{12}^{(0)}&\dots&a_{1n}^{(0)}\\0&a_{22}^{(1)}&\dots&a_{2n}^{(1)}\\\vdots&\vdots&&\vdots\\0&a_{n2}^{(1)}&\dots&a_{nn}^{(1)}\end{pmatrix}\quad\quad\quad\\\quad\\L_{1}\triangleq\begin{pmatrix}1&&&&\\-l_{12}&1\\-l_{13}&&1&&\\\vdots&&&\ddots\\-l_{1n}&&&&1\end{pmatrix}</script><p>则有$A^{(1)}=L_{1}A^{(0)}$,同理有</p><script type="math/tex; mode=display">A^{(2)}\triangleq\begin{pmatrix}a_{11}^{(0)}&a_{12}^{(0)}&a_{}13^{(0)}&\dots&a_{1n}^{(0)}\\0&a_{22}^{(1)}&a_{23}^{(1)}&\dots&a_{2n}^{(1)}\\0&0&a_{33}^{(2)}&\cdots&a_{3n}^{(2)}\\\vdots&\vdots&\vdots&&\vdots\\0&0&a_{n3}^{(2)}&\dots&a_{nn}^{(1)}\end{pmatrix}\quad\quad\quad\\\quad\\\quad\\L_{2}\triangleq\begin{pmatrix}1&&&&\\&1\\&-l_{32}&1\\&-l_{42}&&1&&\\&\vdots&&&\ddots\\&-l_{n2}&&&&1\end{pmatrix}\\A^{(2)}=L_{2}A^{(1)}</script><p>一般的，有</p><script type="math/tex; mode=display">A^{(k-1)}\triangleq\begin{pmatrix}a_{11}^{(0)}&a_{12}^{(0)}&&\dots &\dots&a_{1n}^{(0)}\\&a_{22}^{(1)}&&\dots&\dots&a_{2n}^{(1)}\\&&\ddots&&&\vdots\\&&&a_{kk}^{(k-1)}&\dots&a_{kn}^{(k-1)}\\&&&\vdots&\dots&\vdots\\&&&a_{nk}^{(k-1)}&\dots&a_{nn}^{(k-1)}\end{pmatrix}\quad\quad\quad\\\quad\\\quad\\L_{2}\triangleq\begin{pmatrix}1&&&&\\&\ddots\\&&1\\&&-a_{k+1,k}&1\\&&-l_{k+2,k}&&1&&\\&&\vdots&&&\ddots\\&&-l_{nk}&&&&1\end{pmatrix}\\\quad\\\quad\\\quad\\A^{(k)}\triangleqA^{(k-1)}\triangleq\begin{pmatrix}a_{11}^{(0)}&a_{12}^{(0)}&&\dots&a_{1,k+1}^{(0)} &\dots&a_{1n}^{(0)}\\&a_{22}^{(1)}&&\dots&a_{2,k+1}^{(1)} &\dots&a_{2n}^{(1)}\\&&\ddots&&\vdots&&\vdots\\&&&a_{kk}^{(k-1)}&a_{k,k+1}^{(k-1)} &\dots&a_{kn}^{(k-1)}\\&&&&a_{k+1,k+1}^{k}&\dots&a_{k+1,n}^{(k)}\\&&&&\vdots&&\vdots\\&&&&a_{n,k+1}^{(k)}&\dots&a_{nn}^{(k)}\end{pmatrix}\quad\quad\quadA^{(k)}=L_{k}A^{(k-1)}=\dots=L_{k}L_{k-1}\dots L_{1}A^{(0)}.</script><p>因为一共有n-1步消元，所以$A^{(n-1)}=L_{n}L{n-1}\dots L_{k}\dots L_{2}L_{1}A^{(0)}$</p><script type="math/tex; mode=display">A^{(n-1)}=\begin{pmatrix}a_{11}^{(0)}&a_{12}^{(0)}&\dots&a_{1n}^{(0)}\\&a_{22}^{(1)}&\dots&a{2n}^{(1)}\\&&\ddots&\vdots\\&&&a_{nn}^{n-1}\end{pmatrix}</script><p>我们注意到$L_{k}$的逆矩阵为</p><script type="math/tex; mode=display">L_{k}^{-1}=\begin{pmatrix}1&&&\\&\ddots&&\\&&1&&\\&&-l_{k+1,k}&1\\&&\vdots&&\ddots\\&&l_{n,k}&&&1\end{pmatrix}</script><p>则$A=A^{(0)}=L_{1}^{-1}L{2}^{-1}\dots L_{n-1}^{-1}A^{(n-1)}=LU$</p><p>其中</p><script type="math/tex; mode=display">L\triangleq L_{1}^{-1}L_{2}^{-1}\dots L_{n-1}^{-1}=\begin{pmatrix}1&&&&\\l_{21}&1\\l_{31}&l_{32}&1\\\vdots&\vdots&&\ddots\\l_{n1}&l_{n2}&\dots&l_{n,n-1}&l_{n,n}\end{pmatrix}\\\quad\\\quad\\U\triangleq A^{(n-1)}\begin{pmatrix}u_{11}&u_{12}&\dots&u_{1n}\\&u_{22}&\dots&u_{2n}\\&&\ddots&\vdots\\&&&u_{nn}\end{pmatrix}</script><p>显然可知L为下三角矩阵而U为上三角矩阵</p><h4 id="LU分解的公式推导"><a href="#LU分解的公式推导" class="headerlink" title="LU分解的公式推导"></a>LU分解的公式推导</h4><p>根据$A=LU$,由矩阵乘法可得</p><script type="math/tex; mode=display">a_{ij}=\sum_{k=1}^{n}l_{ik}u_{kj},\quad i,j=1,2,\dots,n \quad(1)</script><p><code>注：由L为下三角矩阵可知</code><strong>$l_{ij}=0, when j&gt;i$</strong> <code>同样的因为U是上三角矩阵，所以</code><strong>$u_{ij}=0, when i&gt;j$</strong></p><p>由（1）可先计算U的元</p><script type="math/tex; mode=display">a_{ij}=\sum_{k=1}^{i}l_{ik}u_{kj}=\sum_{k=1}^{i-1}l_{ik}u_{kj}+u_{ij}\quad\quad 故\\u_{ij}=a_{ij}-\sum_{k=1}^{i-1}l_{ik}u_{kj}\quad i=1,2,\dots,n;j=i,i+1,\dots,n \\特别的,当i=1时，u_{1j}=a_{1j}(j=1,2,\dots,n)</script><p>然后再计算L的元</p><script type="math/tex; mode=display">a_{ij}=\sum_{k=1}^{j}l_{ik}u_{kj}=\sum_{k=1}^{j-1}l_{ik}u_{kj}+l_{ij}u_{jj}\\\quad\\l_{ij}=\frac{a_{ij}-\sum_{k=1}^{j-1}l_{ik}u_{kj}}{u_{jj}}\\特别的，当j=1时，l_{i1}=\frac{a_{i1}}{u_{11}}</script><p>综上所述，我们可以得到如下公式</p><script type="math/tex; mode=display">\left\{\begin{array}\u_{1j}=a_{1j},\quad\quad\quad\quad\quad j=1,2,\dots,n\\l_{i1}=\frac{a_{i1}}{u_{11}},\quad\quad\quad\quad\quad i=2,3,\dots,n\\u_{ij}=a_{ij}-\sum_{k=1}^{i-1}l_{ik}u_{kj},\quad\quad\quad\quad\quad i=2,3,\dots,n;j=i,i+1,\dots,n\quad\quad\quad（2）\\l_{ij}=\frac{a_{ij}-\sum_{k=1}^{j-1}l_{ik}u_{kj}}{u_{jj}},\quad\quad j=2,3,\dots,n-1;i=j+1,j+2,\dots,n\end{array}\right.</script>]]></content>
      
      
      <categories>
          
          <category> Numerical Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Singleton Pattern</title>
      <link href="/2019/07/01/singleton-pattern/"/>
      <url>/2019/07/01/singleton-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式——"><a href="#单例模式——" class="headerlink" title="单例模式——"></a>单例模式——</h1><p>单例模式是六中23种设计模式中最简单的一种，虽然如此单例模式还是有值得探讨的地方。</p><a id="more"></a><h3 id="单例模式的用处"><a href="#单例模式的用处" class="headerlink" title="单例模式的用处"></a>单例模式的用处</h3><p>顾名思义，单例模式就是想产生一个唯一的实例，而这样做的目的在于：</p><ul><li>对于某些频繁使用的全局对象，如果频繁地创建和销毁会占用很多的系统资源</li><li>在一些场景中，需要唯一的实例，比如序列号、资源管理器等，其本身要就具有唯一性。</li></ul><h3 id="单例模式的简介"><a href="#单例模式的简介" class="headerlink" title="单例模式的简介"></a>单例模式的简介</h3><p>单例模式一般分为两类，俗称懒汉式和饿汉式——懒汉式是指当真正要使用到这个对象时才去创建这个对象；而饿汉式则是在程序运行之初就完成对象的创建。</p><p>要想实现单例模式，首先就要把构造函数私有化，这样外部就无法通过调用构造函数来生成更多的实例了。但是这时就要对外提供产生实例的接口，并在内部完成单例的创建。</p><h3 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h3><ol><li><p>最简单的单例模式可以采用一个静态字段来保存单例，外界调用创建单例的方法时就把这个对象返回。静态字段会在程序一开始就初始化（由CLR实现），因此这是饿汉式的单例模式。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 最简单的单例模式，使用静态字段保存唯一单例，对外提供一个方法访问来获取单例</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">static</span> Singleton _singelton = <span class="keyword">new</span> Singleton();</span><br><span class="line">           <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>           &#123;</span><br><span class="line">   </span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">CreatInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>           &#123;</span><br><span class="line">               <span class="keyword">return</span> _singelton;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>上面这种单例模式的实现方式存在一定的问题，试想如果这个单例在程序运行一开始并没有被使用，它就会占据系统的资源，会影响程序的效率（一个典型的例子是数据库链接，会占用大量资源）。所以改进的单例模式使用Lazy Loading，也就是懒汉模式。</p><figure class="highlight c#"><figcaption><span>/// &lt;summary&gt;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 实现了Lazy Loading的单例模式，没有使用不会占用资源，但是它不是线程安全的</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton2</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 _singelton = <span class="literal">null</span>;</span><br><span class="line">          <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>          &#123;</span><br><span class="line">              Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">this</span>.GetType().Name&#125;</span> 被构造了"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Change</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>          &#123;</span><br><span class="line">              sum++;</span><br><span class="line">   </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">CreatInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>          &#123;</span><br><span class="line">              <span class="keyword">if</span> (_singelton == <span class="literal">null</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  _singelton = <span class="keyword">new</span> Singleton2();</span><br><span class="line">   </span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> _singelton;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>          &#123;</span><br><span class="line">              Console.WriteLine(_singelton.sum);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>上一种单例模式可以满足一般的需求，但当涉及到多线程并发时，上一种方法会尝试问题，因为它不是线程安全的，所以需要枷锁同步</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 实现了Lazy Loading并且是线程安全的,但是在高并发的情况下会产生等待</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton3</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 _singleton = <span class="literal">null</span>;</span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">object</span> locker = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line">           <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>           &#123;</span><br><span class="line">               Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">this</span>.GetType().Name&#125;</span> 被构造了"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Change</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>           &#123;</span><br><span class="line">               <span class="keyword">lock</span> (locker)</span><br><span class="line">                   sum++;</span><br><span class="line">   </span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">CreatInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>           &#123;</span><br><span class="line">   </span><br><span class="line">               <span class="keyword">lock</span> (locker)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span> (_singleton == <span class="literal">null</span>)</span><br><span class="line">                   &#123;</span><br><span class="line">                       _singleton = <span class="keyword">new</span> Singleton3();</span><br><span class="line">   </span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> _singleton;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>           &#123;</span><br><span class="line">               Console.WriteLine(_singleton.sum);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>现在已经接近完美了，但是任存在一个问题——性能的消耗，因为每次调用CreateInstance方法时，都要争取锁而排队，会造成阻塞。所以我们希望当单例完成创建后不要再排队，这就有名为了Double-Checked的单例模式</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 使用Double-check,与前一种方法一样，但是性能有提高，单例已生成的情况下不用等待</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton4</span></span><br><span class="line">       &#123;</span><br><span class="line">   </span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 _singelton = <span class="literal">null</span>;</span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">object</span> locker = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line">           <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>           &#123;</span><br><span class="line">               Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">this</span>.GetType().Name&#125;</span> 被构造了"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">CreatInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>           &#123;</span><br><span class="line">               <span class="keyword">if</span> (_singelton == <span class="literal">null</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">lock</span> (locker)</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="keyword">if</span> (_singelton == <span class="literal">null</span>)</span><br><span class="line">                       &#123;</span><br><span class="line">                           _singelton = <span class="keyword">new</span> Singleton4();</span><br><span class="line">   </span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> _singelton;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>现在事情似乎已经很完美了，但是如果细究一下我们会发现这样一个问题：当多个线程访问CreateInstance时，（单例还没有创建的情况下）它们都会进入第一个if语句开始排队，会有一个线程争得锁进入第二个if，然后调用构造函数创建单例，创建完后释放锁，第二个线程进入，第二个线程首先会检查_singleton的状态是否为空，现在问题就出现了，如果这个描述对象是否为空的属性如果没有及时更新，那么就会导致多个实例的产生。这种情况是可能存在的，这是编译器所决定的，由于读写无序则会导致前面的情况出现（先访问了实例是否存在的属性，之后才进行了这个属性的写操作）。改进的方法是在存储单例的静态字段前加上valotile关键词。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 也可以使用volatile关键字保证线程安全</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton5</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">object</span> locker = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton5 _singelton = <span class="literal">null</span>;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">CreatInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>          &#123;</span><br><span class="line">              <span class="keyword">if</span> (_singelton == <span class="literal">null</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">lock</span> (locker)</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="keyword">if</span> (_singelton == <span class="literal">null</span>)</span><br><span class="line">                      &#123;</span><br><span class="line">                          _singelton = <span class="keyword">new</span> Singleton5();</span><br><span class="line">                          Console.WriteLine(<span class="string">"Singleton 被构造了"</span>);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> _singelton;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><code>注：volatile关键字的作用是保证被它修饰的对象（包括引用类型、指针类型、整型、具有整数基类型的枚举类型、泛型等）是和改变同步的，即永远是最新的（可以理解为volatile修饰的对象写操作先于读操作），具体原理涉及内存的操作，此处不做叙述。</code></p></li></ol><h3 id="关于单例线程安全问题的直观验证"><a href="#关于单例线程安全问题的直观验证" class="headerlink" title="关于单例线程安全问题的直观验证"></a>关于单例线程安全问题的直观验证</h3><p>   根据上面封装的类，当我们运行如下代码时</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            List&lt;Task&gt; tasks1 = <span class="keyword">new</span> List&lt;Task&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Singleton2 singleton = Singleton2.CreatInstance();</span><br><span class="line">                tasks1.Add(Task.Run(() =&gt; singleton.Change()));</span><br><span class="line">            &#125;</span><br><span class="line">            Task.WaitAll(tasks1.ToArray());</span><br><span class="line">            Singleton2.Show();</span><br><span class="line">            Console.WriteLine(<span class="string">"***************************************************************"</span>);</span><br><span class="line">            List&lt;Task&gt; tasks2 = <span class="keyword">new</span> List&lt;Task&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Singleton3 singleton = Singleton3.CreatInstance();</span><br><span class="line">                tasks2.Add(Task.Run(() =&gt; singleton.Change()));</span><br><span class="line">            &#125;</span><br><span class="line">            Task.WaitAll(tasks2.ToArray());</span><br><span class="line">            Singleton3.Show();</span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>会得到如下的结果</p><p><img src="http://pte2s6ppx.bkt.clouddn.com/blog/20190701/kma17CT4h8bR.png?imageslim" alt="mark"></p><p>这样我们可以直观地看到线程安全问题确实存在。</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gaussian elimination method</title>
      <link href="/2019/06/27/Matrix/"/>
      <url>/2019/06/27/Matrix/</url>
      
        <content type="html"><![CDATA[<h1 id="求解矩阵的高斯消元法"><a href="#求解矩阵的高斯消元法" class="headerlink" title="求解矩阵的高斯消元法"></a>求解矩阵的高斯消元法</h1><p>高斯消元法是求解矩阵最基础的一种算法，具有泛化性强的优点。</p><a id="more"></a><h2 id="消元过程"><a href="#消元过程" class="headerlink" title="消元过程"></a>消元过程</h2><p>对于方程组$Ax=b$（其中A为n阶方阵）可由n-1个消元过程和n-1个回代过程完成求解</p><script type="math/tex; mode=display">\begin{cases}a_{11}x_1+a_{12}x_2+a_{13}x_3+\cdots+a_{1n}x_n=&b_1\\\vdots\\a_{n1}x_1+a_{n2}x_2+a_{n3}x_3+\cdots+a_{nn}x_n=&b_n&\end{cases}\\\begin{pmatrix}a_{11}&a_{12}&a_{13}&\dots&a_{1n}\\a_{21}&a_{22}&a_{23}&\dots&a_{2n}\\\vdots&&&&\vdots\\a_{n1}&a_{n2}&a_{n3}&\dots&a_{nn}\end{pmatrix}\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\end{pmatrix}=\begin{pmatrix}b_1\\b_2\\\vdots\\b_n\end{pmatrix}</script><ol><li><p>矩阵的消元过程(在矩阵有解的情况下)</p><ul><li>第一步消元</li></ul><p>$a_{ij}^{(1)}=a_{ij}^{(0)}-\frac{a_{i1}^{(0)}}  {a_{11}^{(0)}}a_{1j}^{(0)}=a_{ij}^{(0)}-l_{i1}^{(0)}a_{1j}^{(0)} ,\quad i=2,3,\dots,n;j=2,3,\dots,n$</p><p>$b_{i}^{(1)}=b_{i}^{(0)}-\frac{a_{i1}^{(0)}}  {a_{11}^{(0)}}b_{1}^{(0)}=b_{i}^{(0)}-l_{i1}^{(0)}b_{1}^{(0)} ,\quad i=2,3,\dots,n$</p><p>$l_{i1}\triangleq \frac {a_{i1}^{(0)}} {a_{11}^{(0)}},\quad i=2,3,\dots,n$</p><ul><li><p>第k步消元</p><p>$a_{ij}^{(k)}=a_{ij}^{(k-1)}-\frac{a_{ik}^{(k-1)}}  {a_{kk}^{(k-1)}}a_{kj}^{(k-1)}=a_{ij}^{(k-1)}-l_{ik}^{(k-1)}a_{kj}^{(k-1)} ,\quad i=k+1,k+2,\dots,n;j=k=1,k+2,\dots,n$</p><p>$b_{i}^{(k)}=b_{i}^{(k-1)}-\frac{a_{ik}^{(k-1)}}  {a_{kk}^{(k-1)}}b_{k}^{(k-1)}=b_{i}^{(k-1)}-l_{ik}^{(k-1)}b_{k}^{(k-1)} ,\quad i=k+1,k+2,\dots,n$</p><p>$l_{ik}\triangleq \frac {a_{ik}^{(k-1)}} {a_{kk}^{(k-1)}},\quad i=k+1,k+2,\dots,n$</p></li><li><p>消元完成后</p><script type="math/tex; mode=display">A^{(n-1)}=\begin{pmatrix}a_{11}^{(0)}&a_{12}^{(0)}&a_{13}^{(0)}&\cdots&\cdots&a_{1n}^{(0)}\\&a_{22}^{(1)}&a_{23}^{(1)}&\cdots&\cdots&a_{2n}^{(1)}\\&&\ddots\\&&&a_{kk}^{(k-1)}&\cdots&a_{kn}^{(k-1)}\\&&&&\ddots&\vdots\\&&&&&a_{nn}^{(n-1)}\end{pmatrix},\quadb^{(n-1)}=\begin{pmatrix}b_{1}^{(0)}\\b_{2}^{(1)}\\\vdots\\b_{k}^{(k-1)}\\\vdots\\b_{n}^{(n-1)}\end{pmatrix}</script></li></ul></li></ol><ol><li>回代的过程<script type="math/tex; mode=display">\left\{\begin{array}x_n=\frac{b_n^{n-1}}{a_{nn}^{(n-1)}}\\x_k=\frac{ {b_k}^{(k-1)-\sum_{j=k+1}^n(a_{kj}^{(k-1)}x_j)} } {a_{kk}^{(k-1)} },\quad k=n-1,n-2,\dots,2,1.\end{array}\right.</script></li></ol><h2 id="算法的分析"><a href="#算法的分析" class="headerlink" title="算法的分析"></a>算法的分析</h2><ul><li><p>[ ] 在消元的过程中，计算$l_{ik}\triangleq \frac {a_{ik}^{(k-1)}} {a_{kk}^{(k-1)}},\quad i=k+1,k+2,\dots,n$时共有n-k个除法，而计算$a_{ij}^{(k)}=a_{ij}^{(k-1)}-l_{ik}^{(k-1)}a_{kj}^{(k-1)} ,\quad i=k+1,k+2,\dots,n;j=k=1,k+2,\dots,n$时有$(n-k)^2$个乘法，计算$b_{i}^{(k)}=b_{i}^{(k-1)}-l_{ik}^{(k-1)}b_{k}^{(k-1)} ,\quad i=k+1,k+2,\dots,n$时也有n-k个乘法，消元共进行了n-1步，即$k=1,2,\dots,n-1$.</p></li><li><p>[ ] ==所以在消元过程中乘除法的运算量为==</p><script type="math/tex; mode=display">N_1=\sum_{k=1}^{n-1}((n-k)^2+2(n-k))=n^3/3+n^2/2-5n/6.</script></li></ul><ul><li><p>[ ] ==回代过程中乘除法的运算量为==</p><script type="math/tex; mode=display">   N_2=\sum_{k=1}^{n-1}(n-k)+n=n^2/2+n/2.</script><ul><li><p>[ ] ==所以高斯消元法解n阶矩阵的总乘除法运算量为==</p><p>$N=N_1+N_2=n^3/3+n^2-n/3$</p></li></ul></li></ul><h2 id="高斯消元法的程序实现"><a href="#高斯消元法的程序实现" class="headerlink" title="高斯消元法的程序实现"></a>高斯消元法的程序实现</h2><h6 id="我们可以封装一个Matrix类如下"><a href="#我们可以封装一个Matrix类如下" class="headerlink" title="我们可以封装一个Matrix类如下"></a>我们可以封装一个Matrix类如下</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Matrix</span><br><span class="line">&#123;</span><br><span class="line">    public int row = 0;</span><br><span class="line">    public int column = 0;           </span><br><span class="line">    private float[,] matrix;</span><br><span class="line">    public Matrix(int row, int column)</span><br><span class="line">    &#123;</span><br><span class="line">        this.row = row;</span><br><span class="line">        this.column = column;</span><br><span class="line">        matrix = new float[row, column];</span><br><span class="line">        for (int i = 0; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; column; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                string mid = Console.ReadLine();</span><br><span class="line">                var rows = mid.Split(&apos; &apos;);</span><br><span class="line">                foreach (var item in rows)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i, j++] = float.Parse(item);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void DisPlay()</span><br><span class="line">    &#123;                                         </span><br><span class="line">            for (int i = 0; i &lt; this.row; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                for (int j = 0; j &lt; this.column; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.Write(matrix[i, j] + &quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine(&quot;\r&quot;);</span><br><span class="line">            &#125;                </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Simplize()</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; this.row ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (matrix[i, i] != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                for (int k = i + 1; k &lt; row ; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[k, i] = matrix[k, i] / matrix[i, i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;//这里将消元的中间量存在被消元的位置，因为运算后，这些位置的值为零</span><br><span class="line">            for (int j = i + 1; j &lt; row; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                for (int k = i + 1; k &lt; column; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[j, k] = matrix[j, k] - matrix[j, i] * matrix[i, k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们输入</p><script type="math/tex; mode=display">\begin{pmatrix}1&2&1&0\\2&2&3&3\\-1&-3&0&2\end{pmatrix}</script><p>时，并调用Simplize和DisPlay方法，将得到结果如下</p><p><img src="http://pte2s6ppx.bkt.clouddn.com/blog/20190628/vVp4oxA9X7eB.png?imageslim" alt="mark"></p><p>事实上，这是一个矩阵的LU分解，LU分解在矩阵的研究中有着重要的地位，是十分常用的一个分解方法。</p><h2 id="高斯消元法的缺点"><a href="#高斯消元法的缺点" class="headerlink" title="高斯消元法的缺点"></a>高斯消元法的缺点</h2><ul><li>高斯消元法的运算量较大</li><li>高斯消元法的顺利进行要求矩阵满足某些要求</li></ul>]]></content>
      
      
      <categories>
          
          <category> Numerical Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Decoractor Pattern</title>
      <link href="/2019/06/27/Decoractor-Pattern/"/>
      <url>/2019/06/27/Decoractor-Pattern/</url>
      
        <content type="html"><![CDATA[<p>装饰器模式是一个很著名的设计模式，经常被用于有切面需求的场景，比如插入日志、统计等的逻辑。装饰器模式的作用是能为已经存在的对象添加额外的功能。</p><a id="more"></a><h1 id="设计模式之装饰器模式"><a href="#设计模式之装饰器模式" class="headerlink" title="设计模式之装饰器模式"></a>设计模式之装饰器模式</h1><h2 id="装饰器模式的作用"><a href="#装饰器模式的作用" class="headerlink" title="装饰器模式的作用"></a>装饰器模式的作用</h2><ul><li>在不改变现有对象结构的基础上为其添加新的功能，且并不通过继承而是通过对象之间的关联来实现，使其更加灵活。</li><li>相比于继承来增加新功能（固定的），装饰器模式可以动态的增加新功能，并且功能之间可以进行组合来产生更多的功能，避免了增加功能时对对象的修改</li><li>这是一种实现AOP（面向切面编程）的方法，即将主业务逻辑之外的aspect抽离出来，降低代码的耦合度。</li></ul><h2 id="实现装饰器模式的关键"><a href="#实现装饰器模式的关键" class="headerlink" title="实现装饰器模式的关键"></a>实现装饰器模式的关键</h2><p>装饰器模式无非是要调用一堆方法，但是又不能直接在类中增加逻辑（开闭原则），也不通过继承来实现，而是交给装饰器来实现。那么问题的关键就在于保存这一堆方法，并且使他们之间的顺序可以动态的调整。装饰器模式是通过字段对方法进行缓存（实际上是缓存一个对象，然后调用对象的方法），再通过迭代调用将各个方法以一定的顺序连接起来</p><h2 id="装饰器实现步骤"><a href="#装饰器实现步骤" class="headerlink" title="装饰器实现步骤"></a>装饰器实现步骤</h2><ol><li><p>建立一个继承自对象抽象类的装饰器基类，其中包括缓存字段，构造函数和方法调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class BaseStudentDecorator : AbstractStudent</span><br><span class="line">    &#123;</span><br><span class="line">        private AbstractStudent _student = null;//用于缓存一个对象</span><br><span class="line">        public BaseStudentDecorator(AbstractStudent student)</span><br><span class="line">        &#123;</span><br><span class="line">            this._student = student;</span><br><span class="line">        &#125;</span><br><span class="line">        public override void Finish()</span><br><span class="line">        &#123;</span><br><span class="line">            this._student.Finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>依照单一职责原则创建实现具体功能的装饰器，在其中调用父类的构造函数并复写父类的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public StudentLearningDecoractor(AbstractStudent student) : base(student)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        public override void Finish()</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                //你要实现的逻辑</span><br><span class="line">            &#125;</span><br><span class="line">            base.Finish();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">//创建多个，根据要实现的逻辑</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>对装饰器要实现的功能进行注册并调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">student = new StudentPreviewDecoractor(student);</span><br><span class="line">          student = new StudentLearningDecoractor(student);//添加了一个功能</span><br><span class="line">          student = new StudentReviewDecorator(student);//添加了一个功能</span><br><span class="line">          student = new StudentPlayDecoractor(student);//添加了一个功能</span><br><span class="line">          student = new StudentSleeepDecorator(student);//添加了一个功能</span><br><span class="line">          student.Finish();//调用</span><br></pre></td></tr></table></figure></li></ol><p>   抽象类和具体类</p>   <figure class="highlight plain"><figcaption><span>public abstract class AbstractStudent</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractStudent</span><br><span class="line">   &#123;</span><br><span class="line">       public int Id &#123; get; set; &#125;</span><br><span class="line">       public string Name &#123; get; set; &#125;</span><br><span class="line">       public abstract  void Finish();</span><br><span class="line">   &#125;</span><br><span class="line">   public class StudentCommon:AbstractStudent</span><br><span class="line">   &#123;</span><br><span class="line">       public override void Finish()</span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine($&quot;&#123;base.Name&#125; finished learning&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       public class StudentPreview: StudentCommon</span><br><span class="line">       &#123;</span><br><span class="line">           public override void Finish()</span><br><span class="line">           &#123;</span><br><span class="line">               base.Finish();</span><br><span class="line">               Console.WriteLine(&quot;先进行复习&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>   运行结果：</p><p>   <img src="http://pte2s6ppx.bkt.clouddn.com/blog/20190627/5ckTbxL1rvl1.png?imageslim" alt="mark"></p><h2 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h2><ul><li><p>[ ] 当我们在注册方法时，student（不同类型）对象会被保存在基类中</p></li><li><p>[ ] 当我们最后调用finish方法时，会先调用StudentSleeepDecorator的finish方法，finish方法又会调用基类的finish方法，而基类的finish方法会调用之前缓存的student的finish方法…..，从而形成了一系列的调用，相当于一个链表结构。</p></li><li><p>[ ] 在我们实现具体的装饰器时，==base.Finish()和你要实现的逻辑的顺序直接影响到这些逻辑调用的顺序==。当你要实现的逻辑放在前面时，相当于堆栈，遵从先进后出的原则，因此先注册的方法会最后执行（1）；当base.Finish()放在前面时，相当于队列，遵从先进先出，因此先注册的方法最先执行（2）。</p></li><li><p>[ ] 所以当我们要实现在主逻辑（这里为Console.WriteLine($”{base.Name} finished learning”)，即已有对象的方法）前增加若干方法，在主逻辑后也增加若干方法时：</p><ul><li><p>在编写装饰器时时，对于主逻辑之前要执行的方法应按上述（1）来编写装饰器；而对于主逻辑之后要执行的方法应按上述（2）来编写装饰器。</p></li><li><p>在注册时，对于主逻辑之前要执行的方法要逆序注册；对于主逻辑之后要执行的方法要顺序注册</p></li></ul></li></ul><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>  观察者模式较其他设计模式来说要更难以理解，相要真正理解还是得自己敲一下代码，断点运行一下。</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-观察者模式</title>
      <link href="/2019/06/27/Observer%20Pattern/"/>
      <url>/2019/06/27/Observer%20Pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之观察者模式"><a href="#设计模式之观察者模式" class="headerlink" title="设计模式之观察者模式"></a>设计模式之观察者模式</h1><a id="more"></a><h2 id="什么是观察者模式"><a href="#什么是观察者模式" class="headerlink" title="什么是观察者模式"></a><strong>什么是观察者模式</strong></h2><p>形象的来说，观察者模式包含一个被观察者（subject）以及若干观察者（observer），observer观察subject，当subject发出一个动作时，observer观察到后作出相应反应。在程序中则是某个类（subject）达到某种触发条件后向其他类发送通知（通常是执行某些方法的信息），然后这些类执行相应的方法。</p><h2 id="观察者模式的作用"><a href="#观察者模式的作用" class="headerlink" title="观察者模式的作用"></a><strong>观察者模式的作用</strong></h2><ol><li>用于程序的解耦。观察者模式通过依赖于抽象的接口来减少类与类之间的直接依赖。</li><li>可以作为一种通知的机制，将更新通知给其它的对象。</li></ol><h2 id="观察者模式的缺点"><a href="#观察者模式的缺点" class="headerlink" title="观察者模式的缺点"></a><strong>观察者模式的缺点</strong></h2><ul><li>当一个被观察者有很多的直接或间接的观察者时，要通知到所有的观察者需要耗费很多的时间。</li><li>当被观察者之间循环依赖时（比如：A通知B改变C，C的改变引起A的改变，继而又触发了A通知B），程序会进入循环调用，导致系统崩溃。</li></ul><h2 id="观察者模式的实现要点"><a href="#观察者模式的实现要点" class="headerlink" title="观察者模式的实现要点"></a><strong>观察者模式的实现要点</strong></h2><ol><li>要创建一个接口用以约束所有被观察者，提供消息传递的通道</li><li>被观察者需要有一个存放消息的容器，一般是接口的一个列表；同时被观察者要具有订阅观察者和取消订阅的方法，用以动态的增加减少观察者的数量。</li><li>实现消息的传递——通过调用接口列表中的各个方法。</li></ol><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"> class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Cat cat = new Cat();</span><br><span class="line">            cat.Add(new Dog());</span><br><span class="line">            cat.Add(new Duck());</span><br><span class="line">            cat.Add(new mouse());           </span><br><span class="line">            cat.Add(new people());</span><br><span class="line">            cat.Miao();</span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">interface Ioberver</span><br><span class="line">&#123;</span><br><span class="line">        void Action();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">class Chicken:Ioberver</span><br><span class="line">    &#123;</span><br><span class="line">        public void Action()</span><br><span class="line">        &#123;</span><br><span class="line">            this.Woo();</span><br><span class="line">        &#125;</span><br><span class="line">        public void Woo()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;&#123;0&#125; Woo&quot;, this.GetType().Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">class Dog : Ioberver</span><br><span class="line">    &#123;</span><br><span class="line">        public void Action()</span><br><span class="line">        &#123;</span><br><span class="line">            this.Wang();</span><br><span class="line">        &#125;</span><br><span class="line">        public void Wang()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;&#123;this.GetType().Name&#125; 汪汪汪&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">class Duck : Ioberver</span><br><span class="line">    &#123;</span><br><span class="line">        public void Action()</span><br><span class="line">        &#123;</span><br><span class="line">            this.Gaga();</span><br><span class="line">        &#125;</span><br><span class="line">        public void Gaga()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;&#123;this.GetType().Name&#125; 嘎嘎嘎&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> class mouse : Ioberver</span><br><span class="line">    &#123;</span><br><span class="line">        public void Action()</span><br><span class="line">        &#123;</span><br><span class="line">            this.Zhi();</span><br><span class="line">        &#125;</span><br><span class="line">        public void Zhi()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;&#123;this.GetType().Name&#125; 吱吱吱&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Cat</span><br><span class="line">&#123;</span><br><span class="line">        public void Miao()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;&#123;0&#125; miao&quot;,this.GetType().Name);</span><br><span class="line">            if(this._ObserverList!=null &amp;&amp; this._ObserverList.Count &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                foreach (var observer in _ObserverList)</span><br><span class="line">                &#123;</span><br><span class="line">                    observer.Action();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public List&lt;Ioberver&gt; _ObserverList = new List&lt;Ioberver&gt;();</span><br><span class="line">        public void Add(Ioberver observer)</span><br><span class="line">        &#123;</span><br><span class="line">            this._ObserverList.Add(observer);</span><br><span class="line">        &#125;</span><br><span class="line">        public void Remove(Ioberver observer)</span><br><span class="line">        &#123;</span><br><span class="line">            this._ObserverList.Remove(observer);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><a href="http://pte2s6ppx.bkt.clouddn.com/blog/20190627/Pwc2H0fM3pGs.png?imageslim" target="_blank" rel="noopener"><img src="http://pte2s6ppx.bkt.clouddn.com/blog/20190627/Pwc2H0fM3pGs.png?imageslim" alt="mark"></a></p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShortCut Key for Typora</title>
      <link href="/2019/06/21/Tips%20for%20Typora/"/>
      <url>/2019/06/21/Tips%20for%20Typora/</url>
      
        <content type="html"><![CDATA[<p>刚建立了自己的博客，来发一篇文章:smiley:</p><p>最近刚学会使用Typora，刚好把一些快捷键整理一下。</p><a id="more"></a><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><ol><li><p>标题    ctrl+1/2/3…</p><p>数字表示标题的级数 </p></li><li><p>下划线    ctrl+u</p><p>效果：<u>这是下划线</u></p></li><li><p>删除线    shift+alt+5</p><p>效果：<del>这是删除线</del></p></li><li><p>字体加粗    ctrl+b</p><p>效果：<strong>加粗了</strong></p></li><li><p>字体倾斜   ctrl+i</p><p>效果：<em>倾斜的字</em></p></li><li><p>无序列表   -+space+内容</p><p>效果  </p><ul><li>牛奶</li><li>面包<ul><li>巧克力（可嵌套）</li></ul></li></ul></li><li><p>引用   &gt;+space或ctrl+shift+q</p><blockquote><p>效果：这是引用</p></blockquote></li><li><p>插入地址   ctrl+k</p><p><a href="www.baidu.com">百度</a></p></li><li><p>插入表格   ctrl+t</p><p>效果：</p></li></ol><div class="table-container"><table><thead><tr><th>周一</th><th>周二</th><th>周三</th><th>周四</th><th>周五</th></tr></thead><tbody><tr><td>微积分</td><td>放假</td><td>放假</td><td>放假</td><td>放假</td></tr><tr><td>大学物理</td><td>放假</td><td>放假</td><td>放假</td><td>放假</td></tr><tr><td>英语</td><td>放假</td><td>放假</td><td>放假</td><td>放假</td></tr></tbody></table></div><ol><li><p>回到文章顶部   ctrl+home</p><p>效果：无法展示:joy:</p></li><li><p>自动产生目录   [TOC]+enter</p><p>效果：(只有一个标题，将就看一下效果)</p><p>[TOC]</p></li><li><p>选中一整行   ctrl+l</p><p>额，无法展示效果</p></li><li><p>插入代码块   ctrl+alt+b(可能需要自己设置)</p><p>效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Diagnostics;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">public static void main(string[]args)&#123;</span><br><span class="line">    ConSole.WriteLine(&quot;Hello World&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>搜索内容   ctrl+f    替换   ctrl+h</p><p>效果：无</p></li><li><p>强调、着重标记   ctrl+shift+~(tab上面那个)</p><p>效果：<code>这是重点 这是重点 则是重点</code></p></li><li><p>分隔线   —-+enter或<em>*</em>+enter</p><p>效果：</p><hr></li></ol><ol><li><p>数学公式   $$+enter</p><p>效果：</p><script type="math/tex; mode=display">|i j k |a+b+c^5=2ab</script></li><li><p>表情   :+表情的英文单词</p><p>效果：:artificial_satellite:</p></li><li><p>快速创建新文件   ctrl +n    快速关闭  ctrl+w</p></li><li><p>显示/隐藏大纲   ctrl+shift+l</p></li><li><p>高亮   == 文字 ==（中间没有空格）</p></li><li><p>标题变为普通文本   ctrl+0</p></li><li><p>脚注   <sup><a href="#fn_" id="reffn_"></a></sup></p><p>效果：这是一个脚注<sup><a href="#fn_1" id="reffn_1">1</a></sup></p></li><li><p>行内数学公式   $+esc(然后输入Tex命令)</p></li></ol><p>$\lim_{x\to\infty}\exp(-x)=0$</p><ol><li><p>上下标   <code>x^2^2</code>   <code>H~2~O</code></p><p>效果：x^2^   H~2~O</p></li></ol><blockquote id="fn_1"><sup>1</sup>. 注释<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文本编辑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my first blog</title>
      <link href="/2019/06/21/my-first-blog/"/>
      <url>/2019/06/21/my-first-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="这是我的第一篇blog"><a href="#这是我的第一篇blog" class="headerlink" title="这是我的第一篇blog"></a>这是我的第一篇blog</h1><h2 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h2><p>终于成功了很开心</p><p>:happy:</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
