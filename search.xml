<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C#泛型</title>
      <link href="2020/12/26/c-%E6%B3%9B%E5%9E%8B/"/>
      <url>2020/12/26/c-%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="C-泛型"><a href="#C-泛型" class="headerlink" title="C#泛型"></a>C#泛型</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Usage of bit operation</title>
      <link href="2019/12/30/usage-of-shift-operation/"/>
      <url>2019/12/30/usage-of-shift-operation/</url>
      
        <content type="html"><![CDATA[<h1 id="位运算的用法"><a href="#位运算的用法" class="headerlink" title="位运算的用法"></a>位运算的用法</h1><p>除了逻辑运算，位运算也是编程中常用的运算，但是很多人对于位运算知之甚少。一个原因是因为位运算的用法很零碎，并且有的用法涉及计算机底层的原理所以理解起来比较困难。但是位运算是效率很高的一种运算，特别是在编写单片机的程序时，活用位运算可以节约内存资源和单片机有限的算力。</p><a id="more"></a><h3 id="位运算的定义"><a href="#位运算的定义" class="headerlink" title="位运算的定义"></a>位运算的定义</h3><ol><li><p>按位与（&amp;）</p><p>与字面意思一样，就是将两个二进制数（计算机内存储都是二进制）对应的每一位做与运算</p><p>如：01001101 &amp; 11010011 = 01000001</p></li><li><p>按位或（|）</p><p>与字面意思一样，就是将两个二进制数对应的每一位做或运算</p><p>如：00110101 | 01010010 = 01110111</p></li><li><p>按位异或（^）</p><p>与字面意思一样，就是将两个二进制数对应的每一位做异或<sup><a href="#fn_1" id="reffn_1">1</a></sup>运算</p><p>如：01001110 ^ 00111100 = 01110010</p></li><li><p>取反（~）</p><p>取反运算是将原来是0的变为1，原来是1的变为0</p><p>如：~010100111 = 101011000</p></li><li><p>左移（&lt;&lt;）</p><p>左移运算是将原来的数整体向左移动指定位数</p><p>如：11000111 &lt;&lt; 1 = 10001110</p></li><li><p>右移（&gt;&gt;）</p><p>左移运算是将原来的数整体向右移动指定位数</p><p>如：10101011 &gt;&gt; 1 = 01010101</p></li></ol><p><code>Tips:“&amp;”是偏向于0的，因此常用于置零操作；“|”是偏向于1的，因此常用于置1操作；“^”常用于检测异同；“&lt;&lt;"和“&gt;&gt;”常用于乘除。</code></p><h3 id="位运算的一些性质"><a href="#位运算的一些性质" class="headerlink" title="位运算的一些性质"></a>位运算的一些性质</h3><ol><li><p>与“1”的不变性</p><p>1&amp;1=1    0&amp;1=0</p><p>从上面的两个式子我们可以看出某一位“与”上1，其结果只取决于这一位，即保留了原来的性质</p></li><li><p>或“0”的不变性</p><p>1|0=1    0|0=0</p><p>从上面的两个式子我们可以看出某一位“或”上1，其结果只取决于这一位，即保留了原来的性质</p></li><li><p>与“0” = 清零</p><p>1&amp;0=0    0&amp;0=0</p><p>显而易见某一位“与”上0一定为0</p></li><li><p>或“1” = 置1</p><p>1|1=1    0|1=1</p><p>显而易见某一位“或”上0一定为0</p></li><li><p>异或“1”的取反性</p><p>0^1=1    1^1=0</p><p>从上面的两个式子我们可以看出某一位“异或”上1，其结果与原来相反</p></li><li><p>异或“0”的不变性</p><p>0^0=0    1^0=1</p><p>从上面的两个式子我们可以看出某一位“异或”上0，其结果与原来相同</p></li></ol><h3 id="位运算的用法-1"><a href="#位运算的用法-1" class="headerlink" title="位运算的用法"></a>位运算的用法</h3><ul><li><h4 id="快速乘除2的幂"><a href="#快速乘除2的幂" class="headerlink" title="快速乘除2的幂"></a>快速乘除2的幂</h4><p>由于移位运算的的特点，我们可以发现左移1位的效果就是乘以二，下面给出简单的证明</p><script type="math/tex; mode=display">suppose\quad  (x)_{2}=a_{1}a{2}\dots a_{n}=1*a_{n}+2*a_{n-1}+\dots +2^{n-1}a_{1}\\x<<1=a_{1}a{2}\dots a_{n}0=2*a_{n}+4*a_{n-1}+\dots +2^{n}a_{1}\\\therefore x<<1=2*x</script><p>同理右移1位就是除二，但是这里是整除，因为右移会丢弃最后一位，即奇数会丢失1然后除以二；偶数则是直接除以二。</p><p>移位操作并不局限于乘除2的幂，对于乘法运算，完全可以通过2的幂来组合，如3*x=x&lt;&lt;1+x，不过这样还需要先求乘数的二进制数，反而没有直接计算来的方便。</p></li></ul><ul><li><h4 id="判断一个数的奇偶性"><a href="#判断一个数的奇偶性" class="headerlink" title="判断一个数的奇偶性"></a>判断一个数的奇偶性</h4><p>由于二进制数的特点，奇偶性在二进制数中体现在最后一位是否为1，因此我们可以通过位运算来判断</p><script type="math/tex; mode=display">x\&(1)= 1 \Rightarrow x为奇数\\x\&(1)= 0 \Rightarrow x为偶数</script></li><li><h4 id="判断两个数是否相同"><a href="#判断两个数是否相同" class="headerlink" title="判断两个数是否相同"></a>判断两个数是否相同</h4><p>由异或运算的定义，a^b==0则a与b 相同，反则不同</p></li></ul><ul><li><h4 id="取反第n位"><a href="#取反第n位" class="headerlink" title="取反第n位"></a>取反第n位</h4><p>由位运算的性质，我们可以知道一定要用异或操作，并且我们需要构造一个数，它的第n位为1，其余位为0，那么某个数与它异或后只会取反第n位，所以</p><p>​                                                            <img src="http://src.zhumingcj.cn/blog/20191230/ELaChye3Fm4v.png?imageslim" alt="mark"></p></li></ul><ul><li><h4 id="置零第n位"><a href="#置零第n位" class="headerlink" title="置零第n位"></a>置零第n位</h4><p>由位运算的性质，我们可以知道一定要用与操作，并且我们要构造一个数，它的第n位是0，其余位是1，那么某个数与它与之后只会置零第n位，所以</p><p>​                                                            <img src="http://src.zhumingcj.cn/blog/20191230/WHIFbwDJDw84.png?imageslim" alt="mark"></p><p>一般的，置零x的第$a_{1},a_{2}\dots,a_{n}$位 = x&amp;$((~0)$^$((1&lt;&lt;a_{1})+(1&lt;&lt;a_{2})+\dots +(a&lt;&lt;a_{n})))$</p></li><li><h4 id="置1第n位"><a href="#置1第n位" class="headerlink" title="置1第n位"></a>置1第n位</h4><p>与置零类似，这次我们需要用到或操作，并且我们要构造一个数，它的第n位是1，其余位是0，那么某个数与它与之后只会把第n位置1，所以</p><p>​                                                            <img src="http://src.zhumingcj.cn/blog/20191230/LOM5YrV5qBsR.png?imageslim" alt="mark"></p><p>一般的，置1 x的第$a_{1},a_{2}\dots,a_{n}$位 = x|$((1&lt;&lt;a_{1})+(1&lt;&lt;a_{2})+\dots +(a&lt;&lt;a_{n}))$</p></li></ul><ul><li><h4 id="交换两个数"><a href="#交换两个数" class="headerlink" title="交换两个数"></a>交换两个数</h4><p>​                                                            <img src="http://src.zhumingcj.cn/blog/20191230/p3KorGa05oik.png?imageslim" alt="mark"></p><p>第一次取异或后，a保存了a与b每一位的情况，相同的为0，不同的为1；第二次异或时，根据位运算的性质，结果保留了b中与a相同的位，不同的取反，所以b的值变成了a，第三次情况与第二次相同，最后a与b实现了交换。</p><p>​                                                            <img src="http://src.zhumingcj.cn/blog/20191230/wGkv2gwWnWFs.png?imageslim" alt="mark"></p><p>词表达式一步到位，根据右结合的规则不难理解，但是需要指出的是这种方法反而比传统的交换（借助第三变量）效率更低，我们可以通过下面的测试看到其中的原因。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">34</span>, b = <span class="number">165</span>;</span><br><span class="line">  a = a ^ b;</span><br><span class="line">  b = b ^ a;</span><br><span class="line">  a = a ^ b;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, a, b);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure></li></ul><p>  我调试上面的代码并查看反汇编可以看到异或交换进行了六次读写三次异或</p><p>  <img src="http://src.zhumingcj.cn/blog/20191230/fathRS1JEcRj.png?imageslim" alt="mark"></p><p>  但是传统的代码如下，通过反汇编窗口我们发现传统方法只用了六次读写，当然要更快一些。</p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">34</span>, b = <span class="number">165</span>;</span><br><span class="line">  <span class="keyword">int</span> temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, a, b);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>  <img src="http://src.zhumingcj.cn/blog/20191230/KOdKgEGWkAte.png?imageslim" alt="mark"></p><p>  当然情况也会因为平台有所差别，上述测试均在VS2017上进行，本人也试过DEV，结果异或交换只要三次读写三次异或，而传统交换需要六次读写，所以，总的来说传统方法还是效率更高，至少也会比异或交换差。</p><p>  此处顺便提一下另一种不借助第三个变量交换两个值的方法：</p><p>  ​                                                            <img src="http://src.zhumingcj.cn/blog/20191230/lvwm2nc17zA8.png?imageslim" alt="mark">    </p><p>  自行体会，不做解释（懒）</p><ul><li><h4 id="取相反数"><a href="#取相反数" class="headerlink" title="取相反数"></a>取相反数</h4><p>由原码和补码的关系我们可以知道</p><p>​                                                            <img src="http://src.zhumingcj.cn/blog/20191230/q4BkMXsDOwjp.png?imageslim" alt="mark"></p></li></ul><ul><li><h4 id="保留第n位，清零其他位"><a href="#保留第n位，清零其他位" class="headerlink" title="保留第n位，清零其他位"></a>保留第n位，清零其他位</h4><p>根据性质，我应该用“&amp;”运算，并且需要构造一个数，它的第n位是1，它的其余位是0</p><p>​                                                            <img src="http://src.zhumingcj.cn/blog/20191230/jMvomgJ3zGyc.png?imageslim" alt="mark"></p></li><li><h4 id="求十进制数的二进制"><a href="#求十进制数的二进制" class="headerlink" title="求十进制数的二进制"></a>求十进制数的二进制</h4><p>因为计算机内存储的都是二进制，所以我们只要将它打印出来就行，通过x&amp;1可以判断x的最后一位是1还是零，只要我们写个循环，每次右移1然后判断最后一位是什么，把结果存入栈，最后从栈中输出就得到了十进制数的二进制形式，或者从高位开始遍历就直接输出。</p></li></ul><ul><li><h4 id="翻转最低位的1"><a href="#翻转最低位的1" class="headerlink" title="翻转最低位的1"></a>翻转最低位的1</h4><p>要翻转最低位的1，前提是我们能找到最低位的1。那么我们该如何“找”到最低位的1呢？就这么找肯定是不行的，我们可以给一个“微小的扰动”——$\pm1$，。由于二进制每一位只能是1或1，所以当我们计算x-1时，x就会向最低位的1借位，从某种意义上我们就找到了最低位的1。我们举个例子看看减一会发生什么</p><p>​                                                            <img src="http://src.zhumingcj.cn/blog/20191230/5sBrGBM7mWiY.png?imageslim" alt="mark"></p><p>可以发现x-1与x最低位1前面的位相同，而最低位1以及后面的位发生反转，根据性质可得计算方法</p><p>​                                                        <img src="http://src.zhumingcj.cn/blog/20191230/kurYlr2i9VCK.png?imageslim" alt="mark"></p><p>稍作引申，我们可以得到统计某个二进制数1位的数量，我只要不断重复上述操作，每次讲数量++，直到x变为0就得到了1的数量</p></li></ul><ul><li><h4 id="循环左移2-循环右移k位（suppose-sizeof-int-32"><a href="#循环左移2-循环右移k位（suppose-sizeof-int-32" class="headerlink" title="循环左移2/循环右移k位（suppose    sizeof(int)=32)"></a>循环左移<sup><a href="#fn_2" id="reffn_2">2</a></sup>/循环右移k位（suppose    sizeof(int)=32)</h4><p>直接给出循环左移的计算式：</p><p>​                                                            <img src="http://src.zhumingcj.cn/blog/20191230/I1i9VeQkIh1o.png?imageslim" alt="mark"></p><p>其实也很好理解，循环左移一定是要左移的，但是超出部分要放到末尾就相当于右移，最后要把两个结果拼接起来就用“或”运算。</p></li></ul><ul><li><h4 id="二进制加法器"><a href="#二进制加法器" class="headerlink" title="二进制加法器"></a>二进制加法器</h4><p>虽然二进制的加法看似简单，但是如果我们自己来实现也得费一点力，因为我们不仅要将每一位相加还得处理进位的问题。但是如果我们把这两个过程分开考虑，问题就迎刃而解。下面是实现加法器的代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="comment">//进位为0，运算结束</span></span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//计算两数之和，忽略进位</span></span><br><span class="line">    <span class="comment">//两二进制数相加，对应为不同结果为1否则为0，符合异或</span></span><br><span class="line">    <span class="keyword">int</span> sum=a^b;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算进位</span></span><br><span class="line">    <span class="comment">//两二进制数对应位相同产生进位，符合与运算</span></span><br><span class="line">    <span class="comment">//进位应当是高一位置1，故左移一位</span></span><br><span class="line">    <span class="keyword">int</span> carry=(a&amp;b)&lt;&lt;<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//递归调用，进位与直接和相加可能产生新的进位</span></span><br><span class="line">    <span class="keyword">return</span> add(sum,carry);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><h4 id="求平均数"><a href="#求平均数" class="headerlink" title="求平均数"></a>求平均数</h4><p>如果理解了二进制加法器，那么我们也可以找到一种求两个数平均数的方法（取整后的平均数），下面先给出计算的方法：</p><p>​                                                            <img src="http://src.zhumingcj.cn/blog/20191230/7FzyOPvQRwuR.png?imageslim" alt="mark"></p><p>其中的加法可以直接使用上面的二进制加法器，原来和二进制加法器一样，分两部分计算：a+b产生的进位一定是个偶数，所以其均值应为((a&amp;b)&lt;&lt;1)&gt;&gt;1 = a&amp;b；a+b忽略进位的和为a\^b，平均值为(a^b)&gt;&gt;1(这一步运算会发生取整),最后结果就是上面的式子。<!--1)--></p></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>位运算的使用是有限制的，可以进行位运算的只能是无符号的整型，即char、short、int、long,对于有符号的整型虽然理论上也支持位运算，但是其结果可能因为机器不同而结果不同（主要是由于不同机器对符号位的处理可能有不同规定）。</p><blockquote id="fn_1"><sup>1</sup>. 异或运算结果为：相同为0，不同为1。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> ↩</a></blockquote><blockquote id="fn_2"><sup>2</sup>. 循环左移的意思是，限定的长度下，每一位向左移，超出的补到末尾，举个例子就是游戏中人物超出屏幕会从另一边出来。<a href="#reffn_2" title="Jump back to footnote [2] in the text."> ↩</a></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移位操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Divide-and-Conquer</title>
      <link href="2019/11/17/divide-and-conquer/"/>
      <url>2019/11/17/divide-and-conquer/</url>
      
        <content type="html"><![CDATA[<h1 id="递归分治算法（1）"><a href="#递归分治算法（1）" class="headerlink" title="递归分治算法（1）"></a>递归分治算法（1）</h1><p>孙子兵法有云：“十则围之，五则攻之，倍则分之，敌则能战之，不若则能避之”，这句话的意思是说，十倍的兵力就合围；五倍的兵力就强攻；两倍的兵力就分散敌人，逐个击破；能打就打，不能打就跑——在不同的兵力下，有不同的应对策略。将兵法应用于编程：当计算能力足够的情况下，我们可以采取暴力的方法求解问题，但是当计算能力不足的时候，我们应该将问题分割，逐个求解，这也就是分治的思想。但是“Divide and rule, a sound motto,. Unite and lead, a better one”，翻译过来就是：分而治之是至理名言，和而御之却更显明智。分治算法的难点并不在于分而在于和，分的策略可能有很多种，但是如果分完后不能合起来那就是失败的。</p><a id="more"></a><h3 id="如何分？"><a href="#如何分？" class="headerlink" title="如何分？"></a>如何分？</h3><p>分治算法首先讲求一个“分”字，那么该如何来分呢？其实分是没有固定标准的，但是采用的“分法”必需能够“合”起来，下面给出几条经验总结：</p><ul><li><strong>根据问题的特点，通过恰当的分法使事物的规模降低或将问题分为若干小问题。这一点实际上在程序中随处可见，不仅仅是算法，我们将程序模块化，抽象出函数，采用面向对象的编程思维都是一种分的体现。切记如果问题在分解后没有得到简化反而复杂化了，那么这种分法是不可取的。</strong></li><li><strong>在分解问题时尽量去靠近已经解决的问题。如果一个问题如果通过某种分解方法可以得到几个子问题，而这几个子问题已经有很好的解决方法或者通过简单的变换可以转换为已经解决的问题，那么原问题就能得到很好的解决。</strong></li><li><strong>找到递归的模式。有时候一个问题分一次可能并不能解决问题，但是如果分得的子问题具有与原问题具有一样的形式只是规模缩小了，那么我们继续分割子问题就可以达到这个问题的最小子问题，而这个最小子问题能够很好的被解决，那么我们就可以递归的解决问题。</strong></li></ul><h4 id="怎么和？"><a href="#怎么和？" class="headerlink" title="怎么和？"></a>怎么和？</h4><p>如果是分为若干子问题，那么求解出这些子问题原问题就得到了解决；如果采用递归的方法，那么我们就需要找到子问题与它的父问题的联系，逐层递归最终得到原问题的解。怎么和是很难用言语概况的，针对不同的问题，和的方法都不尽相同。下面我希望通过经典的排序问题对“怎么合”这个问题给出一个解答。</p><h3 id="分治算法的经典例子——排序"><a href="#分治算法的经典例子——排序" class="headerlink" title="分治算法的经典例子——排序"></a>分治算法的经典例子——排序</h3><p>传统的排序算法（暴力法）常见的有冒泡排序和选择排序，但是无论哪种排序都使用了双重循环，也就是说他们的复杂的都为$O(n^{2})$，这个复杂的已经算很高了，在如今大数据的时代，可能一个库里有上亿的数据量，这个时候传统排序耗费的时间太长，也就是目前的计算能力还开销不起，因此提高排序算法的效率是十分必要的。改进的排序算法有很多种，但是几乎都采用了分治的策略，下面我们以其中两种为例进行分析：</p><ol><li><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>快排是一种典型的白盒划分的分治算法，采用分治策略将算法复杂度下限降低到了$O(nlogn)$，相比暴力法效率有较大的提升。</p><p>快排的基本思想：</p><ul><li>“分”的策略：快排在分的时候以某个元素为基准把待排序的数组分成两堆，一堆大于基准，一堆小于基准。为了编程的方便，我们一般选取数组的第一个元素为基准，将大于第一个元素的放到一堆，小于第一个元素的放到另一边。这样原来的数组被划分为两部分（基准可以任选，取决于程序的编写）。</li><li>“和”的策略：在这个问题中，分一次显然无法得到问题的答案，但是分完后这两堆相比于原来的数组规模降低了但任保留了原问题的形式，即任是一个排序问题，只是排序的规模下降了，所以我们可以按照上面的分法继续分下去，当分到只有两个元素成一堆时就是原问题的最小子问题，这个时候我们只要比较大小交换位置就可以使最小子问题解决，由于此分法的特点，我们可以发现当所有的最小子问题解决后原问题就解决了——因为在划分的时候就保证了子问题之间是按序从小到大的，所以这里没有涉及“和”的问题。因此分治算法不一定会有“和”的过程，此算法就是一个例子。</li></ul><p>下面是快速排序一个例子的图解，结合图可以更好地理解上述的基本思想，图中灰色元素为基准元素。</p><p><img src="http://src.zhumingcj.cn/blog/20191117/yyeY6cmV8lDx.png?imageslim" alt="mark"></p><p>快排的代码实现：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"> //此程序选取数组第一个元素作为基准</span><br><span class="line">public static void QuickRank(int[] list, int start, int end)</span><br><span class="line">        {</span><br><span class="line">     //退出递归的条件</span><br><span class="line">            if (end - start &lt; 1) return;</span><br><span class="line">            int middle = 0;</span><br><span class="line">            int i = start + 1;</span><br><span class="line">    //从后往前搜索一个比基准元素小的元素</span><br><span class="line">            for (int j = end; j &gt;= start; j--)</span><br><span class="line">            {</span><br><span class="line">                //退出搜索的条件，原来就有序的情况</span><br><span class="line">                if (j &lt; i) break;</span><br><span class="line">                //将第一个判断分完堆后交界元素与基准元素大小关系，据此确定基准元素的位置，将基准元素与该位置元素交换</span><br><span class="line">                if (i == j)</span><br><span class="line">                {</span><br><span class="line">                    if (list[i] &lt; list[start])</span><br><span class="line">                    {</span><br><span class="line">                        int temp;</span><br><span class="line">                        temp = list[start];</span><br><span class="line">                        list[start] = list[i];</span><br><span class="line">                        list[i] = temp;</span><br><span class="line">                        middle = i;</span><br><span class="line">                    }</span><br><span class="line">                    else</span><br><span class="line">                    {</span><br><span class="line">                        int temp;</span><br><span class="line">                        temp = list[start];</span><br><span class="line">                        list[start] = list[i - 1];</span><br><span class="line">                        list[i - 1] = temp;</span><br><span class="line">                        middle = i - 1;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    break;</span><br><span class="line">                }</span><br><span class="line">//找到比基准元素小的元素后从前往后找到一个比基准元素大的元素，与之前找到的元素交换</span><br><span class="line">                if (list[j] &lt; list[start])</span><br><span class="line">                {</span><br><span class="line">                    for (; i &lt;= end; i++)</span><br><span class="line">                    {</span><br><span class="line">                        if (i == j)</span><br><span class="line">                        {</span><br><span class="line">                            if (list[i] &lt; list[start])</span><br><span class="line">                            {</span><br><span class="line">                                int temp;</span><br><span class="line">                                temp = list[start];</span><br><span class="line">                                list[start] = list[i];</span><br><span class="line">                                list[i] = temp;</span><br><span class="line">                                middle = i;</span><br><span class="line">                            }</span><br><span class="line">                            else</span><br><span class="line">                            {</span><br><span class="line">                                int temp;</span><br><span class="line">                                temp = list[start];</span><br><span class="line">                                list[start] = list[i - 1];</span><br><span class="line">                                list[i - 1] = temp;</span><br><span class="line">                                middle = i - 1;</span><br><span class="line">                            }</span><br><span class="line">                            break;</span><br><span class="line">                        }</span><br><span class="line">                        if (list[i] &gt; list[start])</span><br><span class="line">                        {</span><br><span class="line">                            int temp;</span><br><span class="line">                            temp = list[j];</span><br><span class="line">                            list[j] = list[i];</span><br><span class="line">                            list[i] = temp;</span><br><span class="line">                            break;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">    //递归调用</span><br><span class="line">            QuickRank(list, start, middle);</span><br><span class="line">            QuickRank(list, middle + 1, end);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>快排算法复杂度的分析：</p><p>​    前面提到算法复杂度的下限是$nlogn$，这意味着通常情况下，快排的复杂度是大于$nlogn$的。复杂度下限的取得条件是：每次都能分成大小相等的两堆，此时有递推关系$QuickRank(n)=2*QuickRank(n-1)$，解此递推式可以得到下限$O(nlogn)$；但是当每次分成的两堆大小相差比较大时，比如一堆分得一个，另一堆分得剩下的全部，那么我们可以得到递推式$QuickRank(n)=QuickRank(n-1)+QuickRank(1)+O(n)$，解此递推关系可以发现复杂度为$O(n^{2})$，这是最差的情况，一般快排复杂度介于两者之间。</p></li><li><h5 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h5><p>合并排序是一种典型的白盒划分的分治算法，它的时间复杂度为$O(nlogn)$，比暴力法和快排的效率都要高。</p><p>合并排序的基本思想：</p><ul><li>“分”的策略：合并排序在分的时候一刀两断，将数组分成大小相等的两堆（元素个数为奇数时不能平分，但基本上是平分的），然后递归调用函数，继续分，直到分解到两个元素（或一个元素）为一堆的时候，此时比较两个元素，交换位置就能得到最小子问题的解。</li><li>“和”的策略：与快排不同的是，合并排序采用了黑盒划分的方法，因此无法保证最小子问题的解放到一起还是升序的，所以就有合的步骤。此处“合”需要解决的问题是：将两个升序的数组合并为一个升序的数组，解决这个问题可以采用逐次比较的方法（需要额外申请内存空间，用于存放合并的结果）——首先让两个指针指向两个数组的首位元素，通过指针比较两个数组首元素的大小，将小的元素放到结果数组中，然后此元素对应的指针+1；继续通过这两个指针比较当前指向的两个元素的大小，重复上述操作直到其中一个指针到底对应数组的末尾，将未到达末尾的指针对应的数组中未比较的元素拷贝到结果数组中，至此合并完成。</li></ul><p>下面是合并排序一个例子的图解，图中只给出了“分”的具体过程，结合图可以更好地理解上述的基本思想。</p><p><img src="http://src.zhumingcj.cn/blog/20191117/uWRykreVys3p.png?imageslim" alt="mark"></p><p>合并排序的实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_sort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">list</span>, <span class="keyword">int</span> low, <span class="keyword">int</span> up)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (low == up)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> middle = (low + up) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> size = up - low + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>* temp = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*size);</span><br><span class="line">    <span class="comment">//递归调用</span></span><br><span class="line">Merge_sort(<span class="built_in">list</span>, low, middle);</span><br><span class="line">Merge_sort(<span class="built_in">list</span>, middle + <span class="number">1</span>, up);</span><br><span class="line">Merge(<span class="built_in">list</span>, low, up, temp);</span><br><span class="line"><span class="built_in">list</span> = <span class="built_in">list</span> + low;</span><br><span class="line">    <span class="comment">//将结果拷贝回原来的数组</span></span><br><span class="line"><span class="keyword">while</span> (size--&gt;<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">*<span class="built_in">list</span>++ = *temp++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>*<span class="built_in">list</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span>*temp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span>* left = <span class="built_in">list</span>+start;</span><br><span class="line"><span class="keyword">int</span> middleNum = (end + start) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>* right = <span class="built_in">list</span> +middleNum+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>* endPoint = <span class="built_in">list</span> + end;</span><br><span class="line">    <span class="comment">//逐次比较</span></span><br><span class="line"><span class="keyword">while</span> (left &lt;= <span class="built_in">list</span> + middleNum &amp;&amp; right &lt;= endPoint)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(*(left) &lt; *(right))</span><br><span class="line">{</span><br><span class="line">*temp++ = *(left++);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">*(temp++) = *(right++);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">    <span class="comment">//找到未经比较的元素，拷贝到结果数组</span></span><br><span class="line"><span class="keyword">if</span> (left &lt;= <span class="built_in">list</span> + middleNum) {</span><br><span class="line"><span class="keyword">while</span> (left &lt;= <span class="built_in">list</span> + middleNum)</span><br><span class="line">{</span><br><span class="line">*temp++ = *left++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span> (right &lt;= endPoint)</span><br><span class="line">{</span><br><span class="line">*temp++ = *right++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><p>   快排算法复杂度的分析：</p><p>   ​    前面提到算法复杂度为$O(nlogn)$，这意味着不管在什么情况下，合并排序的复杂度都为$O(nlogn)$。这是因为合并排序每次都能分成大小相等的两堆，递推关系始终满足关系式$QuickRank(n)=2*QuickRank(n-1)$，因此复杂度始终为$O(nlogn)$。</p><h3 id="两种排序算法的比较"><a href="#两种排序算法的比较" class="headerlink" title="两种排序算法的比较"></a>两种排序算法的比较</h3><p>合并排序的性能要比快速排序高，这取决于“分”的策略不同，所以对于分治算法来说如何“分”决定着算法的性能。这两个排序算法还涉及到黑盒划分和白盒划分的区别——所谓黑盒划分就是按照某种规则划分后无法得知划分的情况（输入未知的情况下）；而白盒划分则是按照某种规则划分后我们可以得知划分的情况。拿合并排序和快速排序来讲，采用合并排序时每次对半划分，但是我们无法知道最后每个最小子问题之间有什么关系，但是采用快速排序时根据基准，我们可以知道最小子问题是有序的，或者说对于其中一次划分，我们可以肯定：划分出的两堆数，其中一堆的数都大于另一堆。实质上白盒划分和黑盒划分的区别在于白盒划分降低了划分结果的不确定性，即对划分结果做出了某些限定，在合并排序中相当于限定了划分结果的大小关系。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graphic of Typora</title>
      <link href="2019/10/17/graphic-of-typora/"/>
      <url>2019/10/17/graphic-of-typora/</url>
      
        <content type="html"><![CDATA[<h1 id="流程图示例"><a href="#流程图示例" class="headerlink" title="流程图示例"></a>流程图示例</h1><p>在很多时候，图表能帮助我们更好地传达我们想表述的意思，也更加的直观，因此我们有必要学会各种绘图的技巧。这篇博客将介绍如何使用Typora绘制各种图（流程图、序列图、甘特图）。</p><a id="more"></a><h3 id="1-流程图"><a href="#1-流程图" class="headerlink" title="1.流程图"></a>1.流程图</h3><ul><li><h5 id="使用mermaid绘制（非标准）流程图（个人觉得难看）"><a href="#使用mermaid绘制（非标准）流程图（个人觉得难看）" class="headerlink" title="使用mermaid绘制（非标准）流程图（个人觉得难看）"></a>使用mermaid绘制（非标准）流程图（个人觉得难看）</h5><p>Typora指令：”</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用标识符代表不同节点，如下面的A,B,C...连接线上的注释写在箭头后面用“|”包裹，也可以写在“--”和“--&gt;”中间。</span><br><span class="line"></span><br><span class="line">连接线的样式：</span><br><span class="line"></span><br><span class="line">| --&gt;  | 箭头   |</span><br><span class="line">| ---- | ------ |</span><br><span class="line">| ---  | 实线   |</span><br><span class="line">| ==&gt;  | 粗箭头 |</span><br><span class="line">| ===  | 粗实线 |</span><br><span class="line">| -.-  | 虚线   |</span><br></pre></td></tr></tbody></table></figure><p></p><p>graph TD//TD表示Top-&gt;Down即纵向；横向为LR<br>A[Hard edge]—&gt;B(Round edge)//方括号为普通操作//圆括号为：开始/结束框</p><pre><code>B--&gt;C{Decision}//花括号为条件框C-- one --&gt;D[result one]C--&gt;|two|E[result two]</code></pre><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">```mermaid</span><br><span class="line">graph TD</span><br><span class="line">A[Hard edge]--&gt;B(Round edge)</span><br><span class="line">B--&gt;C{Decision}</span><br><span class="line">C-- one --&gt;D[result one]</span><br><span class="line">C--&gt;|two|E[result two]</span><br></pre></td></tr></tbody></table></figure></li><li><h5 id="标准流程图flow"><a href="#标准流程图flow" class="headerlink" title="标准流程图flow"></a>标准流程图flow</h5><p>Typora指令：”</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">格式：分节点声明和连接两部分</span><br><span class="line"></span><br><span class="line">节点声明：如$\underset{标识符}{st}=&gt;\underset{流程名类型}{start}: \underset{框中文本}{Start}$</span><br><span class="line"></span><br><span class="line">连接：只能用 “-&gt;”</span><br></pre></td></tr></tbody></table></figure><p></p><p>st=&gt;start: Start<br>op=&gt;operation: Your Operation<br>cond=&gt;condition: Yes or No?<br>e=&gt;end<br>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">```flow</span><br><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></tbody></table></figure></li><li><p>关于mermaid流程图和flow流程图更多用法</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    sq[Square shape] --&gt; ci((Circle shape))</span><br><span class="line"></span><br><span class="line">    subgraph A subgraph</span><br><span class="line">        od&gt;Odd shape]-- Two line&lt;br/&gt;edge comment --&gt; ro</span><br><span class="line">        di{Diamond with &lt;br/&gt; line break} -.-&gt; ro(Rounded&lt;br&gt;square&lt;br&gt;shape)</span><br><span class="line">        di==&gt;ro2(Rounded square shape)</span><br><span class="line">        </span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% Notice that no text in shape are added here instead that is appended further down</span><br><span class="line">    e --&gt; od3&gt;Really long text with linebreak&lt;br&gt;in an Odd shape]</span><br><span class="line"></span><br><span class="line">    %% Comments after double percent signs</span><br><span class="line">    e((Inner / circle&lt;br&gt;and some odd &lt;br&gt;special characters)) --&gt; f(,.?!+-*ز)</span><br><span class="line"></span><br><span class="line">    cyr[Cyrillic]--&gt;cyr2((Circle shape Начало));</span><br><span class="line"></span><br><span class="line">     classDef green fill:#9f6,stroke:#333,stroke-width:2px;</span><br><span class="line">     classDef orange fill:#f96,stroke:#333,stroke-width:4px;</span><br><span class="line">     class sq,e green</span><br><span class="line">     class di orange</span><br></pre></td></tr></tbody></table></figure></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    sq[Square shape] --&gt; ci((Circle shape))</span><br><span class="line"></span><br><span class="line">    subgraph A subgraph</span><br><span class="line">        od&gt;Odd shape]-- Two line&lt;br/&gt;edge comment --&gt; ro</span><br><span class="line">        di{Diamond with &lt;br/&gt; line break} -.-&gt; ro(Rounded&lt;br&gt;square&lt;br&gt;shape)</span><br><span class="line">        di==&gt;ro2(Rounded square shape)</span><br><span class="line">        </span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% Notice that no text in shape are added here instead that is appended further down</span><br><span class="line">    e --&gt; od3&gt;Really long text with linebreak&lt;br&gt;in an Odd shape]</span><br><span class="line"></span><br><span class="line">    %% Comments after double percent signs</span><br><span class="line">    e((Inner / circle&lt;br&gt;and some odd &lt;br&gt;special characters)) --&gt; f(,.?!+-*ز)</span><br><span class="line"></span><br><span class="line">    cyr[Cyrillic]--&gt;cyr2((Circle shape Начало));</span><br><span class="line"></span><br><span class="line">     classDef green fill:#9f6,stroke:#333,stroke-width:2px;</span><br><span class="line">     classDef orange fill:#f96,stroke:#333,stroke-width:4px;</span><br><span class="line">     class sq,e green</span><br><span class="line">     class di orange</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    B["fa:fa-twitter for peace"]</span><br><span class="line">    B--&gt;C[fa:fa-ban forbidden]</span><br><span class="line">    B--&gt;D(fa:fa-spinner);</span><br><span class="line">    B--&gt;E(A fa:fa-camera-retro perhaps?);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    B["fa:fa-twitter for peace"]</span><br><span class="line">    B--&gt;C[fa:fa-ban forbidden]</span><br><span class="line">    B--&gt;D(fa:fa-spinner);</span><br><span class="line">    B--&gt;E(A fa:fa-camera-retro perhaps?);</span><br></pre></td></tr></tbody></table></figure><h3 id="2-序列图"><a href="#2-序列图" class="headerlink" title="2.序列图"></a>2.序列图</h3><ul><li><h5 id="序列图sequence"><a href="#序列图sequence" class="headerlink" title="序列图sequence"></a>序列图sequence</h5><p>Typora指令：”</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">格式：对话和标注</span><br><span class="line"></span><br><span class="line">对话：对象1 -&gt; 对象2：内容</span><br><span class="line"></span><br><span class="line">标注：Note {right of/left of/over(跨越多个对象，对象之间逗号相隔)}+对象：内容</span><br></pre></td></tr></tbody></table></figure><p></p><p>Alice-&gt;Bob: Hello Bob, how are you?<br>Note right of Bob: Bob thinks<br>Bob—&gt;Alice: I am good thanks!</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">```sequence</span><br><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></tbody></table></figure></li></ul><p>一个示例（三次握手图解）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client-&gt;server: 客户端发送请求 SYN=1 Seq=X</span><br><span class="line">server-&gt;client: 服务器响应请求 SYN=1 ACK=X+1 Seq=Y</span><br><span class="line">client-&gt;server: 客户端确认响应 ACK=Y+1 Seq=Z</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client-&gt;server: 客户端发送请求 SYN=1 Seq=X</span><br><span class="line">server-&gt;client: 服务器响应请求 SYN=1 ACK=X+1 Seq=Y</span><br><span class="line">client-&gt;server: 客户端确认响应 ACK=Y+1 Seq=Z</span><br></pre></td></tr></tbody></table></figure><ul><li><h5 id="序列图（mermaid版）"><a href="#序列图（mermaid版）" class="headerlink" title="序列图（mermaid版）"></a>序列图（mermaid版）</h5><p>第一行标识图的类型，其余与sequence类似。</p><p>不同：participant声明对象；alt选择模式；loop循环模式</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;Bob: Hello Bob, how are you?</span><br><span class="line">    alt is sick</span><br><span class="line">    Bob-&gt;&gt;Alice: Not so good :(</span><br><span class="line">    else is well</span><br><span class="line">    Bob-&gt;&gt;Alice: Feeling fresh like a daisy</span><br><span class="line">    end</span><br><span class="line">    opt Extra response</span><br><span class="line">    Bob-&gt;&gt;Alice: Thanks for asking</span><br><span class="line">    end</span><br></pre></td></tr></tbody></table></figure></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;Bob: Hello Bob, how are you?</span><br><span class="line">    alt is sick</span><br><span class="line">    Bob-&gt;&gt;Alice: Not so good :(</span><br><span class="line">    else is well</span><br><span class="line">    Bob-&gt;&gt;Alice: Feeling fresh like a daisy</span><br><span class="line">    end</span><br><span class="line">    opt Extra response</span><br><span class="line">    Bob-&gt;&gt;Alice: Thanks for asking</span><br><span class="line">    end</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    participant John</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    loop Healthcheck</span><br><span class="line">        John--&gt;John: Fight against hypochondria</span><br><span class="line">    end</span><br><span class="line">    Note right of John: Rational thoughts&lt;br/&gt;prevail...</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br><span class="line">    John-&gt;&gt;Bob: How about you?</span><br><span class="line">    Bob--&gt;&gt;John: Jolly good!</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    participant John</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    loop Healthcheck</span><br><span class="line">        John--&gt;John: Fight against hypochondria</span><br><span class="line">    end</span><br><span class="line">    Note right of John: Rational thoughts&lt;br/&gt;prevail...</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br><span class="line">    John-&gt;&gt;Bob: How about you?</span><br><span class="line">    Bob--&gt;&gt;John: Jolly good!</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice -&gt;&gt; Bob: Hello Bob, how are you?</span><br><span class="line">    Bob--&gt;&gt;John: How about you John?</span><br><span class="line">    Bob--x Alice: I am good thanks!</span><br><span class="line">    Bob-x John: I am good thanks!</span><br><span class="line">    Note right of John: Bob thinks a &lt;br/&gt;longlong time,&lt;br/&gt; so long that&lt;br/&gt; the text does&lt;br/&gt;not fit on a&lt;br/&gt; row.</span><br><span class="line"></span><br><span class="line">    Bob--&gt;Alice: Checking with John...</span><br><span class="line">    Alice-&gt;John: Yes... John, how are you?</span><br></pre></td></tr></tbody></table></figure><h3 id="3-甘特图"><a href="#3-甘特图" class="headerlink" title="3.甘特图"></a>3.甘特图</h3><p>格式：</p><ul><li><p>第一行声明图的类型，第二行声明日期格式（类似于Format的写法），第三行声明标题</p></li><li><p>每一个独立部分写在section里面，section后面为section的名字</p><p>section的格式：</p><ul><li><p>每一行为一个任务，开头为任务名称；后面为任务状态；接着是时间的标识符（可有可无），用于其他任务的定位；最后是（时间起止）||（起始时间+时间间隔）||（标识符定位+时间间隔）</p></li><li><p>任务状态：</p><p>| done   | 已完成       |<br>| ——— | —————— |<br>| crit   | 处于重要阶段 |<br>| active | 正在进行     |</p></li></ul></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">%% Example with slection of syntaxes</span><br><span class="line">        gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title Adding GANTT diagram functionality to mermaid</span><br><span class="line"></span><br><span class="line">        section A section</span><br><span class="line">        Completed task            :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        Active task               :active,  des2, 2014-01-09, 3d</span><br><span class="line">        Future task               :         des3, after des2, 5d</span><br><span class="line">        Future task2              :         des4, after des3, 5d</span><br><span class="line"></span><br><span class="line">        section Critical tasks</span><br><span class="line">        Completed task in the critical line :crit, done, 2014-01-06,24h</span><br><span class="line">        Implement parser and jison          :crit, done, after des1, 2d</span><br><span class="line">        Create tests for parser             :crit, active, 3d</span><br><span class="line">        Future task in critical line        :crit, 5d</span><br><span class="line">        Create tests for renderer           :2d</span><br><span class="line">        Add to mermaid                      :1d</span><br><span class="line"></span><br><span class="line">        section Documentation</span><br><span class="line">        Describe gantt syntax               :active, a1, after des1, 3d</span><br><span class="line">        Add gantt diagram to demo page      :after a1  , 20h</span><br><span class="line">        Add another diagram to demo page    :doc1, after a1  , 48h</span><br><span class="line"></span><br><span class="line">        section Last section</span><br><span class="line">        Describe gantt syntax               :after doc1, 3d</span><br><span class="line">        Add gantt diagram to demo page      : 20h</span><br><span class="line">        Add another diagram to demo page    : 48h</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">%% Example with slection of syntaxes</span><br><span class="line">        gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title Adding GANTT diagram functionality to mermaid</span><br><span class="line"></span><br><span class="line">        section A section</span><br><span class="line">        Completed task            :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        Active task               :active,  des2, 2014-01-09, 3d</span><br><span class="line">        Future task               :         des3, after des2, 5d</span><br><span class="line">        Future task2              :         des4, after des3, 5d</span><br><span class="line"></span><br><span class="line">        section Critical tasks</span><br><span class="line">        Completed task in the critical line :crit, done, 2014-01-06,24h</span><br><span class="line">        Implement parser and jison          :crit, done, after des1, 2d</span><br><span class="line">        Create tests for parser             :crit, active, 3d</span><br><span class="line">        Future task in critical line        :crit, 5d</span><br><span class="line">        Create tests for renderer           :2d</span><br><span class="line">        Add to mermaid                      :1d</span><br><span class="line"></span><br><span class="line">        section Documentation</span><br><span class="line">        Describe gantt syntax               :active, a1, after des1, 3d</span><br><span class="line">        Add gantt diagram to demo page      :after a1  , 20h</span><br><span class="line">        Add another diagram to demo page    :doc1, after a1  , 48h</span><br><span class="line"></span><br><span class="line">        section Last section</span><br><span class="line">        Describe gantt syntax               :after doc1, 3d</span><br><span class="line">        Add gantt diagram to demo page      : 20h</span><br><span class="line">        Add another diagram to demo page    : 48h</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文本编辑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>three ways of coding</title>
      <link href="2019/10/03/three-ways-of-coding/"/>
      <url>2019/10/03/three-ways-of-coding/</url>
      
        <content type="html"><![CDATA[<h1 id="三种编码方式：原码、反码、补码"><a href="#三种编码方式：原码、反码、补码" class="headerlink" title="三种编码方式：原码、反码、补码"></a>三种编码方式：原码、反码、补码</h1><p>学过大学计算机基础的人可能对原码、反码、补码有所了解，但是对于三种编码的意义一脸懵逼或是一知半解，本文希望能透彻的讲清楚三者的意义及联系。清楚地理解原码、反码、补码的概念对于编写嵌入式开发的程序有着巨大的帮助。</p><a id="more"></a><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>原码由符号位、真值组成，下面给出一些例子：</p><div class="table-container"><table><thead><tr><th>二进制原码</th><th>对应十进制数</th></tr></thead><tbody><tr><td>10011001</td><td>-25</td></tr><tr><td>00111010</td><td>57</td></tr><tr><td>01010110</td><td>86</td></tr></tbody></table></div><p>原码是很直观的一个概念，就是第一位保存符号，第二位保存真值。</p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>既然有了原码，又为什么需要反码呢？这要从加减法运算讲起，如果使用原码，我们在运算时需要分两部分计算，即符号位的运算和真值的运算 ，下面用例子来说明。</p><div class="table-container"><table><thead><tr><th>算式</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>2+3=00000010+00000011=00000101=5</td><td style="text-align:center">正数相加，符号位一样运算后还是0，真值位直接相加</td></tr><tr><td>2+（-1）=00000010+10000001=00000001</td><td style="text-align:center">正数和负数相加，符号位不一样，运算后取决于真值大的数的符号，真值位用大值减小值</td></tr><tr><td>-2+（-1）</td><td style="text-align:center">负数相加，符号位相同运算后为1，真值位直接相加</td></tr><tr><td>2-3</td><td style="text-align:center">符号位不同，运算后取决于真值大的数的符号，真值位用大值减小值</td></tr><tr><td>-3-（-2）</td><td style="text-align:center">转换成2-3</td></tr></tbody></table></div><p>可以看到，运算时先去括号进行符号的运算，可以归结为两种情况</p><ol><li>两个数的符号相同，如2+3，-2-3，此时符号位不变，真值位相加</li><li>两个数的符号位不同，如-3+2,3-4，-4+2，此时一律当成减法来做，符号取决于真值大的数，运算结果的数组为大值减小值。</li></ol><p>但是这样的运算法则对计算机来说是很复杂的，对于计算机如果能直接相加而不考虑符号位是最好不过的，但是我们发现2+（-1）=00000010+10000001=10000011=-3，说明原码直接相加的结果是不正确的。为了解决这一问题，反码被创造了出来。反码是在原码的基础上，对于正数保持不变；对于负数保持符号位不变，真值位取反得到的。下面给出例子：</p><div class="table-container"><table><thead><tr><th>二进制原码</th><th>二进制反码</th><th>对应十进制数</th></tr></thead><tbody><tr><td>10011001</td><td>11100110</td><td>-25</td></tr><tr><td>00111010</td><td>00111010</td><td>57</td></tr><tr><td>01010110</td><td>01010110</td><td>86</td></tr></tbody></table></div><p>现在我们再来考察一下反码的运算</p><div class="table-container"><table><thead><tr><th>算式</th><th>说明</th></tr></thead><tbody><tr><td>$2+3=(00000010)_反+(00000011)_反=（00000101）_{反}=5$</td><td>正数相加，无误</td></tr><tr><td>2+-3=$(00000010)_反+(11111100)_反=(11111110)_反=-1$</td><td>正负数相加，负数的真值大，无误</td></tr><tr><td>3+-1=$(00000011)_反+(11111110)_反=(00000001)_反=1$</td><td>正负数相加，正数的真值大，出现错误</td></tr><tr><td>3+-2=$(00000011)_反+(11111101)_反=(00000000)_反=0$</td><td>正负数相加，正数的真值大，出现错误</td></tr><tr><td>-2+-3=$(11111101)_反+(11111100)_反=(11111001)_反=-6$</td><td>负数相加，出现错误</td></tr><tr><td>1+-1=$(00000001)_反+(11111110)_反=(11111111)_反=+0$</td><td>正负数相加且真值相等，结果为+0</td></tr><tr><td>+0+(+0)=$(00000000)_反+(00000000)_反=(00000000)_反=+0$<br>-0+(-0)=$(11111111)_反+(11111111)_反=(11111110)_反=-1$       <br>0+(-0)=$(00000000)_反+(11111111)_反=(11111111)_反=-0$</td><td>由于符号位的存在，导致有+0和-0之分，因此0+0有三种情况，也会产生三种结果</td></tr><tr><td>0+(-1)=$(00000000)_反+(11111110)_反=(11111110)_反=-1$<br>-0+(-1)=$(11111111)_反+(11111110)_反=(11111101)_反=-$2</td><td>同样由于$\pm0$的存在导致了不同的运算结果</td></tr></tbody></table></div><p>综上，我们总结出规律(减法一律视为加法，硬件中没有减法器只有加法器)：</p><ol><li>正数的反码运算是正确的</li><li>正数与负数相加时，当负数的真值大于等于正数时，结果正确</li><li>对于正数与负数相加时，当负数的真值小于正数、负数相加的情况，结果错误但都与正确结果相差一</li><li>存在+0和-0的问题</li></ol><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><ul><li><p>反码的意义</p><p>根据取反码的定义，我们可以知道对于正数无变化，对于负数相当于取真值相对于127的补，即负数反码的真值和本身的真值之和等于127。</p></li><li><p>正数与负数反码相加的情况</p><p>设正数a的真值为$x_{a}$，负数b的真值为$x_{b}$，记a的反码为$\tilde a$;记b的反码为$\tilde b$，则取反码后：</p><p>$\tilde a$的真值为$x_{a},\tilde b$的真值为$127-x_{b}$</p><p>那么$\tilde a + \tilde b$的真值为$127+x_{a}-x_{b}$,这里会产生一个进位问题：        </p><ul><li><p>当$x_{b}<x_{a}$​时 ，由于$127+x_{a}-x_{b}$="">127产生进位，符号位因为进位置零。相应的实际上正数大于负数,符号 位 正确。</x_{a}$​时></p><p>结果的真值为$x_{a}-x_{b}-1$与正确结果相差1，可知错误的产生是由于进位</p></li><li><p>当$x_{b}&gt;x_{a}$时，$127+x_{a}-x_{b}&gt;127$不进位,符号位任为1，相应的实际上正数小于负数,符号位正确。</p><p>结果真值为$x_{b}-x_{a}$,结果正确，到此与上表相符。</p></li></ul></li><li><p>对于负数相加的情况，结果的真值为$254-x_{a}-x_{b}$，因为不能溢出，所以$x_{a}+x_{b}&lt;=127$</p><ul><li>当$x_{a}+x_{b}&lt;127$ 时，会发生一个进位，符号位因此置1，符号正确，结果真值为$x_{a}+x_{b}-1$,与上表相符。</li><li>当$x_{a}+x_{b}=127$时，不进位，符号位置0，符号错误，结果真值为127，结果错误</li></ul></li></ul><p>总的来看采用反码来运算有以下问题：</p><ol><li>$\pm$ 0的问题</li><li>进位导致的偏差</li><li>边界运算的跳变</li></ol><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>为了解决反码存在的问题，补码应运而生。在将补码之前，我们来看看如何改进反码。</p><p>由上面的分析，我们发现进位的产生导致运算结果与正确的结果相差1，那么我们可以进行修正，由于正数之间的运算没有问题，那么我们不能修正正数，因为这样会引起正数运算的错误，于是我们应该对负数进行修正。</p><p>根据式$x_{a}-x_{b}-1$（正负数相加的情况），保持$x_{a}$不变，则只能将-$x_{b}$修正为1-$x_{b}$，往上追溯即把$\tilde b $的真值修正为$128-x_{b}$，即负数b在取反的基础上，再加一(逆回去的时候也是如此)，经过验证，我们发现负数相加时的问题也解决了。</p><p>巧合的是，此时边界问题也得到了解决，简单的来看，我们可以这么想：负数相加，两个数都多加了1，逆回去要减去1，总的来看修正了1；正负数相加，正数大于负数时，负数多加了1，运算结果由于是正的，逆回去的时候不再减1，总的来看修正了1；正负数相加，负数大于正数，负数多加了1，运算结果由于是负的，逆回去的时候减去1，总的来看修正零。这样我们就把上面的错误都修正了。</p><p>再来看一下$\pm0$的问题，我们发现+0取反加1后为00000000，-0取反加1后也为00000000，因此$\pm0$在某种程度上得到了统一。</p><p>在这里我们引出补码，补码的一种计算方式就是取反加一（对于负数，正数补码是本身），但是切记补码不是通过反码定义的，这只是一种巧合而已。在反码中，我们还做了一个规定是-128=10000000，这是因为用补码表示数的时候0只有一种补码，这导致补码少了一个，即10000000没有出现，因此扩充定义。但是-128没有反码，它不在反码表示范围之内。</p><h5 id="补码的真正含义"><a href="#补码的真正含义" class="headerlink" title="补码的真正含义"></a>补码的真正含义</h5><p>不管是补码还是反码，它们都是为了解决带符号运算的问题的。由于数值类型的限制，确定的类型的长度是固定的，因此我们可以通过舍弃进位的方式将负数转为正数。</p><p>以8位的数为例：</p><p>3+（-2）与3+（256-2）=00000011+（100000000-00000010）=00000011+11111110=00000001</p><p>两者的结果是一样的，因为后者产生了一个进位（一个进位代表了256的产生）舍弃后结果也为1。这里不得不拿钟来说事，假设现在钟显示3点，但是走快了一个小时，我们要把它调到2点，方式有两种——我们既可以往后拨1个小时也可以往前拨23个小时，这是因为钟表上只能记录0-23这24个数，3+23=26并不在其中，只能丢弃一个24变为2。因此我们不能分清2与26的区别，也就是说（假设x+y=res,y为负数）我们完全有理由可以认为$x+y’=res+256$，为保证等式的成立，必然有等价关系$y+256=y’$（解x，根据对应相等得出）</p><p>按这种方式，我们实际上是对负数做了一个映射，关系为当x为正数时x+256无变化；当x为负数时$x_{补}=256-|x|$,这样x+y和256-|x|+y在丢弃进位后是一样的。这样，我们构建了这样一个世界：一切减法变加法，一切负数变正数，想求原值逆映射。</p><p>下面我们再解释一下为什么负数补码等于反码加一。假设负数x的真值为a,则由于取反保留了符号位，相当于加了10000000即128，真值部分取反，得到的结果的真值为127-a，那么取反得到的数相当于128+127-a=255-a，再加上1等于256-a即补码的定义。</p><p>最后给出补码的数学验证，这里我们会用到同余的概念。如果两个数除以同一个数得到的余数相等，则这两个数关于除数同余，例如11%4==35%4，则11与35关于4同余，记为$11\equiv35(mod \ \ 4)$</p><p>由于(x为负数)$x=-|x|\equiv 256-|x|(mod \ \ 256)$,并且$y\equiv y(mod \ \ 256)$,则根据同余的线性运算法则有：</p><script type="math/tex; mode=display">\begin{align}y-|x|=x+y\\x+y\equiv x+y+256(mod \ \ 256)\\x+y+256=y-|x|+256=x_{补}+y_{补}\\\therefore x+y \equiv x_{补}+y_{补}(mod \ \ 256)\end{align}</script><p>在限定了数的范围之后，同余数x+y和x+y+256是一样的，拿钟来说就是相差一圈，但是就结果而言我们无法区分这两种情况，这是一种等效的思想。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Principle of Floating Number</title>
      <link href="2019/09/29/principle-of-floating-number/"/>
      <url>2019/09/29/principle-of-floating-number/</url>
      
        <content type="html"><![CDATA[<h1 id="浮点数的原理"><a href="#浮点数的原理" class="headerlink" title="浮点数的原理"></a>浮点数的原理</h1><p>在编程中，我们经常会与float打交道，总是会遇到一些难以预测的问题，而且这些问题往往没有有效的解决方法。我们想要弄清楚其中的奥秘，就一定要理解float的实现原理；通过float的原理来看问题，一切问题都会迎刃而解。</p><a id="more"></a><h3 id="float的组织形式（规格化浮点数）"><a href="#float的组织形式（规格化浮点数）" class="headerlink" title="float的组织形式（规格化浮点数）"></a>float的组织形式（规格化浮点数）</h3><p>一个浮点数由三部分组成——符号、尾数、指数，下面给出一个例子</p><script type="math/tex; mode=display">\pm 3.1415926\Rightarrow \underset{符号}{\pm}\underset{尾数}{0.314159}\times\underset{指数}{10^{1}}\\标准形式：fl(x)=\tilde x=\pm \{\frac {x_{1}}{\beta}+\frac {x_{2}}{\beta^{2}}+\dots+\frac {x_{t}}{\beta^{t}} \}\times \beta^{l}</script><p>$注：标准形式中，\beta代表进制的基数；t表示机器的字长；指数部分幂l的范围l\in[L,U] $</p><p>根据标准形式我们可以知道浮点数的表示范围</p><script type="math/tex; mode=display">|fl(x)_{min}|=\beta^{L-t}\\|fl(x)_{max}|=(1-\beta^{t})\beta^{U}\\浮点数集F(\beta,t,L,U)能表示的数有1+2(\beta-1)(\beta^{t-1})(U-L+1)个</script><p>因为字长t是受限于机器的，所以浮点数的精度是有限的，用浮点数存储一个有t+1位有效数字的数会发生精度的丢失：</p><script type="math/tex; mode=display">x=0.x_{1}x_{2}x_{3}\dots x_{t}x_{t+1}\times\beta^{l}\Rightarrow\tilde x=0.x_{1}x_{2}x_{3}\dots\tilde x_{t}</script><p>此时最大绝对误差为$\frac {1}{2}\beta^{-t+l}$，相应的最大相对误差为$\frac{\frac {1}{2}\beta^{-t+l}}{\beta^{l-1}}=\frac 12\beta^{-(t-1)}$,可见相对误差限只与计算机的字长有关。</p><h3 id="舍入误差的产生"><a href="#舍入误差的产生" class="headerlink" title="舍入误差的产生"></a>舍入误差的产生</h3><ul><li><p>数据的精度超过数据类型的精度，比如用float存储15位有效数字的数据，显然会丢失精度。</p></li><li><p>大数与小数相加（以浮点数集F(10,4,10,10)为例进行说明）。大数与小数相加时首先会对阶，使得小数的阶与大数的阶一样，然后尾数进行运算。以$0.3121\times 10^{3}$和$0.2342\times 10^{-1}$为例，对阶时——$0.2342\times 10^{-1}=0.00002342\times 10^{3}=0.0000\times 10^{3}$，小数丢失了全部的精度。其实这是必然的，由于字长是有限的，所以有效数字位数是有限的，大数和小数分别存储时都能准确表示，但相加时，相当于增加了有效数字的位数，一旦两者的和的有效数字位数大于字长，必然要丢失精度，大数吞小数的出现只是因为规定了向大数对阶（丢失小数肯定比丢失大数好啊，不能捡了芝麻，丢了西瓜）。所以多个数加和时我们应该先加和小的数，尽量避免大数吃小数。</p></li><li><p>由于计算机采用二进制，进制转换存在误差。我们可以考虑将十进制数11.31转换为10位二进制数，整数部分11=$(1011)_{2}$，小数部分通过乘2取整的方法进行转换，0.31<em>3=0.62,则小数第一位$b_{1}$是0，0.62\</em>2=1.24，则第二位$b_{2}$为1，因此类推：</p><script type="math/tex; mode=display">2\times 0.24=0.48\quad b_{3}=0\\2\times 0.48=0.96\quad b_{4}=0\\2\times 0.96=1.92\quad b_{5}=1\\2\times 0.92=1.84\quad b_{6}=1\\2\times 0.84=1.68\quad b_{7}=1\\</script><p>由于小数第七位为1，向上舍入进1，则11.31=$(1011.010100)_{2}=1.011010100\times2^{3}=11.3125$，绝对误差为0.0025，相对误差为$\frac{0.0025}{11.31}=2.2\times10^{-4}$，这也就是为什么我们经常会遇到：定义float num=2.1,打印num时会得到这样的东西  =&gt; 2.0999999046。进制转换时产生的误差是采用浮点数存储不可避免的问题，但是这个误差一般很小，只要小于我们限定的误差，我们并不需要care。</p></li><li><p>在上面我们给出了计算机的精度为$\frac 12\beta^{-(t-1)}$，在数的加减乘除运算中产生的误差的绝对值不会大于计算机的精度，此处不予证明。</p></li></ul><h3 id="float与double"><a href="#float与double" class="headerlink" title="float与double"></a>float与double</h3><p>标准的IEEE单精度浮点数（float)用32bit即4个字节存储</p><script type="math/tex; mode=display">b_{1}b_{2}\dots b_{9}b_{10}\dots b_{31}b_{32}</script><p>其中第一个bit$b_{1}$为符号位，$b_{2}-b_{9}$存储指数的信息，其余为规范化的尾数(对于二进制，规范形式为1.#####，#取值为0或1)。要注意的是$E=b_{2}b_{3}\dots b_{8}b_{9}$,但是E本身并不是指数，因为$0\leq E \leq 255$,但是我们需要指数为负的情况，所以事实上指数k=E-127。则$-127\leq  k \leq 128$。因此一个浮点数表示的二进制数x为</p><script type="math/tex; mode=display">x=(-1)^{b_{1}}\times (1.m)_{2}\times 2^{k}</script><p>同样的，双精度double为62bit，即8个字节的比特序列，第一位同样是符号位，第二位到第十二位存储指数信息，其余为规范化尾数，此时$-1023\leq  k \leq 1024$。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Numerical Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浮点数原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针的使用</title>
      <link href="2019/09/28/Usage%20of%20pointer/"/>
      <url>2019/09/28/Usage%20of%20pointer/</url>
      
        <content type="html"><![CDATA[<h1 id="指针的用法"><a href="#指针的用法" class="headerlink" title="指针的用法"></a>指针的用法</h1><p>指针在C语言中的地位就好比反射之于java/C#，起着十分重要的作用。指针能让萌新落泪，让大神起飞，让C语言屹立不倒。正是指针的存在让C语言变得十分灵活但同样也带来了一些令程序员头疼的问题。</p><a id="more"></a><h3 id="为什么需要指针"><a href="#为什么需要指针" class="headerlink" title="为什么需要指针"></a>为什么需要指针</h3><p>指针，顾名思义是指向一个地方的标识，与存储有着密切的关系。指针指向内存中的一个地址，这个地址可能包含存储的信息，或者指向信息的指针（指针也一种信息），这样才能很好的管理内存。如果不给内存划分区域，编上地址，我们根本无法描述我们要比信息存储在哪，就行我们定位一个地方也是通过地址来找。以此指针就是告诉程序变量存放的位置，这样程序就能找到地方取出或存入信息。</p><h3 id="如何定义指针"><a href="#如何定义指针" class="headerlink" title="如何定义指针"></a>如何定义指针</h3><p>定义指针只需要在 基本类型后加*即可，以下是示例：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* i_num\\指向一个<span class="keyword">int</span>变量的指针</span><br><span class="line"><span class="keyword">char</span>* ch\\指向字符类型的指针</span><br><span class="line"><span class="keyword">float</span>* f_num</span><br><span class="line"><span class="keyword">int</span>** num\\指向指针的指针，即num指向的地址存放的也是一个地址</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>* <span class="title">st_point</span>\\指向结果体的指针</span></span><br></pre></td></tr></tbody></table></figure><h3 id="指针的基操"><a href="#指针的基操" class="headerlink" title="指针的基操"></a>指针的基操</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一些简单的准备</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b[]={<span class="number">23</span>,<span class="number">45</span>,<span class="number">6787</span>,<span class="number">98</span>};</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">4</span>][<span class="number">5</span>];<span class="comment">//二维数组，可理解为矩阵</span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">task</span>{</span></span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">char</span> Descirption[<span class="number">50</span>];</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>{</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Learning</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Learning something"</span>);</span><br><span class="line">    }</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task</span> <span class="title">tasks</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明指针并赋值</span></span><br><span class="line"><span class="keyword">int</span>* p=&amp;a;<span class="comment">// &amp;是取地址符，获取变量的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组的特性</span></span><br><span class="line"><span class="keyword">int</span>* p1=b;<span class="comment">/*一维数组名是数组存储的首地址，相当于一个指针，不同的是一维数组名是一个指针常量，即指向固定的地址，不能给它赋值来改变其指向的地址（注意是不能赋值，而不是赋值了不改变地址）*/</span></span><br><span class="line"><span class="keyword">int</span>** p2=c;<span class="comment">//类似的，二维数组名是一个二重指针</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>* <span class="title">stp</span>=&amp;<span class="title">st</span>;</span><span class="comment">/*不同于数组，结构体名虽然也是结构体首地址，但不能当成指针传递（实际上数组名也不是指针，只是赋值的时候自动转换了）*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问指针指向的地址存储的信息，用*</span></span><br><span class="line">*a<span class="comment">//取出a存储的值</span></span><br><span class="line">*b<span class="comment">//取出b的地址存储的值，即b[0]的值23</span></span><br><span class="line">*c<span class="comment">//c[0][0]的值</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//结构体的不同，用-&gt;('-'加上'&gt;'中间不能有空格)访问，如</span></span><br><span class="line">(*stp).name[<span class="number">0</span>]=<span class="string">'a'</span>;</span><br><span class="line">stp-&gt;id=<span class="number">4</span>;</span><br><span class="line">stp-&gt;tasks.count=<span class="number">6</span>;</span><br><span class="line"><span class="comment">//step.task-&gt;count//这是错误的，-&gt;只适用于结构体指针类型,step.task以不是指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针的运算</span></span><br><span class="line">p++;<span class="comment">//指针+1，表示指针的地址+一个数据类型长度，对于int型来说是4个字节</span></span><br><span class="line">p--;</span><br><span class="line">p+<span class="number">3</span>;</span><br><span class="line">--p;</span><br></pre></td></tr></tbody></table></figure><h3 id="二维数组指针详解"><a href="#二维数组指针详解" class="headerlink" title="二维数组指针详解"></a>二维数组指针详解</h3><p>在写代码之前我们来看看二维数组在内存中存储的方式</p><p>对于一维数组，存储肯定是线性的，但是二维数组并不是以矩阵的形式存储，还是以线性的方式存储，如下图：</p><p><img src="http://src.zhumingcj.cn/blog/20190928/4lRoDeXD1Ng9.png?imageslim" alt="mark"></p><p>对于二维数组可以理解为以一元数组为元素的数组，所以a相当于一个二维指针（但不是），a[0]代表一个一维数组，a[0]是这个数组的名字，即指向a[0][0]到a[0][3]这块内存的首地址。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span>*p1;</span><br><span class="line"><span class="keyword">int</span>**p2;</span><br><span class="line">p1=a[<span class="number">0</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">//p2=a;//错误，a实际上不是一个指针</span></span><br><span class="line"></span><br><span class="line">p2=(<span class="keyword">int</span>**)a;<span class="comment">//因为a相当于一个指针，因此可以强制转换</span></span><br><span class="line"><span class="keyword">int</span>(*p2)[<span class="number">4</span>]=a;<span class="comment">//这样也可以，P2是二维指针，理解为p2是int[4]的指针</span></span><br><span class="line"></span><br><span class="line">p1++;<span class="comment">/*指针移动4个字节（1个int的存储大小），因为p1指向的数组存储int，如果移动的距离不是4个字节会导致数据存储重叠或者有空隙，读取的时候会有问题*/</span></span><br><span class="line">p2++;<span class="comment">//p2指向的数组以int[4]为元素，因此移动16个字节</span></span><br></pre></td></tr></tbody></table></figure><h3 id="指针之痛——野指针"><a href="#指针之痛——野指针" class="headerlink" title="指针之痛——野指针"></a>指针之痛——野指针</h3><p>在使用指针处理有关数组的问题时往往会简化程序，有相当大的灵活性。但是在使用中往往出现野指针的问题，所谓野指针就是指向不知道的地方的指针。</p><p>产生野指针的常见错误有两种：</p><ol><li>声明指针后没有初始化，这是初学者经常犯的毛病，不多说。</li><li>使用指针的自增运算时没有节制，超出数组存储的范围；操作指针后没有复位，再次操作时出现越界，典型的有使用指针遍历数组后指针指向最后一个元素，但是再次使用指针访问数组前没有复位。</li><li>在方法中返回一个局部的指针变量，因为局部变量是有生命周期的，当函数运行完毕就会销毁。函数最后一个语句一般是return，当你return一个指针的时候，这个指针还是存在的，即指针指向地址存储着你需要的信息，但是一旦return执行完毕，这个局部指针就会被销毁（其中的值被销毁，内存的地址编码是固定的，地址是不会被消除的）。当你在外面的程序访问时，你访问的确实还是这个地址，但是里面的内容是不可预测的，因为局部指针销毁后，程序会认为这个地址对应的存储空间是空闲的，会分配给程序中的其他变量。所以从效果上看就像是指针不知道指到哪里去了，也就是野指针。</li></ol><h3 id="指针传参与形参传参的区别"><a href="#指针传参与形参传参的区别" class="headerlink" title="指针传参与形参传参的区别"></a>指针传参与形参传参的区别</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_value_1</span><span class="params">(<span class="keyword">int</span> a)</span></span>{</span><br><span class="line">    a=a*a+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_value_1</span><span class="params">(<span class="keyword">int</span>* a)</span></span>{</span><br><span class="line">    *a=(*a)*(*a)+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于这两个函数，调用执行的效果是不一样的，对于第一个方法，使用的是形参，形参可以看做是函数的局部变量，传递参数的过程可以等效为在函数中声明一个局部变量，再把传递的实参的值赋给这个局部变量。因此我们后续在函数中操作这个变量都不会影响到传递过来的实参，相当于我们开了个副本来操作，当函数执行完毕就会销毁。但如果参数是个指针，同样的我们也是声明一个局部指针，拷贝传参的实参，但是不一样的是：当地址一样时，我们访问的就是同一个变量，所以我们在函数通过局部指针访问和在程序外通过实参访问的是一个变量，修改自然也就会生效。</p><p>关于指针有太多的用法和注意点，学好指针是每个合格的C程序员所必须的，本文也只是讲了最基础的语法，指针的运用才是最为迷人的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web_Spider_3</title>
      <link href="2019/09/02/web-spider-3/"/>
      <url>2019/09/02/web-spider-3/</url>
      
        <content type="html"><![CDATA[<h1 id="网络爬虫入门教程（3）"><a href="#网络爬虫入门教程（3）" class="headerlink" title="网络爬虫入门教程（3）"></a>网络爬虫入门教程（3）</h1><p>这篇博客将继续介绍爬虫程序中模拟登陆的解决方法、post方式和信息提取的方法。</p><a id="more"></a><h4 id="使用post方式进行模拟登陆"><a href="#使用post方式进行模拟登陆" class="headerlink" title="使用post方式进行模拟登陆"></a>使用post方式进行模拟登陆</h4><p>在之前的博客中所介绍的爬虫都是以get的方式来访问服务器的，这篇博客将讲述post方式的基本用法。</p><p>前一篇博客引出了登陆问题，（这里解释一下）由于HTTP协议是无状态的（下一次请求并不知道上一次请求的信息），所以登陆之后服务器与浏览器之间进行的各种请求与响应需要确定用户是否登陆，自然而然我们需要一个标志，而cookie就充当了这样一个角色。所以我们要想解决登陆问题，就必须想办法获取cookie，上一篇博客中采用抓包是一种方式，但是显然不是我们想要的，下面就给出纯代码模拟登陆的方法：</p><p>在这个代码中，我们要爬取人人网个人页面的html文件，显然需要先进行登陆。在写代码前我们需要用fiddler抓取登陆时的包，找到host的URL和表单数据，为post请求做准备，为解决cookie问题，我们要引入cookiejar这个模块，用cookiejar创建handler再用handler创建opener，此后的请求都使用opener，cookiejar对象在登陆成功后会自动保存cookie</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> http.cookiejar</span><br><span class="line"><span class="comment">#创建一个cookiejar对象</span></span><br><span class="line">cj=http.cookiejar.CookieJar()</span><br><span class="line"><span class="comment">#通过cookiejar对象创建一个handler</span></span><br><span class="line">handler=urllib.request.HTTPCookieProcessor(cj)</span><br><span class="line"><span class="comment">#根据handler创建一个opener</span></span><br><span class="line">opener=urllib.request.build_opener(handler)</span><br><span class="line">post_url=<span class="string">"http://www.renren.com/ajaxLogin/login?1=1&amp;uniqueTimestamp=2019822154521"</span></span><br><span class="line"><span class="comment">#这是表单数据，从fiddler中复制过来，改成字典格式</span></span><br><span class="line">form_data={</span><br><span class="line">        <span class="string">'email'</span>:<span class="string">'18258317595'</span>,</span><br><span class="line">        <span class="string">'icode'</span>:<span class="string">''</span>,</span><br><span class="line">        <span class="string">'origURL'</span>:<span class="string">'http://www.renren.com/home'</span>,</span><br><span class="line">        <span class="string">'domain'</span>:<span class="string">'renren.com'</span>,</span><br><span class="line">        <span class="string">'key_id'</span>:<span class="string">'1'</span>,</span><br><span class="line">        <span class="string">'captcha_type'</span>:<span class="string">'web_login'</span>,</span><br><span class="line">        <span class="string">'password'</span>:<span class="string">'567e34db122fc42aa42d8fbe6b76f32beee819ea7aa6639d1e5994ef6c2f85e3'</span>,</span><br><span class="line">        <span class="string">'rkey'</span>:<span class="string">'88c3ce72a86f84868e5006432a0566bc'</span>,</span><br><span class="line">        <span class="string">'f'</span>:<span class="string">'http%3A%2F%2Fwww.renren.com%2F971983124%2Fnewsfeed%2Fphoto'</span>,</span><br><span class="line">        }</span><br><span class="line">headers={</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36 Edge/18.18362'</span>,</span><br><span class="line">        }</span><br><span class="line">request=urllib.request.Request(url=post_url,headers=headers)</span><br><span class="line">form_data=urllib.parse.urlencode(form_data).encode()</span><br><span class="line">response=opener.open(request,form_data)</span><br><span class="line">print(response.read().decode())</span><br><span class="line"><span class="comment">#登陆后再用get请求获取HTML文件</span></span><br><span class="line">get_url=<span class="string">"http://www.renren.com/971983124/profile"</span></span><br><span class="line">request=urllib.request.Request(get_url,headers=headers)</span><br><span class="line">response=opener.open(request)</span><br><span class="line">print(response.read().decode())</span><br></pre></td></tr></tbody></table></figure><h4 id="post请求的一般格式"><a href="#post请求的一般格式" class="headerlink" title="post请求的一般格式"></a>post请求的一般格式</h4><p>post请求的格式和get很相似，不同之处在于：get请求传输的数据是querystring，通过拼接的方式附在URL后面，而post传输数据则以表单的方式，相对安全性要高。在编写代码时，get方式要注意参数的拼接，而post方式要以字典的形式把formdata数据传递给服务器。下面再给出一个post方式的例子：</p><p>这个例子模拟用户使用百度翻译，获取搜索结果（由于百度采取了加密，所以当我们更改搜索的单词时，爬虫程序会失效，想要破解需要分析js代码，找出加密的方式，理论可行，实际非常困难）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line">word=<span class="string">'baby'</span></span><br><span class="line">post_url=<span class="string">"https://fanyi.baidu.com/v2transapi"</span></span><br><span class="line">headers={</span><br><span class="line">         <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36 Edge/18.18362'</span>,</span><br><span class="line"><span class="comment">#         'Accept': '*/*',</span></span><br><span class="line"><span class="comment">#         'Accept-Language': 'zh-Hans-CN,zh-Hans;q=0.5',</span></span><br><span class="line"><span class="comment">#         'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',</span></span><br><span class="line"><span class="comment">#         'X-Requested-With': 'XMLHttpRequest',</span></span><br><span class="line"><span class="comment">#         'Accept-Encoding': 'gzip, deflate, br',</span></span><br><span class="line"><span class="comment">#         'Host': 'fanyi.baidu.com',</span></span><br><span class="line"><span class="comment">#         'Content-Length': '121',</span></span><br><span class="line"><span class="comment">#         'Connection': 'Keep-Alive',</span></span><br><span class="line"><span class="comment">#         'Cache-Control': 'no-cache',</span></span><br><span class="line">         <span class="string">'Cookie'</span>: <span class="string">'BDRCVFR[k2U9xfnuVt6]=mk3SLVN4HKm; H_PS_PSSID=; delPer=0; PSINO=1; BAIDUID=B25FFDAC5A102DA419F1283CC7BE770D:FG=1; BIDUPSID=B25FFDAC5A102DA419F1283CC7BE770D; PSTM=1567391659; BDORZ=FFFB88E999055A3F8A630C64834BD6D0; yjs_js_security_passport=9dad9c7e98f7c96362e0901326330787f15c901f_1567511321_js; BDUSS=gzQmJoTUlJMTJ4NjRLS0IzdGNPOWZRcGNrT1F-U1dEOFI1N0JvczlnbmJrWlJkRVFBQUFBJCQAAAAAAAAAAAEAAADg1FhMt-e5~c7eutt6bQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANsEbV3bBG1dN2; __yjsv5_shitong=1.0_7_77bc4d143bb6e9e9889cea03584640024746_300_1567511320184_60.247.46.118_8ba4d331; locale=zh; Hm_lpvt_64ecd82404c51e03dc91cb9e8c025574=1567511320; from_lang_often=%5B%7B%22value%22%3A%22zh%22%2C%22text%22%3A%22%u4E2D%u6587%22%7D%2C%7B%22value%22%3A%22en%22%2C%22text%22%3A%22%u82F1%u8BED%22%7D%5D; SOUND_PREFER_SWITCH=1; APPGUIDE_8_0_0=1; to_lang_often=%5B%7B%22value%22%3A%22en%22%2C%22text%22%3A%22%u82F1%u8BED%22%7D%2C%7B%22value%22%3A%22zh%22%2C%22text%22%3A%22%u4E2D%u6587%22%7D%5D; FANYI_WORD_SWITCH=1; Hm_lvt_64ecd82404c51e03dc91cb9e8c025574=1567511320; SOUND_SPD_SWITCH=1; REALTIME_TRANS_SWITCH=1; HISTORY_SWITCH=1'</span>,</span><br><span class="line">        }</span><br><span class="line">form_data={</span><br><span class="line">        <span class="string">'from'</span>:<span class="string">'en'</span>,</span><br><span class="line">        <span class="string">'to'</span>:<span class="string">'zh'</span>,</span><br><span class="line">        <span class="string">'query'</span>:word,</span><br><span class="line">        <span class="string">'transtype'</span>:<span class="string">'realtime'</span>,</span><br><span class="line">        <span class="string">'simple_means_flag'</span>:<span class="string">'3'</span>,</span><br><span class="line">        <span class="string">'sign'</span>:<span class="string">'814534.560887'</span>,</span><br><span class="line">        <span class="string">'token'</span>:<span class="string">'4b7ec249cc1766cf4cb6d26480abbce4'</span>,</span><br><span class="line">        }</span><br><span class="line">form_data=urllib.parse.urlencode(form_data).encode()</span><br><span class="line">request=urllib.request.Request(post_url,headers=headers)</span><br><span class="line">response=urllib.request.urlopen(request,form_data)</span><br><span class="line">print(response.read().decode())</span><br></pre></td></tr></tbody></table></figure><p>post方式的表单数据无法在浏览器找到，必须进行抓包来获取。在这个例子中，我们在headers中仅仅模拟User-agent这一项无法获取到html，此时我们应该把header中的内容全部复制过来（Accept-Encoding除外，加入这一项则服务器返回的资源进行了压缩，而我们无法用程序进行解压缩，所以不能加入这一项），当然并不是所有的项都起作用。在这个例子中，经过检验可知header中只有UA和cookie起作用。</p><h2 id="页面数据提取的三种方式"><a href="#页面数据提取的三种方式" class="headerlink" title="页面数据提取的三种方式"></a>页面数据提取的三种方式</h2><h4 id="1-正则表达式（基于python，其他语言或有不同）"><a href="#1-正则表达式（基于python，其他语言或有不同）" class="headerlink" title="1.正则表达式（基于python，其他语言或有不同）"></a>1.正则表达式（基于python，其他语言或有不同）</h4><ul><li>匹配单个字符</li></ul><div class="table-container"><table><thead><tr><th>\d</th><th>匹配一个数字（0-9）</th></tr></thead><tbody><tr><td>\w</td><td>匹配一个字母或数字（0-9 或 a-z 或 A-Z）</td></tr><tr><td>.</td><td>匹配除换行以为所有单字符</td></tr><tr><td>[0-9]</td><td>匹配一个0-9的数字相当于\d，非固定形式，也可以[3-7]等等，下同</td></tr><tr><td>[a-z]</td><td>匹配一个小写英文字符</td></tr><tr><td>[A-Z]</td><td>匹配一个大写英文字符</td></tr><tr><td>[0-9a-z]等</td><td>上述的组合，比如这个式子匹配一个数字或小写英文字符，还可以有其他组合</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\r</td><td>匹配一个回车符</td></tr><tr><td>\t</td><td>匹配一个制表符</td></tr><tr><td>\v</td><td>匹配一个垂直制表符（很少用）</td></tr></tbody></table></div><ul><li>匹配多个字符</li></ul><div class="table-container"><table><thead><tr><th>\s</th><th>匹配任何空白字符（亲测python包括空格、换行符、制表符、回车符）</th></tr></thead><tbody><tr><td>\S</td><td>匹配任何非空白字符</td></tr></tbody></table></div><ul><li>匹配数量限定符</li></ul><div class="table-container"><table><thead><tr><th>*</th><th>匹配前面的表达式零次或多次</th></tr></thead><tbody><tr><td>+</td><td>匹配前面的表达式一次或多次</td></tr><tr><td>？</td><td>匹配前面的表达式零次或一次</td></tr><tr><td>{n}</td><td>写在表达式后面，n是一个整数，表示匹配n次（不能多也不能少）。如r”o{p}”可以匹配apple中的“pp”而不能匹配person中的“p”</td></tr><tr><td>{n,}</td><td>写在表达式后面，n是一个整数,表示至少匹配n次（<strong>注意，没有{，n}这种形式</strong>）</td></tr><tr><td>{n,m}</td><td>写在表达式后面，n，m是一个整数，表示至少匹配n次，至多匹配m次</td></tr></tbody></table></div><ul><li>特殊符号</li></ul><div class="table-container"><table><thead><tr><th>$</th><th>用在表达式开头，限定从字符串结尾开始匹配，如r”$(app\w*?)”不能匹配“application”，但是能匹配“wapp”</th></tr></thead><tbody><tr><td>^</td><td>用在表达式开头，限定从字符串开头开始匹配</td></tr><tr><td>\b</td><td>匹配处于边界的字符串，即从开头或结尾开始匹配</td></tr><tr><td>\B</td><td>匹配非边界字符串，即匹配处于中间的字符串</td></tr><tr><td>()</td><td>括号内的表达式所匹配的字符将是你想要获取的，可使用多个括号，但不能嵌套，有多个括号时用\n(n为括号的标号，n从0开始)代表第n+1个括号。如r”ab(\w)oul(\d+)ge\1”中\1代表再次匹配第二个括号，且调用方法如re.findall时返回的将是括号内匹配到的内容，单个括号返回字符，多个括号返回列表</td></tr><tr><td>？</td><td>限定非贪婪模式，即匹配?前面的表达式时，尽量匹配最少的字符。如当r”\d+”会匹配”23232dfe”中的”23232”，而r”\d+?”只会匹配最少的“2”，因为+限定了最少匹配一个</td></tr><tr><td>\</td><td></td><td>逻辑或，\</td><td>两边的表达式，只要满足一个就会匹配成功，可使用多次</td></tr><tr><td>\</td><td>取消转义，若要匹配上述表格中的符号需要在前面使用\取消转义，如r”\?”匹配“?”字符</td></tr></tbody></table></div><ul><li>尾部的修饰符</li></ul><div class="table-container"><table><thead><tr><th>re.I</th><th>大小写不敏感，即匹配时不区分大小写</th></tr></thead><tbody><tr><td>re.M</td><td>多行匹配，作用于^和$。正常模式下r” ^she$”只会匹配第一行中的she，而指定re.M则会匹配每一行中的she</td></tr><tr><td>re.S</td><td>使得.可以匹配包括\n在内的所有字符</td></tr><tr><td></td></tr></tbody></table></div><p>下面是爬虫常用的一些正则表达式：</p><ol><li><p>Email地址：^\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*$</p></li><li><p>域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?</p></li><li><p>Internet URL：[a-zA-z]+://[^\s]<em> 或 ^<a href="http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=" target="_blank" rel="noopener">http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=</a>]</em>)?$</p></li><li><p>html标签：</p><ul><li><p>单标签</p><p>(&lt;.*?&gt;)</p></li><li><p>双标签</p><p>r”(&lt;\w+?.<em>?&gt;.</em>?&lt;/.*?&gt;)”</p></li></ul></li></ol><h4 id="2-xpath"><a href="#2-xpath" class="headerlink" title="2. xpath"></a>2. xpath</h4><p>xpath是基于树结构来查找标签元素的，因此用来解析HTML非常方便，下面给出xpath的语法</p><div class="table-container"><table><thead><tr><th>//</th><th>选取当前的所有节点（标配的开头）</th></tr></thead><tbody><tr><td>.</td><td>选取当前节点（二次Xpath提取时会使用）</td></tr><tr><td>..</td><td>选取当前节点父节点</td></tr><tr><td>@</td><td>选取属性</td></tr><tr><td>*</td><td>匹配任何元素节点</td></tr><tr><td>@*</td><td>选取所有有属性的节点</td></tr><tr><td>/</td><td>从根节点选取，即选取根节点下的元素，如//div/span选取div下的span</td></tr><tr><td>label[@xxx=”###”]</td><td>选取某个有属性xxx,且属性值为###的标签</td></tr><tr><td>contains(@property,’key’)</td><td>选取有property属性且属性值包含key的元素</td></tr><tr><td>starts-with(@property,’key’)</td><td>选取有property属性且属性值开头为key的元素</td></tr><tr><td>div[text()=’key’]</td><td>选取内容为key的div（可换为其他标签）</td></tr><tr><td>/text()</td><td>获取某个元素的文本内容，即html标签之间的内容</td></tr></tbody></table></div><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">link</span>=<span class="string">"www.baidu.com"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sp"</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span> <span class="attr">name</span>=<span class="string">"hello"</span>&gt;</span>65<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">name</span>=<span class="string">"bjiu"</span>&gt;</span>7467<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>例如要选择最内层第三个div，xpath可写为：</p><p>\\div[@class=”content”]\\p[contains(@link,”baidu”)]\div[2]</p><p>当xpath匹配的不是一个元素而是多个元素时，可以像数组一样使用下标来获取其中的元素</p><p>xpath选取出来的元素可以继续用xpath来提取内容，所以当难以一次性的xpath比较难写时，或者要提取的内容处于不同位置单其父级具有相同的结构时可以考虑先定位到父元素，再提取最终想要的内容。</p><h4 id="3-beautifulsoup"><a href="#3-beautifulsoup" class="headerlink" title="3. beautifulsoup"></a>3. beautifulsoup</h4><p>首先要构建一个beautifulsoup的对象</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(open(<span class="string">'xxx.html'</span>, encoding=<span class="string">'utf8'</span>), <span class="string">'lxml'</span>)</span><br></pre></td></tr></tbody></table></figure><ul><li><p>可以以”.”来访问某个元素的子元素;可以使用字典索引的方式访问元素的属性值</p><p>如soup.a[‘herf’]表示提取整个html中a标签的链接</p></li><li><p>可以通过“.text”或者”get_text()”或者”.string”获取标签中的文本</p><p>如soup.div.text/.string/.get_text()表示提取div中的文本。</p><p>.text和.string有一些区别，详细请参考<a href="https://blog.csdn.net/zqxnum1/article/details/84587357这篇博客" target="_blank" rel="noopener">https://blog.csdn.net/zqxnum1/article/details/84587357这篇博客</a></p></li><li><p>find(label,property=value),选取有属性property且值为value的label，找到一个就返回</p><p>find_all(label,property=value)，同上，但是返回一个列表，可通过索引访问其中元素</p><p>如：soup.find_all(‘span’,’class’=’gave’)选取所有class=gave的span标签</p></li><li><p>select(‘标签选择器’)</p><p>select里面写css中的标签选择器</p><p>如：select(div&gt;span&gt;ul)表示选取div下的span下的ul</p><p>​        select(.book&gt;span&gt;div)表示选取class=book的元素下的span下的ul</p></li></ul><p>如想了解更多用法，右转官方文档$\rightarrow$<a href="https://beautifulsoup.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://beautifulsoup.readthedocs.io/zh_CN/latest/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Spider_2</title>
      <link href="2019/08/28/web-spider-2/"/>
      <url>2019/08/28/web-spider-2/</url>
      
        <content type="html"><![CDATA[<h1 id="网络爬虫入门教程（2）"><a href="#网络爬虫入门教程（2）" class="headerlink" title="网络爬虫入门教程（2）"></a>网络爬虫入门教程（2）</h1><p>接着上一篇博客，这篇博客会具体讲述网络爬虫代码的构建。</p><a id="more"></a><h2 id="何为爬虫"><a href="#何为爬虫" class="headerlink" title="何为爬虫"></a>何为爬虫</h2><p>相信很多人都听说过网络爬虫，但是就我的经验而言，很多人并不了解它究竟是什么。（问这是一种什么虫子的人 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span> ）实际上网络爬虫只是在网络上收集资源的程序，简单的来说就是去网上批量下载各种资源，并且完成目标内容的提取。</p><h2 id="代码编写大纲"><a href="#代码编写大纲" class="headerlink" title="代码编写大纲"></a>代码编写大纲</h2><ol><li>想要去网上下载资源，首先得有URL，批量下载资源时URL不能简单的认为获取，而要从网上获取</li><li>虽然有了URL就可以访问网页，但是程序毕竟和浏览器不一样，所以得进行伪装</li><li>向服务器发起请求，下载资源</li><li>编码问题<ul><li>在网络传输数据时，由于是tcp协议，所以采用字节传输，因此传输的内容（string）要先转换成二进制，同样的，当我们从网上下载得到的信息要进行解码。编码常用的编码字符集有utf-8和gbk两种，在解码时要用编码时的字符集进行解码</li><li>URL中只能出现限定的字符，中文、特殊字符不能出现（浏览器地址栏可以显示中文，应该是自动解码了）因此URL在进行拼接完后必须进行编码，否则会报错</li></ul></li></ol><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><ol><li><p>最简单的爬虫</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">url=<span class="string">'http://www.baidu.com'</span></span><br><span class="line">response=urllib.request.urlopen(url)</span><br><span class="line"><span class="comment">#其中decode()函数就是对获得的HTML内容进行解码</span></span><br><span class="line">print(response.read().decode())</span><br></pre></td></tr></tbody></table></figure><p><img src="http://src.zhumingcj.cn/blog/190828/lAAce2adLH.png?imageslim" alt="mark"></p><p>结果如图所示，我们就能得到百度的HTML文件，但是其实我们并没有成功的得到百度的HTML，在第三点中会讲到。</p></li><li><p>爬取百度贴吧</p><p>打开百度贴吧，我们可以得到URL为<code>[https://tieba.baidu.com](https://tieba.baidu.com/)</code>，然后我们输入“励志”，页面跳转，URL变为<code>https://tieba.baidu.com/f?ie=utf-8&amp;kw=励志&amp;fr=search</code>，改变搜索的词多试几次，我们会发现URL变化的只有kw=##这一项，于是我们可以知道##与搜索的内容有关。当然有的浏览器可能地址栏不显示中文（亲测edge显示编码后的内容，Chrome显示中文），但是有相同的规律，于是我们可以猜测##为搜索内容编码后的东西。我们可以通过站长工具这个网站在线进行URL的解码，发现##解码后就是搜索的内容。有时候我们会发现URL可能很长，这时我们可以删掉一些内容，用缩短后的URL进行访问，如果还能访问说明删除的那些参数是多于的，在这个例子中删除头和尾的参数并不影响正常访问，所以程序中的URL与浏览器地址栏中显示的并不一样</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="comment">#原始URL</span></span><br><span class="line">url=<span class="string">'https://tieba.baidu.com/'</span></span><br><span class="line">query_string=input(<span class="string">'请输入要下载的贴吧:'</span>)</span><br><span class="line"><span class="comment">#urlencode函数需要传递一个字典</span></span><br><span class="line">data={</span><br><span class="line">      <span class="string">'kw'</span>:query_string</span><br><span class="line">      }</span><br><span class="line">query_string=urllib.parse.urlencode(data)</span><br><span class="line"><span class="comment">#URL参数前要加？</span></span><br><span class="line">url=url+<span class="string">'?'</span>+query_string</span><br><span class="line">response=urllib.request.urlopen(url)</span><br><span class="line">print(response.read().decode())</span><br></pre></td></tr></tbody></table></figure><p>这个程序就能下载你想要的贴吧的HTML文件，经验证和在浏览器中搜索得到的是一样的</p></li><li><p>让代码伪装成服务器</p><p>如果像上面那样写程序去访问服务器，有时候可能会被服务器拒绝（其实第一个示例中返回的HTML只有这么短是不正常的，出现这种情况就是因为服务器识破了爬虫的身份），因为，有的服务器可以知道我们不是浏览器而是爬虫程序，所以必须进行伪装,伪装的方法只需要在请求中包含User-Agent这一项，User-Agent表明访问者的身份。User-Agent可以在谷歌浏览器中F12，然后在http请求中找到，也可以自行百度。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">url=<span class="string">'http://www.baidu.com'</span></span><br><span class="line">headers={</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'</span>,</span><br><span class="line">}</span><br><span class="line">request=urllib.request.Request(url,headers=headers)</span><br><span class="line">response=urllib.request.urlopen(request)</span><br><span class="line">print(response.read().decode())</span><br></pre></td></tr></tbody></table></figure><p>运行这个程序，我们才会得到百度真正的HTML，如图：</p><p><img src="http://src.zhumingcj.cn/blog/190828/AGdA0GgjKb.png?imageslim" alt="mark"></p></li><li><p>一个综合型的示例，获取指定贴吧的指定页内容，包括了URL拼接、请求构建、文件的写入</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">ba_name=input(<span class="string">'请输入要查询的贴吧名'</span>)</span><br><span class="line">start_page=int(input(<span class="string">'请输入起始页'</span>))</span><br><span class="line">end_page=int(input(<span class="string">'请输入结束页'</span>))</span><br><span class="line"><span class="comment">#创建用来保存的文件夹</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (os.path.exists(ba_name)):</span><br><span class="line">    os.mkdir(ba_name)</span><br><span class="line"><span class="comment">#URL中不变的内容</span></span><br><span class="line">url=<span class="string">'http://tieba.baidu.com/f?ie=utf-8&amp;'</span></span><br><span class="line">data={</span><br><span class="line">      <span class="string">'kw'</span>:ba_name, </span><br><span class="line">      }</span><br><span class="line">url+=urllib.parse.urlencode(data)</span><br><span class="line"><span class="keyword">for</span> page <span class="keyword">in</span> range(start_page,end_page+<span class="number">1</span>):</span><br><span class="line">    <span class="comment">#此处str((page-1)*50)这个规律是通过观察的出的--在浏览器访问不同页数，观察URL的变化，在这个例子中起始页URL中pn=0，第二页pn=50,第三页pn=100...规律可得</span></span><br><span class="line">    url_new=url+(<span class="string">'&amp;pn='</span>+str((page<span class="number">-1</span>)*<span class="number">50</span>))</span><br><span class="line"><span class="comment">#    print(url_new)</span></span><br><span class="line">    proxy=urllib.request.ProxyHandler()</span><br><span class="line">    opener=urllib.request.build_opener(proxy)</span><br><span class="line">    headers={</span><br><span class="line">             <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'</span>,</span><br><span class="line">            }</span><br><span class="line">    request=urllib.request.Request(url=url_new,headers=headers)</span><br><span class="line">    print(<span class="string">'第%s页开始下载...'</span>% page)</span><br><span class="line">    response= opener.open(request)</span><br><span class="line">    filename=ba_name+<span class="string">'_'</span>+ str(page) + <span class="string">'.html'</span></span><br><span class="line">    filepath=ba_name+<span class="string">'/'</span>+filename</span><br><span class="line">    <span class="keyword">with</span> open(filepath,<span class="string">'wb'</span>)<span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(response.read())</span><br><span class="line">    print(<span class="string">'第%s页结束下载...'</span>% page)</span><br></pre></td></tr></tbody></table></figure><p>运行这个程序我们就可以得到HTML文件（貌似不怎么完整，应该是百度搞了防盗措施），但是这个例子是很理想化的，在大多数情况下我们很有可能找不到页码变化和URL变化之间的规律</p></li><li><p>为了解决页码变化和URL变化“无联系”（联系肯定有，只是做了加密）的问题，我们可以从已经得到HTML中获取下一页的URL，因为在浏览器中我们去往下一页需要点击某“下一页”的按钮，如果了解HTML语言，我们就知道“下一页”按钮在HTML中就是一个a标签，而a标签中就会有下一页的URL，因为涉及到内容的解析，这只做说明，相关例子将在下一篇博客中给出。</p></li><li><p>正所谓道高一尺，魔高一丈，爬虫多了对服务器来说压力会很大，所以很多服务器会有反爬的措施，常见的有防盗链、ip检测、验证码等等，其中比较好处理的是ip检测。要想解决ip检测的问题首先你得有代理服务器（网上可租，也有免费的，哎，免费的不敢保证），通过代理的方式我们就能避免这个问题。代理这个概念在生活中很常见，代理就是找第三方帮你做事，也就是爬虫程序不直接向服务器发起请求，而是由代理服务器向服务器发起请求，然后再返回给爬虫程序，因此服务器不会知道你的ip，也就封不了。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line">url = <span class="string">'http://www.baidu.com/'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置代理，在ProxyHandler中传入代理ip加端口号</span></span><br><span class="line">proxy = urllib.request.ProxyHandler({<span class="string">'http'</span>: <span class="string">'http://127.0.0.1:8888/'</span>})</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个打开器，opener比urlopen强大得多，有很多urlopen做不到的功能，比如代理、验证cookie</span></span><br><span class="line">opener = urllib.request.build_opener(proxy)</span><br><span class="line"></span><br><span class="line"><span class="comment">#install_opener会使得代理全局生效，即使用urlopen方法其实会调用创建的opener的open方法</span></span><br><span class="line">urllib.request.install_opener(opener)</span><br><span class="line">headers={</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'</span>,</span><br><span class="line">        </span><br><span class="line">        }</span><br><span class="line">request=urllib.request.Request(url=url,headers=headers)</span><br><span class="line">response =urllib.request.urlopen(request)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure></li><li><p>对于需要登录的网站，如果我们采取上面的方法来下载HTML文件，虽然可能不报错，但是肯定获取不到HTML文件。这说明我们没有完全模仿浏览器，这时如果我们在谷歌浏览器中审查元素，把http协议中的请求头黏贴到headers中，再运行程序发现又可以获取到HTML了。其实在登录过程中，服务器的响应中会返回设置cookie的一个命令，然后浏览器就会保存这个cookie，作为登录过的凭证，每次浏览器访问登录后才能访问的内容时都要携带这个cookie服务器才会返回请求的资源，解决登录问题简单粗暴的方法就是在浏览器找到cookie粘贴到headers中，如</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">url=<span class="string">'http://www.renren.com/971983124/newsfeed/photo'</span></span><br><span class="line">headers={</span><br><span class="line">        <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50'</span>,</span><br><span class="line">        <span class="string">'Cookie'</span>: <span class="string">'anonymid=jzjetqke-tjiod7; depovince=BJ; _r01_=1; JSESSIONID=abcj8ylTjQ-n3_4qbLTYw; ick_login=5929d602-a414-4f1b-b8fa-83f01844c486; t=fdfdca524711412440e3aa2f89ddd00a4; societyguester=fdfdca524711412440e3aa2f89ddd00a4; id=971983124; xnsid=526b61a2; ver=7.0; loginfrom=null; jebe_key=5d8a8bf3-cf7c-441b-bc60-65f236cb5832%7Cbf794041c970cd1607a6fc82acb47392%7C1566280296884%7C1%7C1566280297531; jebe_key=5d8a8bf3-cf7c-441b-bc60-65f236cb5832%7Cbf794041c970cd1607a6fc82acb47392%7C1566280296884%7C1%7C1566280297535; wp_fold=0; jebecookies=576b6d5f-c52d-4d79-a6a6-6724e7aa3b0a|||||'</span></span><br><span class="line">        }</span><br><span class="line">request=urllib.request.Request(url,headers=headers)</span><br><span class="line">response=urllib.request.urlopen(request)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'renren.html'</span>,<span class="string">'wb'</span>)<span class="keyword">as</span> fp:</span><br><span class="line">    fp.write(response.read())</span><br></pre></td></tr></tbody></table></figure><p> 当然这个cookie早已过期，现在运行无法得到任何东西</p><hr><p>限于篇幅，更好的解决cookie的方法将在下一篇博客中给出</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Spider_1</title>
      <link href="2019/08/28/web-spider-1/"/>
      <url>2019/08/28/web-spider-1/</url>
      
        <content type="html"><![CDATA[<h1 id="网络爬虫入门教程（1）"><a href="#网络爬虫入门教程（1）" class="headerlink" title="网络爬虫入门教程（1）"></a>网络爬虫入门教程（1）</h1><p>刚入门网络爬虫，期望通过三篇博客来总结一下入门级爬虫程序的写法，希望能给那些想要入爬虫这个坑的人提供一些帮助。为了结构化的介绍爬虫，将分为：http协议、网络爬虫代码构建、内容提取三篇博客进行全面的讲解。</p><p><code>注：写爬虫要遵守相关法规，不能侵犯他人著作权！！！（简单的来说免费的网站都能爬，付费的很难爬也不能以此盈利，否则有前车之鉴，千万赔偿劝退）</code></p><a id="more"></a><h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p>下面先列出以下http协议的特性，但与爬虫关系不大，仅作了解（想要详细了解http，<a href="https://www.cnblogs.com/EricaMIN1987_IT/p/3837436.html" target="_blank" rel="noopener">参见这篇博客</a>）：</p><ol><li><p>http协议是明文传送非加密的，即是不安全的</p></li><li><p>http协议是无状态的，这并不是只连接（TCP）无状态，而是指服务器不会记录前一次访问的信息，通俗的讲就是：</p><p>浏览器：服务器，你欠我一百万</p><p>服务器：好，我给你一百万</p><p>浏览器：服务器，你还是欠我一百万</p><p>服务器：（傻傻的）给你一百万….</p><p>也就是说，即使浏览器发起N多个相同的请求，服务器都会响应</p></li><li><p>http协议连接不上持续的，即每次连接只处理一个请求，处理完就关闭连接，下一个请求会新建一个连接而不是保持前一个连接继续处理。</p></li></ol><h4 id="http的内容（重点）"><a href="#http的内容（重点）" class="headerlink" title="http的内容（重点）"></a>http的内容（重点）</h4><p>一个完整的http协议由请求行、请求头、空行、请求体四部分组成，下图是一个示例：</p><p><img src="http://src.zhumingcj.cn/blog/190828/fH0fjm35De.png?imageslim" alt="mark"></p><h5 id="请求行：请求方法-URL-http版本号"><a href="#请求行：请求方法-URL-http版本号" class="headerlink" title="请求行：请求方法+URL+http版本号"></a>请求行：请求方法+URL+http版本号</h5><ul><li>请求方法常见的有：<ul><li>get（最多）：向服务器请求某个资源，get会把数据（参数）拼接在URL中，在浏览器地址栏中可见，一般为？key=value&amp;key=value……的形式如<code>https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1</code>，因此get的安全性较低</li><li>post:用于向服务器提交数据，常见的场合为用户登录、注册等，post传输数据在请求体中，对用户不可见，安全性相对较高</li><li>其他还有（仅作了解，很少碰到）：<ul><li>OPTIONS - 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</li><li>HEAD- 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。</li><li>PUT - 向指定资源位置上传其最新内容。<br>DELETE - 请求服务器删除Request-URI所标识的资源。</li><li>TRACE- 回显服务器收到的请求，主要用于测试或诊断。</li><li>CONNECT - HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li><li>PATCH - 用来将局部修改应用于某一资源，添加于规范RFC5789。</li></ul></li></ul></li></ul><h5 id="请求头：有多个部分，下面列出常见的"><a href="#请求头：有多个部分，下面列出常见的" class="headerlink" title="请求头：有多个部分，下面列出常见的"></a>请求头：有多个部分，下面列出常见的</h5><ul><li>Accept：指定客户端能够接收的内容</li><li>Accept-Language：指定客户端能够接受的语言</li><li>Accept-Ecoding：指定客户端能够接受的编码类型</li><li>User-Agent：用户代理，向服务器说明自己的操作系统、浏览器等信息</li><li>Connection：是否开启持久连接（keepalive）</li><li>Host： 服务器域名</li><li>Cookie：最重要的请求头之一, 将cookie的值发送给HTTP服务器。</li><li>Content-Length：表示请求消息正文的长度。例如：Content-Length: 38。</li></ul><h5 id="请求体：请求的正文，内容不一，也可空"><a href="#请求体：请求的正文，内容不一，也可空" class="headerlink" title="请求体：请求的正文，内容不一，也可空"></a>请求体：请求的正文，内容不一，也可空</h5><h4 id="http的响应"><a href="#http的响应" class="headerlink" title="http的响应"></a>http的响应</h4><p>HTTP响应由三部分组成：状态行、响应头、响应正文；</p><p>状态行：包括协议版本Version、状态码Status Code、回应短语；</p><p>响应头：包括搭建服务器的软件，发送响应的时间，回应数据的格式等信息；</p><p>响应正文：就是响应的具体数据。</p><p>下面是一个示例</p><p><img src="http://src.zhumingcj.cn/blog/190828/KkEHhH2Gbf.png?imageslim" alt="mark"></p><p>其中常见的状态码有：</p><p>​        200—-OK/请求已经正常处理完毕</p><p>​        301—-/请求永久重定向</p><p>​        302—-/请求临时重定向</p><p>​        304—-/请求被重定向到客户端本地缓存</p><p>​        400—-/客户端请求存在语法错误</p><p>​        401—-/客户端请求没有经过授权</p><p>​        403—-/客户端的请求被服务器拒绝，一般为客户端没有访问权限</p><p>​        404—-/客户端请求的URL在服务端不存在</p><p>​        500—-/服务端永久错误</p><p>​        503—-/服务端发生临时错误</p><hr><p>想要编写爬虫程序就一定要对http协议有所了解，这篇博客只是大概地讲述了http协议，对于简单的爬虫程序已然够用，如果想深入的了解http协议，请移步下列博客</p><p><a href="https://segmentfault.com/a/1190000015969377" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015969377</a></p><p><a href="https://blog.csdn.net/aliujiujiang/article/details/81088317" target="_blank" rel="noopener">https://blog.csdn.net/aliujiujiang/article/details/81088317</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solution to VS2017 Installation Problem</title>
      <link href="2019/08/17/solution-to-vs2017-installation-problem/"/>
      <url>2019/08/17/solution-to-vs2017-installation-problem/</url>
      
        <content type="html"><![CDATA[<h1 id="VS2017安装中注册表问题的解决"><a href="#VS2017安装中注册表问题的解决" class="headerlink" title="VS2017安装中注册表问题的解决"></a>VS2017安装中注册表问题的解决</h1><p>今天在安装VS2017时碰到了一个棘手的问题导致所有的组件都无法使用，经过半天的捣鼓最终解决了以下的问题。</p><a id="more"></a><ul><li>注册表权限问题</li></ul><p>如果你的电脑里曾经安装过visual studio的产品，但是卸载的时候没有清除注册表，那么下一次安装的时候就可能出现下述情况：</p><p><img src="http://src.zhumingcj.cn/blog/190816/AD9B7GDCcK.jpg?imageslim" alt="mark"></p><p><img src="http://src.zhumingcj.cn/blog/190816/BFaAddh7f6.jpg?imageslim" alt="mark"></p><p>在安装Vs2017时会显示安装完成，但存在警告，打开VS2017exe文件创建项目时只有空白解决方案，找不到其它的模板，并且当我们查看日志详情时会显示下面的内容：</p><p><strong><em>详细信息</em></strong><br><strong><em>MSI: C:\ProgramData\Microsoft\VisualStudio\Packages\Microsoft.VisualStudio.MinShell.Msi.Resources,version=15.0.26621.2,language=zh-CN\Microsoft.VisualStudio.MinShell.Msi.Resources.msi，属性: REBOOT=ReallySuppress ARPSYSTEMCOMPONENT=1 MSIFASTINSTALL=”7” VSEXTUI=”1”</em></strong><br><strong><em>返回代码: 1603</em></strong><br><strong><em>返回代码详细信息: 安装时发生严重错误</em></strong><br><strong><em>消息 ID: 1402</em></strong><br><strong><em>消息详细信息: 无法打开注册表项\HKEY_LOCAL_MACHINE32\SOFTWARE\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_BLOCK_CROSS_PROTOCOL_FILE_NAVIGATION。请确认你是否有足够的权限访问该注册表项，或者与技术支持人员联系。</em></strong></p><p>其中注册表项$\times\times\times$的内容可能因计算机而异。</p><p><code>解决方法：</code></p><p>根据日志的提示可知是注册表的权限存在问题，导致安装程序无法访问。在这里我们可以使用快捷键win+R打开命令行，然后输入regedit进入注册表的管理。</p><p>在这里我遇到了一个大坑，按照日志的提示我们应该修改\HKEY_LOCAL_MACHINE32\SOFTWARE\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_BLOCK_CROSS_PROTOCOL_FILE_NAVIGATION的权限，但是64位的电脑根本没有HKEY_LOCAL_MACHINE32这一项，如果忽略32，则在\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\Main\FeatureControl下也无法找到FEATURE_BLOCK_CROSS_PROTOCOL_FILE_NAVIGATION，当然自己新建一个注册表也无济于事。</p><p> 反复试了几次后我一度放弃，但是想到32可能是32位电脑的情况后跑去百度了一下，在翻阅了大量博客和论     坛之后终于在Microsoft TechNet的论坛上找到了答案，原来在64位的电脑上HKEY_LOCAL_MACHINE32\Software会自动定向到HKEY_LOCAL_MACHINE\Software\Wow6432Node，所以我们要修改的权限应该是\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_BLOCK_CROSS_PROTOCOL_FILE_NAVIGATION才对。</p><p>具体修改时，可能一开始显示没有访问权限，但是我们可以右键-&gt;权限-&gt;添加组或用户名,添加的时候把Administrator和system都添加进去，并且它们要有完全控制的权限。</p><p>然后在重新安装后重启电脑就没问题了（可能还会警告，那也是同样的问题，参照日志该注册表权限就行，直到不报错）。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QR_Decomposition_2</title>
      <link href="2019/08/11/qr-decomposition-2/"/>
      <url>2019/08/11/qr-decomposition-2/</url>
      
        <content type="html"><![CDATA[<h1 id="QR分解（2）"><a href="#QR分解（2）" class="headerlink" title="QR分解（2）"></a>QR分解（2）</h1><p>QR分解是线性代数中一种常用的矩阵分解，即把矩阵分解为一个正规正交矩阵和一个上梯形矩阵——QR分解是求一般矩阵全部特征值的最有效并广泛应用的方法，同时也是许多迭代算法的基础。（QR分解续篇）</p><a id="more"></a><h2 id="豪斯霍尔的变换法"><a href="#豪斯霍尔的变换法" class="headerlink" title="豪斯霍尔的变换法"></a>豪斯霍尔的变换法</h2><ol><li><p>豪斯霍尔德变换定义</p><script type="math/tex; mode=display">设u\in R^{n}且||u||_{2}=1，矩阵H=I-2uu^{T}称为豪斯霍尔德矩阵</script></li><li><p>豪斯霍尔德矩阵的性质</p><ul><li><p>H矩阵是一个正交矩阵</p><script type="math/tex; mode=display">证：\\HH^{T}=(I-2uu^{T})(I-2uu^{T})\\=I-4uu^{T}+4uu^{T}uu^{T}\\=I-4uu^{T}+4u(u^{T}u)u^{T}\\=I-4uu^{T}+4uu^{T}=I</script></li><li><p>直观的来看，豪斯霍尔德变换是一个镜像变换，如图</p><p><img src="http://src.zhumingcj.cn/blog/20190812/7GlB4asAswuB.png?imageslim" alt="mark"></p><p>豪斯霍尔德矩阵的作用是把向量x映射到以π为镜面的像，其中平面π的法向量为u</p></li></ul></li></ol><h2 id="基于豪斯霍尔德变换的QR分解"><a href="#基于豪斯霍尔德变换的QR分解" class="headerlink" title="基于豪斯霍尔德变换的QR分解"></a>基于豪斯霍尔德变换的QR分解</h2><p>引理：</p><script type="math/tex; mode=display">设\ x\in R^{n}是任意的给定非零向量，v\in R^{n}是任意给定的单位向\\量，则存在初等反射矩阵H=I-2uu^{T},使得Hx=\sigma v，其中\sigma为常数</script><p>证明：</p><script type="math/tex; mode=display">\because v为单位向量\\\therefore x^{T}H^{T}Hx=\sigma^{2}v^{T}v=\sigma^{2}=||x||_{2}^{2}\Rightarrow\\\sigma=\pm\sqrt{||x||_{2}}\\又\because Hx=(I-2uu^{T})x=x-2uu^{T}x=x-2(u^{T}x)u=\sigma v\\\therefore u的方向与x-\sigma v方向相同\\\because u是单位向量\\\therefore u=\frac{x-\sigma x}{||x-\sigma x||_{2}}\\\therefore u存在且唯一，从而H存在</script><p><code>注：其中计算σ时，为避免舍入误差，应取</code><strong>$\sigma=-sgn(x_{1})||x||_{2}$</strong></p><p>实际上根据豪斯霍尔德变换的几何意义，我们可以把x看做原向量，v 看成变换后镜像向量的一个单位向量，则u向量方向一定为原向量（x）减去原向量（想）模长倍的镜像向量（v）。单位化后即为所要求的u。</p><p>QR分解的过程：</p><script type="math/tex; mode=display">设要分解的矩阵为：\\\quad\\A=\begin{pmatrix}a_{11}&a_{12}&\dots&a_{1n}\\a_{21}&a_{22}&\dots&a_{2n}\\\vdots&\vdots&&\vdots\\a_{m1}&a_{m2}&\dots&a_{mn}\end{pmatrix}=(a_{1},a_{2},\dots,a_{n})\\\quad\\记为\\A^{(0)}=(a_{1}^{(0)},a_{2}^{(0)},\dots,a_{n}^{(0)})=A\\\quad\\第一步：\\为把矩阵A的第一列化为(\sigma,0,\dots,0)^{T},取x=a_{1}^{(0)},v=e_{1}=(1,0,\dots,0)^{T}\\根据式（4），取\\u_{1}=\frac{a_{1}^{(0)}-\sigma_{1} e_{1}}{||a_{1}^{(0)}-\sigma _{1}e_{1}||_{2}}=\frac{w_{1}}{||w_{1}||_{2}}\\其中\sigma_{1}=-sgn(a_{1}^{(0)})||a_{1}^{(0)}||_{2},\ w_{1}=a_{1}^{(0)}-\sigma_{1}e_{1}\\而\\||w_{1}||_{2}=||a_{1}^{(0)}-\sigma_{1}e_{1}||_{2}=\sqrt{2(\sigma_{1}^{2}-\sigma_{1}a_{11}^{(0)}})\\2u_{1}u_{1}^{T}=\frac{2w_{1}w_{1}^{T}}{||w_{1}||_{2}^{2}}=\frac{w_{1}w_{1}^{T}}{\sigma_{1}(\sigma_{1}-a_{11}^{(0)})}=\frac{w_{1}w_{1}^{T}}{\alpha_{1}},\alpha_{1}=\sigma_{1}(\sigma_{1}-a_{11}^{(0)})\\令H_{1}=I-2u_{1}u_{1}^{T}=I-\alpha^{-1}w_{1}w_{1}^{T},用H_{1}左乘A^{(0)}得\\A^{(1)}=H_{1}A^{(0)}=(H_{1}a_{1}^{(0)},H_{1}a_{2}^{(0)},\dots,H_{1}a_{n}^{(0)})\\=(\sigma_{1} e_{1},a_{2}^{(1)},a_{3}^{(1)},\dots,a_{n}^{(1)})\\=\begin{pmatrix}\sigma_{1}&a_{12}^{(1)}&a_{13}^{(1)}&\dots&a_{1n}^{(1)}\\0&a_{22}^{(1)}&a_{23}^{(1)}&\dots&a_{2n}^{(1)}\\\vdots&\vdots&\vdots&&\vdots\\0&a_{m2}^{(1)}&a_{m3}^{(1)}&\dots&a_{mm}^{(1)}\end{pmatrix}\\\quad\\其中\\a_{j}^{(1)}=H_{1}a_{j}^{(0)}=a_{j}^{(0)}-\beta_{1j}(a_{1}^{(0)}-\sigma_{1}e_{1})\\=\begin{pmatrix}a_{1j}^{(0)}-\beta_{1j}(a_{11}^{(0)}-\sigma_{1})\\a_{2j}^{(0)}-\beta_{1j}a_{21}^{(0)}\\\vdots\\a_{mj}^{(0)}-\beta_{1j}a_{mj}^{(0)}\end{pmatrix}\\由此可得\\\left\{\begin{array}{}a_{1j}^{(1)}=a_{1j}^{(0)}-\beta_{1j}(a_{11}^{(0)}-\sigma_{1}),\quad j=2,3,\dots,n\\a_{ij}^{(1)}=a_{ij}^{(0)}-\beta_{1j}a_{i1}^{(0)},\quad i=2,3,\dots,m;j=2,3,\dots,n\end{array}\right.\\其中\\\beta_{ij}=\alpha_{1}^{-1}((a_{11}^{(0)}-\sigma_{1})a_{1j}^{(0)}+\sum_{i=2}^{m}a_{i1}^{(0)}a_{ij}^{(0)}),\quad j=2,3,\dots,n\\\quad\\第二步:\\记a_{2}^{(1)}=(a_{12}^{(1)},a_{22}^{(1)},\dots,a_{m2}^{(1)})^{T}=(a_{12}^{(1)},\widetilde a_{2}^{(1)T})^{T}\\重复第一步取\\u_{2}=\frac{\widetilde a_{2}^{(1)}-\sigma_{2}e_{1}^{(1)}}{||\widetilde a_{2}^{(1)}-\sigma_{2}e_{1}^{(1)}||_{2}}=\frac{w_{2}}{||w_{2}||_{2}}\\\sigma_{2}=-sgn(a_{22}^{(1)})||\widetilde a_{2}^{(1)}||_{2};w_{2}=\widetilde a_{2}^{(1)}-\sigma_{2}e_{1}^{(1)}\\构造\\\widetilde {H_{2}}=I-2u_{2}u_{2}^{T}=I-\alpha^{-1}w_{2}w_{2}^{T}令\\H_{2}=\begin{pmatrix}1&0\\0&\widetilde H_{2}\end{pmatrix}\\用H_{2}左乘A_{(2)}得\\A^{(2)}=H_{2}A^{(1)}=(\sigma_{1}e_{1},a_{12}^{(1)}e_{1}+\sigma_{2}e_{2},a_{3}^{(2)},\dots,a_{n}^{(2)})\\=\begin{pmatrix}\sigma_{1}&a_{12}^{(1)}&a_{13}^{(1)}&a_{14}^{(1)}&\dots&a_{1n}^{(1)}\\0&\sigma_{2}&a_{23}^{(2)}&a_{24}^{(2)}&\dots&a_{2n}^{(2)}\\0&0&a_{33}^{(2)}&a_{34}^{(2)}&\dots&a_{3n}^{(2)}\\\vdots&\vdots&\vdots&\vdots&&\vdots\\0&0&a_{m3}^{(2)}&a_{m4}^{(2)}&\dots&a_{mn}^{(2)}\end{pmatrix}\\继续重复这个过程直至s=min{m-1,n}步，最后得到\\A^{(s)}=H_{s}H_{s-1}\dots H_{1}A=R\\记\\H=H_{s}H_{s-1}\dots H_{1}A\\则\\HA=R \Rightarrow A=QR</script><ul><li><p>当m=n时,R是n阶可逆上三角矩阵</p></li><li><p>当m&gt;n时，R是$m \times  n$阶上梯形矩阵</p></li></ul><p>$\bigstar$ 矩阵的QR分解具有唯一性</p><script type="math/tex; mode=display">证明\\设存在两种分解 \quad A=QR=\widetilde Q \widetilde R\\\because A^{T}A=R^{T}QQR=R^{T}R\\A^{T}A=\widetilde R^{T} \widetilde Q \widetilde Q \widetilde R=\widetilde R^{T} \widetilde R\\又\because A^{T}A是对称正定的，且矩阵的楚列斯基分解是唯一的\\\therefore R=\widetilde R,\quad Q=\widetilde Q</script><p>$\bigstar$ QR分解常用于求解病态线性方程组Ax=b，即化为</p><script type="math/tex; mode=display">y=Q^{T}b,\quad Rx=y</script><p>通过这种方法求解线性方程是非常稳定的，得到的结果往往比三角分解好很多。</p><h3 id="豪斯霍尔德法QR分解的程序"><a href="#豪斯霍尔德法QR分解的程序" class="headerlink" title="豪斯霍尔德法QR分解的程序"></a>豪斯霍尔德法QR分解的程序</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">    {</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">            //验证程序正确性的demo</span><br><span class="line">            Matrix m = new Matrix(3, 3);</span><br><span class="line">            Matrix[] result_QR = m.QR_Decomposition();</span><br><span class="line">            result_QR[0].DisPlay();</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            result_QR[1].DisPlay();</span><br><span class="line">            Matrix n = result_QR[0] * result_QR[1];</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            n.DisPlay();</span><br><span class="line">        }</span><br><span class="line">//单位阶跃函数</span><br><span class="line">        public static int Sgn(float num)</span><br><span class="line">        {</span><br><span class="line">            if (num &lt; 0)</span><br><span class="line">            {</span><br><span class="line">                return -1;</span><br><span class="line">            }</span><br><span class="line">            else if (num == 0)</span><br><span class="line">            {</span><br><span class="line">                return 0;</span><br><span class="line">            }</span><br><span class="line">            else</span><br><span class="line">            {</span><br><span class="line">                return 1;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    \\类的封装</span><br><span class="line">        class Matrix</span><br><span class="line">        {</span><br><span class="line">            \\初始化及构造函数</span><br><span class="line">            public int row = 0;</span><br><span class="line">            public int column = 0;</span><br><span class="line">            private float[,] matrix;</span><br><span class="line">            public Matrix(int row, int column, int option)</span><br><span class="line">            {</span><br><span class="line">                this.row = row;</span><br><span class="line">                this.column = column;</span><br><span class="line">                matrix = new float[row, column];</span><br><span class="line">                if (option == 1)</span><br><span class="line">                {</span><br><span class="line">                    for (int i = 0; i &lt; row; i++)</span><br><span class="line">                    {</span><br><span class="line">                        for (int j = 0; j &lt; column; j++)</span><br><span class="line">                        {</span><br><span class="line">                            if (i == j)</span><br><span class="line">                            {</span><br><span class="line">                                matrix[i, i] = 1;</span><br><span class="line">                            }</span><br><span class="line">                            else</span><br><span class="line">                            {</span><br><span class="line">                                matrix[i, j] = 0;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            public Matrix(int row, int column)</span><br><span class="line">            {</span><br><span class="line">                this.row = row;</span><br><span class="line">                this.column = column;</span><br><span class="line">                Console.WriteLine($"Please enter a matrix with {this.row}rows,{this.column}colums");</span><br><span class="line">                matrix = new float[row, column];</span><br><span class="line">                try</span><br><span class="line">                {</span><br><span class="line">                    for (int i = 0; i &lt; row; i++)</span><br><span class="line">                    {</span><br><span class="line">                        for (int j = 0; j &lt; column; j++)</span><br><span class="line">                        {</span><br><span class="line">                            string mid = Console.ReadLine();</span><br><span class="line">                            var rows = mid.Split(' ');</span><br><span class="line">                            foreach (var item in rows)</span><br><span class="line">                            {</span><br><span class="line">                                matrix[i, j++] = float.Parse(item);</span><br><span class="line">                            }</span><br><span class="line"></span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                    }</span><br><span class="line">                    Console.WriteLine("\r\n");</span><br><span class="line">                }</span><br><span class="line">                catch (Exception e)</span><br><span class="line">                {</span><br><span class="line">                    Console.WriteLine($"something wrong!\n{e.Message}");</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">\\矩阵运算的重载</span><br><span class="line">            public static Matrix operator -(Matrix p1, Matrix p2)</span><br><span class="line">            {</span><br><span class="line">                if (p1.row == p2.row &amp;&amp; p1.column == p2.column)</span><br><span class="line">                {</span><br><span class="line">                    Matrix result = new Matrix(p1.row, p1.column, 0);</span><br><span class="line">                    for (int i = 0; i &lt; p1.row; i++)</span><br><span class="line">                    {</span><br><span class="line">                        for (int j = 0; j &lt; p1.column; j++)</span><br><span class="line">                        {</span><br><span class="line">                            result.matrix[i, j] = p1.matrix[i, j] - p2.matrix[i, j];</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    return result;</span><br><span class="line">                }</span><br><span class="line">                else</span><br><span class="line">                {</span><br><span class="line">                    throw new Exception();</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            public static Matrix operator *(float multip, Matrix p1)</span><br><span class="line">            {</span><br><span class="line"></span><br><span class="line">                Matrix result = new Matrix(p1.row, p1.column, 0);</span><br><span class="line">                for (int i = 0; i &lt; p1.row; i++)</span><br><span class="line">                {</span><br><span class="line"></span><br><span class="line">                    for (int j = 0; j &lt; p1.column; j++)</span><br><span class="line">                    {</span><br><span class="line"></span><br><span class="line">                        result.matrix[i, j] = p1.matrix[i, j] * multip;</span><br><span class="line"></span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">                return result;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            public static Matrix operator *(Matrix p1, Matrix p2)</span><br><span class="line">            {</span><br><span class="line">                if (p1.column != p2.row)</span><br><span class="line">                {</span><br><span class="line">                    //Matrix a = new Matrix(1, 2) { matrix = p1.matrix };</span><br><span class="line">                    throw new Exception();</span><br><span class="line">                }</span><br><span class="line">                else</span><br><span class="line">                {</span><br><span class="line">                    Matrix result = new Matrix(p1.row, p2.column, 0);</span><br><span class="line">                    for (int i = 0; i &lt; p1.row; i++)</span><br><span class="line">                    {</span><br><span class="line"></span><br><span class="line">                        for (int j = 0; j &lt; p2.column; j++)</span><br><span class="line">                        {</span><br><span class="line">                            float temp = 0;</span><br><span class="line">                            for (int k = 0; k &lt; p1.column; k++)</span><br><span class="line">                            {</span><br><span class="line">                                temp += p1.matrix[i, k] * p2.matrix[k, j];</span><br><span class="line"></span><br><span class="line">                            }</span><br><span class="line">                            result.matrix[i, j] = temp;</span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                    }</span><br><span class="line">                    return result;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">//矩阵转置</span><br><span class="line">            public void Transpose()</span><br><span class="line">            {</span><br><span class="line">                this.row = column + row;</span><br><span class="line">                this.column = row - column;</span><br><span class="line">                this.row = row - column;</span><br><span class="line">                float[,] temp = new float[row, column];</span><br><span class="line">                for (int i = 0; i &lt; this.row; i++)</span><br><span class="line">                {</span><br><span class="line">                    for (int j = 0; j &lt; this.column; j++)</span><br><span class="line">                    {</span><br><span class="line">                        temp[i, j] = matrix[j, i];</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                matrix = temp;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">\\生成反射矩阵（豪斯霍尔德矩阵）</span><br><span class="line">            public Matrix ReflectMatrix(int order, Matrix column_vec, int suborder)</span><br><span class="line">            {</span><br><span class="line">                Matrix Reflect_matrix = new Matrix(order, order, 1);</span><br><span class="line">                \\生成单位向量</span><br><span class="line">                Matrix unit_vec = new Matrix(column_vec.row, column_vec.column, 1);</span><br><span class="line">                \\生成单位矩阵</span><br><span class="line">                Matrix unit_matrix = new Matrix(suborder, suborder, 1);</span><br><span class="line">                </span><br><span class="line">                \\需要使用临时变量存储转置矩阵（临时变量初始化不能直接赋值column_vec）,原因是：matrix是引用类型，赋值的方式只是使变量指向同一个对象，进行转置操作时会丢失原来的矩阵，下同</span><br><span class="line">                    </span><br><span class="line">                Matrix temp_1 = new Matrix(column_vec.row, column_vec.column, 0);</span><br><span class="line">                temp_1.matrix = column_vec.matrix;</span><br><span class="line">                temp_1.Transpose();</span><br><span class="line">                \\根据算法，计算相应参数</span><br><span class="line">                float sigma = -Sgn(column_vec.matrix[0, 0]) * (float)Math.Sqrt((temp_1 * column_vec).matrix[0, 0]);</span><br><span class="line">                float alpha = sigma * (sigma - column_vec.matrix[0, 0]);</span><br><span class="line">                Matrix omega = column_vec - sigma * unit_vec;</span><br><span class="line">                Matrix temp_2 = new Matrix(omega.row, omega.column, 0);</span><br><span class="line">                temp_2.matrix = omega.matrix;</span><br><span class="line">                temp_2.Transpose();</span><br><span class="line">                if (order == suborder)</span><br><span class="line">                {</span><br><span class="line">                    Reflect_matrix = unit_matrix - (1 / alpha) * omega * temp_2;</span><br><span class="line">                }</span><br><span class="line">                else</span><br><span class="line">                {</span><br><span class="line">                    Matrix temp_matrix = unit_matrix - (1 / alpha) * omega * temp_2;</span><br><span class="line">                    for (int i = order - suborder; i &lt; order; i++)</span><br><span class="line">                    {</span><br><span class="line">                        int start_value = order - suborder;</span><br><span class="line">                        for (int j = start_value; j &lt; order; j++)</span><br><span class="line">                        {</span><br><span class="line">                            Reflect_matrix.matrix[i, j] = temp_matrix.matrix[i - start_value, j - start_value];</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                return Reflect_matrix;</span><br><span class="line">            }</span><br><span class="line">//QR分解主程序</span><br><span class="line">             public Matrix[] QR_Decomposition()</span><br><span class="line">            {</span><br><span class="line">//准备储存结果的容器</span><br><span class="line">                Matrix result_Q = new Matrix(this.column, this.column, 1);</span><br><span class="line">                Matrix result_R = new Matrix(this.row, this.column, 0);</span><br><span class="line">                result_R.matrix = this.matrix;</span><br><span class="line">                //按列把待分解的矩阵化为上三角矩阵或上梯形矩阵</span><br><span class="line">                for (int i = 0; i &lt; column; i++)</span><br><span class="line">                {</span><br><span class="line">                    Matrix column_vec = new Matrix(row - i, 1, 0);</span><br><span class="line">                    for (int j = 0; j &lt; row - i; j++)</span><br><span class="line">                    {</span><br><span class="line">                        column_vec.matrix[j, 0] = result_R.matrix[j + i, i];</span><br><span class="line">                    }</span><br><span class="line">                    Matrix reflect_matrix = ReflectMatrix(row, column_vec, row - i);</span><br><span class="line">                    result_Q = reflect_matrix * result_Q;</span><br><span class="line">                    result_R = reflect_matrix * result_R;</span><br><span class="line">                }</span><br><span class="line">                result_Q.Transpose();</span><br><span class="line">                Matrix[] result = { result_Q, result_R };</span><br><span class="line">                return result;</span><br><span class="line">            }</span><br><span class="line">//仅用于矩阵的打印</span><br><span class="line">            public void DisPlay()</span><br><span class="line">            {</span><br><span class="line">                for (int i = 0; i &lt; this.row; i++)</span><br><span class="line">                {</span><br><span class="line">                    for (int j = 0; j &lt; this.column; j++)</span><br><span class="line">                    {</span><br><span class="line">                        Console.Write(string.Format("{0:F3}", matrix[i, j]) + "   ");</span><br><span class="line">                    }</span><br><span class="line">                    Console.WriteLine("\r");</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>同样使用两个例子验证算法的正确性：</p><ol><li><p>输入矩阵</p><script type="math/tex; mode=display">A=\begin{pmatrix}3&5&5\\0&3&4\\4&0&5\end{pmatrix}</script><p>得到输出如下图</p><p><img src="http://src.zhumingcj.cn/blog/20190815/SkulowJuHwNc.png?imageslim" alt="mark"></p></li><li><p>输入矩阵</p><script type="math/tex; mode=display">B=\begin{pmatrix}3 &14 &9\\6 &43 &3\\6 &22 &15\\\end{pmatrix}</script><p>得到结果如下图：</p><p><img src="http://src.zhumingcj.cn/blog/20190815/HOrW89mKmhjQ.png?imageslim" alt="mark"></p><p>经过检验，基本可以确定程序是正确的。</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Numerical Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QR decomposition</title>
      <link href="2019/08/08/qr-decomposition_1/"/>
      <url>2019/08/08/qr-decomposition_1/</url>
      
        <content type="html"><![CDATA[<h1 id="QR分解-1"><a href="#QR分解-1" class="headerlink" title="QR分解(1)"></a>QR分解(1)</h1><p>QR分解是线性代数中一种常用的矩阵分解，即把矩阵分解为一个正规正交矩阵和一个上梯形矩阵——QR分解是求一般矩阵全部特征值的最有效并广泛应用的方法，同时也是许多迭代算法的基础。</p><a id="more"></a><h2 id="QR分解的导出"><a href="#QR分解的导出" class="headerlink" title="QR分解的导出"></a>QR分解的导出</h2><p>QR分解可以通过两种基本的正交变换来导出——吉文斯变换和豪斯霍尔德变换，下面将详细地给出两种正交变换推导QR分解的过程。</p><h3 id="吉文斯变换法"><a href="#吉文斯变换法" class="headerlink" title="吉文斯变换法"></a>吉文斯变换法</h3><ol><li><p>吉文斯变换的定义</p><script type="math/tex; mode=display">对某个\theta，记s=sin\theta,c=cos\theta,设1\leq i \lt j \leq n\\P(i,j,\theta)=\begin{pmatrix}1&\\&\ddots\\&&1\\&&&c&&&&s\\&&&&1\\&&&&&\ddots\\&&&&&&1\\&&&-s&&&&c\\&&&&&&&&1\\&&&&&&&&&\ddots\\&&&&&&&&&&1\end{pmatrix}_{n\times  n}</script></li><li><p>吉文斯变换的特性</p><ul><li><p>通过计算我们可以得到$P(i,j,\theta)\times P(i,j,\theta)^{T}=I$，因此吉文斯变换矩阵是一个正交矩阵。</p></li><li><p>当吉文斯矩阵左乘一个方阵x时（$P(i,j,\theta)x$），只会改变x的第i个和第j个分量。</p><script type="math/tex; mode=display">事实上，设x=(x_{1},x_{2},\dots,x_{n})^{T},y=(y_{1},y_{2},\dots,y_{n})^{T}\\则根据y=P_{i,j}x可得\\y_{i}=cx_{i}+sx_{j},\quad y_{j}=-sx_{i}+cx_{j}</script></li><li><p>直观的看，吉文斯变换是一个平面旋转矩阵。由上一条性质，我们知道吉文斯矩阵只改变x的i,j分量，这种改变的几何意义是：它会把x在i,j平面的投影顺时针旋转$\theta$度，以二维的吉文斯矩阵为例：</p><script type="math/tex; mode=display">P_{(1,2)}=\begin{pmatrix}cos\theta&sin\theta\\-sin\theta&cos\theta\end{pmatrix}_{2\times2}\quad\\当我们取\theta为\frac{\pi}{2}时，我们得到\\P=\begin{pmatrix}0&1\\-1&0\end{pmatrix}用P左乘于x=(1,2)^{T}得到x'=(2,-1)\\我们可以看到x在P的作用下顺时针旋转了90^{\circ}</script></li><li><p>吉文斯矩阵可以将给定向量的某个分量化为零，由第二个特性，我们可以得到以下结论：</p><script type="math/tex; mode=display">当x_{i}^{2}+x_{j}^{2}\neq0时，欲使x_{j}'=0,只需要选取\\c=\frac{x_{i}}{\sqrt{x_{i}^{2}+x_{j}^{2}}},s=\frac{x_{j}}{\sqrt{x_{i}^{2}+x_{j}^{2}}}</script></li></ul></li></ol><pre><code> 也可以直观的理解为将给定向量在i,j平面的分量旋转至与i坐标轴重合，显然这种旋转存在且旋转角度就是上式所给出的。</code></pre><ol><li><p>基于吉文斯变换的QR分解</p><p>思路：由于QR分解的形式是分解为一个上梯形矩阵和一个正交矩阵，因此可以考虑用若干个吉文斯矩阵的乘积将给定矩阵化为上三角矩阵。</p></li></ol><p>   引理：设x是任意给定的非零向量，则存在有限个吉文斯矩阵的乘积P，使得$Px=||x||_{2}\vec e_{1}$，其中$\vec e_{i}=(1,0,\dots,0)$</p><p>   证明：</p><p>   根据吉文斯矩阵的最后一条特性，依次构造</p><script type="math/tex; mode=display">   P_{12}:c=\frac{x_{1}}{\sqrt{x_{1}^{2}+x_{2}^{2}}},\quad s=\frac{x_{2}}{\sqrt{x_{1}^{2}+x_{2}^{2}}}\\   \quad\\   P_{12}x=(\sqrt{x_{1}^{2}+x_{2}^{2}},0,x_{3},\dots,x_{n})^{T};\\   \quad\\   P_{13}:c=\frac{\sqrt{x_{1}^{2}+x_{2}^{2}}}{\sqrt{x_{1}^{2}+x_{2}^{2}+x_{3}^{2}}},\quad s=\frac{x_{3}}{\sqrt{x_{1}^{2}+x_{2}^{2}+x_{3}^{2}}}\\   \quad\\   P_{12}x=(\sqrt{x_{1}^{2}+x_{2}^{2}+x_{3}^{2}},0,0,x_{4},\dots,x_{n})^{T};\\   \quad\\   P_{1n}:c=\frac{\sqrt{x_{1}^{2}+x_{2}^{2}+\dots+x_{n-1}^{2}}}{\sqrt{x_{1}^{2}+x_{2}^{2}+\dots+x_{n}^{2}}},\quad s=\frac{x_{n}}{\sqrt{x_{1}^{2}+x_{2}^{2}+\dots+x_{n}^{2}}}\\   \quad\\   P_{12}x=(\sqrt{x_{1}^{2}+x_{2}^{2}+\dots+x_{n}^{2}},0,\dots,0)^{T}=||x||\vec e_{1};\\   证毕</script><p>   根据引理我们可进行基于吉文斯变换的QR分解：</p><p>   设A是一个$m\times n$的矩阵且它的列向量线性无关，则利用吉文斯变换可以把A逐步化为上梯形矩阵。</p><script type="math/tex; mode=display">   设\\   \quad\\   A=   \begin{pmatrix}   a_{11}&a_{12}&\dots&a_{1n}\\   a_{21}&a_{22}&\dots&a_{2n}\\   \vdots&\vdots&&\vdots\\   a_{m1}&a_{m2}&\dots&a_{mn}   \end{pmatrix}=   (a_{1},a_{2},\dots,a_{n})\\   \quad\\   并记\\   A^{(0)}=(a_{1}^{(0)},a_{2}^{(0)},\dots,a_{n}^{(0)})=A\\   变换过程如下：\\   第一步：\\   根据引理可以构造m-1个m阶吉文斯矩阵的乘积P_{1},使得\\   P_{1}a_{1}^{(0)}=||a_{1}^{(0)}||_{2}\vec e_{1}\\   \quad\\   记a_{11}=||a_{1}^{(0)}||_{2},用P_{1}左乘A^{0}得\Rightarrow\\   \quad\\   A^{(1)}=P_{1}A^{(0)}=   \begin{pmatrix}   a_{11}^{(1)}&a_{12}^{(1)}&\dots&a_{1n}^{(1)}\\   0&a_{22}^{(1)}&\dots&a_{2n}^{(1)}\\   \vdots&\vdots&&\vdots\\   0&a_{m2}^{(1)}&\dots&a_{mn}^{(1)}   \end{pmatrix}\\   第二步：\\   记a_{2}^{(1)}=(a_{12}^{(1)},a_{22}^{(1)},\dots,a_{m2}^{(1)})^{T}=(a_{12}^{(1)},\widetilde a_{2}^{(1)})\\   同理可以构造m-2个m-1阶吉文斯矩阵的乘积\widetilde P_{2}，使得\\   \widetilde P_{2}\widetilde a_{2}^{(1)}=||\widetilde a_{2}^{(1)}||_{2}\vec e_{1}\\   令\\   P_{2}=   \begin{pmatrix}   1&0\\   0&\widetilde P_{2}\\   \end{pmatrix},\\   用P_{2}左乘A^{(1)}得\\   A^{(2)}=P_{2}A^{(1)}=   \begin{pmatrix}   a_{11}^{(1)}&a_{12}^{(1)}&a_{13}^{(1)}&\dots&a_{1n}^{(1)}\\   0&a_{22}^{(2)}&a_{23}^{(2)}&\dots&a_{2n}^{(2)}\\   0&0&a_{33}^{(2)}&\dots&a_{3n}^{(2)}\\   \vdots&\vdots&\vdots&&\vdots\\   0&0&a_{m3}^{(2)}&\dots&a_{mn}^{(2)}   \end{pmatrix}\\   重复以上过程，构造P_{1},P_{2},\dots,P_{k},则   A^{(k-1)}=P_{k-1}P_{k-2}\dots P_{1}A^{(0)}\\   =   \begin{pmatrix}   a_{11}^{(1)}&a_{12}^{(1)}&\dots&a_{1,k-1}^{(1)}&a_{1k}^{(1)}&a_{1,k+1}^{(1)}&\dots&a_{1n}^{(1)}\\   0&a_{22}^{(2)}&\dots&a_{2,k-1}^{(2)}&a_{2k}^{(2)}&a_{2,k+1}^{(2)}&\dots&a_{2n}^{(2)}\\   &&\ddots&\vdots&\vdots&\vdots&&\vdots\\   0&0&0&a_{k-1,k-1}^{(k-1)}&a_{k-1,k}^{(k-1)}&a_{k-1,k+1}^{(k-1)}&\dots&a_{k-1,n}^{(k-1)}\\   0&0&0&0&a_{kk}^{(k-1)}&a_{k,k+1}^{(k-1)}&\dots&a_{kn}^{(k-1)}\\   \vdots&\vdots&\vdots&&\vdots\\   0&0&0&0&a_{mk}^{(k-1)}&a_{m,k+1}^{(k-1)}&\dots&a_{mn}^{(k-1)}   \end{pmatrix}\\   第k步：\\   记a_{k}^{(k-1)}=(a_{1k}^{(1)},a_{2k}^{(2)},\dots,a_{k-1,k}^{(k-1)},a_{kk}^{(k-1)},\dots,a_{mk}^{(k-1)})^{T}=(a_{1k}^{(1)},a_{2k}^{(2)},\dots,a_{k-1,k}^{(k-1)},\widetilde a_{k}^{(k-1)})^{T}\\   构造\\   \widetilde p_{k}\widetilde a_{k}^{(k-1)}=||\widetilde a_{k}^{(k-1)}||_{2}\vec e_{1}\\   令\\   P_{k}=   \begin{pmatrix}   I_{k-1}&0\\   0&\widetilde P_{k}   \end{pmatrix}\\   用P-{k}左乘A^{(k-1)}得\\   A^{(k)}=P_{k}P_{k-1}\dots P_{1}A^{(0)}\\   =   \begin{pmatrix}   a_{11}^{(1)}&a_{12}^{(1)}&\dots&a_{1,k-1}^{(1)}&a_{1k}^{(1)}&a_{1,k+1}^{(1)}&a_{1,k+2}^{(1)}&\dots&a_{1n}^{(1)}\\   &a_{22}^{(2)}&\dots&a_{2,k-1}^{(2)}&a_{2k}^{(2)}&a_{2,k+1}^{(2)}&a_{2,k+2}^{(2)}&\dots&a_{2n}^{(2)}\\   &&\ddots&\vdots&\vdots&\vdots&\vdots&&\vdots\\   &&&a_{k-1,k-1}^{(k-1)}&a_{k-1,k}^{(k-1)}&a_{k-1,k+1}^{(k-1)}&a_{k-1,k+2}^{(k-1)}&\dots&a_{k-1,n}^{(k-1)}&\\   &&&&a_{kk}^{(k)}&a_{k,k+1}^{(k)}&a_{k,k+2}^{(k)}&\dots&a_{kn}^{(k)}\\   &&&&&a_{k+1,k+1}^{(k)}&a_{k+1,k+2}^{(k)}&\dots&a_{k+1,n}^{(k)}\\   &&&&&\vdots&\vdots&&\vdots\\   &&&&&a_{m,k+1}^{(k)}&a_{m,k+2}^{(k)}&\dots&a_{m,n}^{(k)}\\   \end{pmatrix}\\</script><p>继续上述变换过程，直至$s=min\{m-1,n\}$步，最后得到</p><script type="math/tex; mode=display">A^{s}=P_{s}P_{s-1}\dots P_{1}A=R</script><p>由于上述的过程中每个$P_{i}$都是正交矩阵，所以$P=P_{s}P_{s-1}\dots P_{1}$也是正交矩阵，所以式（7）可以写为</p><script type="math/tex; mode=display">PA=R</script><ul><li>当m=n时，R是N阶上三角矩阵，这时式（8）可以写为</li></ul><script type="math/tex; mode=display">A=QR</script><p>​        其中$Q=P^{T}$为n阶正交矩阵，R为可逆的上三角矩阵</p><ul><li>当m&gt;n时，R是$m\times n$阶的上梯形矩阵，此时<script type="math/tex; mode=display">PA=R=\begin{pmatrix}R_{1}\\0\end{pmatrix}</script></li></ul><p>  其中$R_{1}$为可逆的上三角矩阵</p><p>至此，我们实现了矩阵A基于吉文斯变换的QR分解。</p><h3 id="吉文斯变换法QR分解的程序"><a href="#吉文斯变换法QR分解的程序" class="headerlink" title="吉文斯变换法QR分解的程序"></a>吉文斯变换法QR分解的程序</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">namespace QR_decomposition</span><br><span class="line">{</span><br><span class="line">    class Program</span><br><span class="line">    {</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">            //用于验证的demo，自行修改</span><br><span class="line">            Matrix m = new Matrix(3, 3);</span><br><span class="line">            Matrix[] result_QR = m.QR_Decomposition();</span><br><span class="line">            result_QR[0].DisPlay();</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            result_QR[1].DisPlay();</span><br><span class="line">            Matrix n = result_QR[0] * result_QR[1];</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            n.DisPlay();</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        //对象封装</span><br><span class="line">        class Matrix</span><br><span class="line">        {</span><br><span class="line">            //数据和矩阵形状的信息</span><br><span class="line">            public int row = 0;</span><br><span class="line">            public int column = 0;</span><br><span class="line">            private float[,] matrix;</span><br><span class="line">            //不同的构造方法，输入初始化和自动初始化</span><br><span class="line">            public Matrix(int row, int column, int option)</span><br><span class="line">            {</span><br><span class="line">                this.row = row;</span><br><span class="line">                this.column = column;</span><br><span class="line">                matrix = new float[row, column];</span><br><span class="line">                if (option == 1 &amp;&amp; row == column)</span><br><span class="line">                {</span><br><span class="line">                    for (int i = 0; i &lt; row; i++)</span><br><span class="line">                    {</span><br><span class="line">                        for (int j = 0; j &lt; row; j++)</span><br><span class="line">                        {</span><br><span class="line">                            if (i == j)</span><br><span class="line">                            {</span><br><span class="line">                                matrix[i, i] = 1;</span><br><span class="line">                            }</span><br><span class="line">                            else</span><br><span class="line">                            {</span><br><span class="line">                                matrix[i, j] = 0;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            public Matrix(int row, int column)</span><br><span class="line">            {</span><br><span class="line">                this.row = row;</span><br><span class="line">                this.column = column;</span><br><span class="line">                Console.WriteLine($"Please enter a matrix with {this.row}rows,{this.column}colums");</span><br><span class="line">                matrix = new float[row, column];</span><br><span class="line">                try</span><br><span class="line">                {</span><br><span class="line">                    for (int i = 0; i &lt; row; i++)</span><br><span class="line">                    {</span><br><span class="line">                        for (int j = 0; j &lt; column; j++)</span><br><span class="line">                        {</span><br><span class="line">                            string mid = Console.ReadLine();</span><br><span class="line">                            var rows = mid.Split(' ');</span><br><span class="line">                            foreach (var item in rows)</span><br><span class="line">                            {</span><br><span class="line">                                matrix[i, j++] = float.Parse(item);</span><br><span class="line">                            }</span><br><span class="line"></span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                    }</span><br><span class="line">                    Console.WriteLine("\r\n");</span><br><span class="line">                }</span><br><span class="line">                catch (Exception e)</span><br><span class="line">                {</span><br><span class="line">                    Console.WriteLine($"something wrong!\n{e.Message}");</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            //打印矩阵</span><br><span class="line">            public void DisPlay()</span><br><span class="line">            {</span><br><span class="line">                for (int i = 0; i &lt; this.row; i++)</span><br><span class="line">                {</span><br><span class="line">                    for (int j = 0; j &lt; this.column; j++)</span><br><span class="line">                    {</span><br><span class="line">                        Console.Write(string.Format("{0:F3}", matrix[i, j]) + "   ");</span><br><span class="line">                    }</span><br><span class="line">                    Console.WriteLine("\r");</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            //构造吉文斯矩阵的函数</span><br><span class="line">            public Matrix RotateMatrix(int order, float para1, float para2, int index1, int index2)</span><br><span class="line">            {</span><br><span class="line">                Matrix Rotate_matrix = new Matrix(order, order, 1);</span><br><span class="line">                float cos = (float)(para1 / (Math.Sqrt(Math.Pow(para1, 2) + Math.Pow(para2, 2))));</span><br><span class="line">                float sin = (float)(para2 / (Math.Sqrt(Math.Pow(para1, 2) + Math.Pow(para2, 2))));</span><br><span class="line">                Rotate_matrix.matrix[index1, index1] = cos;</span><br><span class="line">                Rotate_matrix.matrix[index2, index2] = cos;</span><br><span class="line">                Rotate_matrix.matrix[index1, index2] = sin;</span><br><span class="line">                Rotate_matrix.matrix[index2, index1] = -sin;</span><br><span class="line">                return Rotate_matrix;</span><br><span class="line">            }</span><br><span class="line">            //矩阵转置</span><br><span class="line">            public void Transpose()</span><br><span class="line">            {</span><br><span class="line">                float[,] temp=new float[row,column];</span><br><span class="line">                for (int i = 0; i &lt;this. row; i++)</span><br><span class="line">                {</span><br><span class="line">                    for (int j = 0; j &lt;this. column; j++)</span><br><span class="line">                    {</span><br><span class="line">                        temp[i, j] = matrix[j, i];</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                matrix = temp;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            //矩阵乘法的复写</span><br><span class="line">            public static Matrix operator *(Matrix p1, Matrix p2)</span><br><span class="line">            {</span><br><span class="line">                Matrix result = new Matrix(p1.row, p2.column, 0);</span><br><span class="line">                for (int i = 0; i &lt; p1.row; i++)</span><br><span class="line">                {</span><br><span class="line"></span><br><span class="line">                    for (int j = 0; j &lt; p2.column; j++)</span><br><span class="line">                    {</span><br><span class="line">                        float temp = 0;</span><br><span class="line">                        for (int k = 0; k &lt; p1.column; k++)</span><br><span class="line">                        {</span><br><span class="line">                            temp += p1.matrix[i, k] * p2.matrix[k, j];</span><br><span class="line"></span><br><span class="line">                        }</span><br><span class="line">                        result.matrix[i, j] = temp;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">                return result;</span><br><span class="line">            }</span><br><span class="line">            //QR分解的主要过程</span><br><span class="line">            public Matrix[] QR_Decomposition()</span><br><span class="line">            {</span><br><span class="line">//申明两个矩阵用于存放结果Q矩阵和R矩阵</span><br><span class="line">                Matrix result_Q = new Matrix(this.column, this.column, 1);</span><br><span class="line">                Matrix result_R = new Matrix(this.row, this.column, 0);</span><br><span class="line">                result_R.matrix = this.matrix;</span><br><span class="line">                //按照算法先列后行进行扫描</span><br><span class="line">                for (int i = 0; i &lt; column; i++)</span><br><span class="line">                {</span><br><span class="line">                    for (int j = i + 1; j &lt; row; j++)</span><br><span class="line">                    {</span><br><span class="line">                        //遇到元素是零的情况，跳过此次循环</span><br><span class="line">                        if (result_R.matrix[j, i] == 0) continue;</span><br><span class="line">                        Matrix rotate_matrix = RotateMatrix(column, result_R.matrix[i, i], result_R.matrix[j, i], i, j);</span><br><span class="line">                        result_Q = rotate_matrix * result_Q;</span><br><span class="line">                        result_R = rotate_matrix * result_R;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                result_Q.Transpose();</span><br><span class="line">                Matrix[] result = { result_Q, result_R };</span><br><span class="line">                return result;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="程序的验证"><a href="#程序的验证" class="headerlink" title="程序的验证"></a>程序的验证</h4><p>对于上面的程序，我们用两个例子来进行验证：</p><ul><li><p>输入矩阵</p><script type="math/tex; mode=display">A=\begin{pmatrix}3&5&5\\0&3&4\\4&0&5\end{pmatrix}</script><p>我们将得到输出如下</p><p><img src="http://src.zhumingcj.cn/blog/20190811/c9Sf45LyEfIU.png?imageslim" alt="mark"></p><p>经过验证程序输出的QR分解是正确的，并且通过计算QR矩阵的乘积，我们得到了原来输入的矩阵，这足以证明程序的正确性</p></li><li><p>再次输入矩阵</p><script type="math/tex; mode=display">B=\begin{pmatrix}3 &14 &9\\6 &43 &3\\6 &22 &15\\\end{pmatrix}</script><p>输出结果如下</p><p><img src="http://src.zhumingcj.cn/blog/20190811/TDg3gezX4Q25.png?imageslim" alt="mark"></p><p>经过检验，结果依然是正确的。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Numerical Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Simple Classification</title>
      <link href="2019/07/23/simple-classification/"/>
      <url>2019/07/23/simple-classification/</url>
      
        <content type="html"><![CDATA[<h1 id="二分类与多分类问题"><a href="#二分类与多分类问题" class="headerlink" title="二分类与多分类问题"></a>二分类与多分类问题</h1><p>分类是一种朴素而又深刻的思想，要是人工智能成为现实，解决分类问题是必须的。分类可以更好的挖掘数据中的信息，也便于对数据的捆绑加工。分类可以降低世界的复杂度，将世界中复杂的关系简化为类与类之间的联系，从而有可能通过机器来认知刻画这个世界。</p><a id="more"></a><h2 id="线性判别分析"><a href="#线性判别分析" class="headerlink" title="线性判别分析"></a>线性判别分析</h2><p>线性判别分析（Linear Discriminant Analysis）是一种经典的线性学习方法，用于解决二分类问题。LDA的基本思想是将样例投影到一条直线上，并使同类样例的投影点尽可能接近，使异类样例的投影点尽可能远离。在对新的样本进行分类时根据其投影点在直线上的位置进行分类。如下图为一个二维示例：</p><p><img src="C:\Users\朱明\AppData\Roaming\Typora\typora-user-images\1563978748868.png" alt="1563978748868"></p><h4 id="LDA模型详析"><a href="#LDA模型详析" class="headerlink" title="LDA模型详析"></a>LDA模型详析</h4><p>当给定数据集$D=\{(x_{i},y_{i})\}_{i=1}^{m},\ y_{i}\in\{0,1\}$，令$X_{i}、\mu_{_{i}}、\sum_{i}$分别表示第i$\in\{0,1\}$类样例的集合、均值向量、协方差矩阵。若将数据点投影到直线上，两类样例的中心分别在$w^{T}\mu_{0}和w^{T}\mu_{1}$，两类样本的协方差分别为$w^{T}\sum_{0}w和w^{T}\sum_{1}w$，由于直线是一维的，因此$w^{T}\mu_{0}、w^{T}\mu_{1}、w^{T}\sum_{0}w\ 和 \ w^{T}\sum_{1}w$</p><p>均为实数。</p><p>想要使同类样例尽可能接近，可以让同类样例投影点的协方差尽可能小，即$w^{T}\sum_{0}w-w^{T}\sum_{1}w$尽可能小；想要使异类投影点之间的距离尽可能大，则要让$||w^{T}\mu_{0}+w^{T}\mu_{1}||_{2}^{2}$尽可能大，同时考虑上述两个因素，我们可以得到我们要最大化的目标：</p><script type="math/tex; mode=display">J=\frac{||w^{T}\mu_{0}-w^{T}\mu_{1}||_{2}^{2}}{w^{T}\sum_{0}w+w^{T}\sum_{1}w}\\=\frac{w^{T}(\mu_{0}-\mu_{1})(\mu_{0}-\mu_{1})^{T}w}{w^{T}(\sum_{0}+\sum_{1})w}</script><p>定义”类内散度矩阵”（within-class scatter matrix）</p><script type="math/tex; mode=display">S_{w}=\sum_{0}+\sum_{1}\\=\sum_{x\in X_{0}}(x-\mu_{0})(x-\mu_{0})^{T}+\sum_{x\in X_{1}}(x-\mu_{1})(x-\mu_{1})^{T}</script><p>同样的，定义类间散度矩阵（between-class scatter matrix）</p><script type="math/tex; mode=display">S_{b}=(\mu_{0}-\mu_{1})(\mu_{0}-\mu_{1})^{T}</script><p>则式（1）可以重写为</p><script type="math/tex; mode=display">J=\frac{w^{T}S_{b}w}{w^{T}S_{w}w}</script><p>这就是LDA的最大化目标，即$S_{b}与S_{w}$的广义瑞利商（generalized Rayleigh quotient)。</p><p>式（4）等价于</p><script type="math/tex; mode=display">\underset{w}min\ -w^{T}S_{b}w\\s.t.\ w^{T}S_{w}w=1</script><p>由拉格朗日乘子法可得</p><script type="math/tex; mode=display">-w^{T}S_{b}w+\lambda w^{T}S_{w}w=0 \quad 求导\Rightarrow\\S_{b}w=\lambda S_{w}w</script><p>  通过观察我们可以发现$S_{b}w$的方向恒为$\mu_{0}-\mu_{1}$，因为</p><script type="math/tex; mode=display">S_{b}w=(\mu_{0}-\mu_{1})\underset{这是一个数}{\underline{(\mu_{0}-\mu_{1})^{T}w}}\\不妨令\\S_{b}w=\lambda (\mu_{0}-\mu_{1})\\则由（6）可得\\w=\frac{1}{\lambda}S_{w}^{-1}S_{b}w=S_{w}^{-1}(\mu_{0}-\mu_{1})</script><p> 考虑到数值解的稳定性，在实践中通常对$S_{w}$进行奇异值分解，即$S_{w}=U\sum V^{T}$，其中$\sum$是一个实对角矩阵它的对角线上的元素是$S_{w}$的奇异值，由此可以得到</p><script type="math/tex; mode=display">S_{w}^{-1}=V{\sum}^{-1}U^{T}</script><h4 id="LDA的多分类形式"><a href="#LDA的多分类形式" class="headerlink" title="LDA的多分类形式"></a>LDA的多分类形式</h4><p>现在假设存在N个类，且第i类样例数为$m_{i}$。现在我们来定义全局散度矩阵</p><script type="math/tex; mode=display">S_{t}=S_{b}+S_{w}\\=\sum_{i=1}^{m}(x_{i}-\mu)(x_{i}-\mu)^{T}</script><p>其中$\mu$是所有样例的均值向量。我们将类内散度矩阵$S_{w}$重新定义为每个类别的散度矩阵之和，即</p><script type="math/tex; mode=display">S_{w}=\sum_{i=1}^{N}S_{w_{i}}\\其中\\S_{w_{i}}=\sum_{x\in X_{i}}(x-\mu_{i})(x-\mu_{i})^{T}</script><p>由式（9）和（10）可得</p><script type="math/tex; mode=display">S_{b}=S_{t}-S_{w}\\=\sum_{i=1}^{N}m_{i}(\mu_{i}-\mu)(\mu_{i}-\mu)^{T}</script><p>多分类LDA采用优化目标如下：</p><script type="math/tex; mode=display">\frac{tr(W^{T}S_{b}W)}{tr(W^{T}S_{W}W)}</script><p>其中$W\in R^{d*(N-1)}$，tr(.)表示矩阵的迹，式（12）可以通过如下广义特征值方程求解，得</p><script type="math/tex; mode=display">S_bW=\lambda S_{W}W</script><p>若将W视为一个投影矩阵，则多分类LDA将样本投影到N-1维空间，N-1通常远小于数据原有的属性数。因此通过这个投影可以减少样本点的维数，可以起到降维的作用。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Changed Linear Regression</title>
      <link href="2019/07/20/changed-linear-regression/"/>
      <url>2019/07/20/changed-linear-regression/</url>
      
        <content type="html"><![CDATA[<h1 id="线性回归的变形"><a href="#线性回归的变形" class="headerlink" title="线性回归的变形"></a>线性回归的变形</h1><p>顾名思义，线性回归只能处理线性关系的情况，这样难免有很大的局限性，所以我们通常对线性回归模型进行改造来获得拟合曲线的能力。</p><a id="more"></a><h2 id="对数线性回归"><a href="#对数线性回归" class="headerlink" title="对数线性回归"></a>对数线性回归</h2><p>当点集所表现出了的趋势大致为对数函数时，显然线性回归会有很大的偏差，此时在原有的基础上对y取对数即可转化为x到ln y的线性回归。我们得到下面的模型：</p><script type="math/tex; mode=display">ln y=w^{T}\overrightarrow x+b</script><p>在式中对数函数起到了将线性关系映射到曲线关系的作用，因此对于不同的映射函数，我们可以得到许多的非线性模型，即</p><script type="math/tex; mode=display">y=g^{-1}(w^{T}\overrightarrow x+b)</script><p>这些非线性模型的核心还是线性回归，因此这些非线性回归都是广义上的线性回归，是它的一种变形。</p><h2 id="对数几率回归"><a href="#对数几率回归" class="headerlink" title="对数几率回归"></a>对数几率回归</h2><p>如果我们想用线性回归来解决二分类问题，我们可以使用单位阶跃函数把y映射到（0,1），单位阶跃函数形式如下</p><script type="math/tex; mode=display">y'=\left\{\begin{array}\0,\quad y<0\\0.5,\quad y=0\\1,\quad y>0\end{array}\right.</script><p>当单位阶跃函数作用于y后，若y大于零则为正例，小于零则为反例，y为临界值则可任意判别。但是由单位阶跃函数的表达式我们可以知道它是不连续的。实际中，不连续的函数存在应用困难，我们希望能找到可以近似代替单位阶跃函数的连续函数，对数几率函数就是我们要找的函数：</p><script type="math/tex; mode=display">y'=\frac{1}{1+e^{-y}}=\frac{1}{1+e^{-(w^{T}x+b)}}\Rightarrow\\ln{\frac{y}{1-y}}=w^{T}x+b</script><p> 如果y表示x是正例的可能性，那么1-y就是其为反例的可能性，两者都比值$\frac{y}{1-y}$称为几率，反应x为正例的相对可能性，对几率取对数则得到对数几率$ln{\frac{y}{1-y}}$。</p><p>由此可以看出式（4）是在用线性回归的模型来预测对数几率</p><h4 id="对数几率回归参数的求解"><a href="#对数几率回归参数的求解" class="headerlink" title="对数几率回归参数的求解"></a>对数几率回归参数的求解</h4><p>要确定对数几率回归模型，就必须求解参数w和b，若将式（4）中的y’视为类后验概率估计p(y’=1|x)，则式（4）可重写为</p><script type="math/tex; mode=display">ln\frac{p(y'=1|x)}{p(y'=0|x)}=w^{T}x+b</script><p>显然有</p><script type="math/tex; mode=display">p(y'=1|x)=\frac{e^{w^{T}x+b}}{1+e^{w^{T}x+b}}\\p(y'=0|x)=\frac{1}{1+e^{w^{T}x+b}}</script><p>于是，我们可通过”极大似然法”来估计w和b。对给定的数集${(x_{i},y_{i})}_{i=1}^{m}$，对数概率回归模型最大”对数似然”为</p><script type="math/tex; mode=display">l(w,b)=\sum_{i=1}^{m}lnp(y_{i}|x_{i};w,b)</script><p>即令每个样本属于其真实标记的概率越大越好。为方便讨论</p><script type="math/tex; mode=display">令\beta=(w;b),\hat x=(x;1),则w^{T}x+b可简写为\beta^{T}\hat x\\再令p_{1}(\hat x;\beta)=p(y=1|\hat x;\beta)，p_{0}(\hat x;\beta)=p(y=0|\hat x;\beta)=1-p_{1}(\hat x;\beta)</script><p>则式（7）可重写为</p><script type="math/tex; mode=display">p(y_{i}|x_{i};w,b)=y_{i}p_{1}(\hat x;\beta)+(1-y_{i})p_{0}(\hat x;\beta)</script><p>把式（9）代入（6）可得最大化式（7）等于最小化下式</p><script type="math/tex; mode=display">l(\beta)=\sum_{i=1}^{m}(-y_{i}\beta^{T}\hat x+ln(1+e^{\beta^{T}\hat x}))</script><p>式（10）是关于$\beta$的告诫可导连续函数，根据凸优化理论，经典的数值优化算法如梯度下降法、牛顿法等都可以求得其最优解如下</p><script type="math/tex; mode=display">\beta^{*}=argmin\quad{l(\beta)}</script><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linear Regression</title>
      <link href="2019/07/19/linear-regression/"/>
      <url>2019/07/19/linear-regression/</url>
      
        <content type="html"><![CDATA[<h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><p>线性回归是机器学习中最基本但也十分重要的一个概念，线性回归可以解决简单的最优解和二分类问题，并且有些复杂的学习模型是在线性回归的基础上延伸出来的。</p><a id="more"></a><h2 id="什么是线性回归"><a href="#什么是线性回归" class="headerlink" title="什么是线性回归"></a>什么是线性回归</h2><p>在实验中，我们希望找到某个量与其他量之间的关系，在很多情况下这种函数关系是线性的。一般的，把实验所得到的数据点绘制在坐标图中，如果这些点大致在一条直线上，那么我们可以假设我们所要求的函数关系是线性的。</p><p>假设我们要找n个自变量(x1,x2,…，xn)和因变量y之间的线性关系，即$y=a_{1}x_{1}+a_{2}x_{2}+\dots+a_{n}x_{n}+b$，在这个函数中有n+1个未知量，因此我们需要n+1组数据来求解这n+1个未知量。但是实际中我们得到的数据是不精确的并且往往多于n+1组数据，由线性代数我们可以知道超定方程是无解的。这种情况下如果我们选取其中的n+1组数据来求解未知数将产生很大的误差，而且我们希望充分的利用得到的数据。当我们把这些数据点绘制在坐标纸上，我们会发现我们面临的问题是找到一条直线尽可能地表现这些点所显示的趋势。确定这样一条直线的过程就叫做线性回归。</p><h4 id="线性回归的公式"><a href="#线性回归的公式" class="headerlink" title="线性回归的公式"></a>线性回归的公式</h4><p>为了精确的描述，我们用均方差来刻画直线的接近程度，均方差越小，所对应的直线越接近这些点所想表达的趋势。当函数是一元函数f(x)=wx+b时，均方误差（MSE）的计算式如下：</p><script type="math/tex; mode=display">MSE=E_{(w,b)}=\sum_{i=1}^{m}(f(x_{i})-y_{i})^{2}</script><p>当均方误差最小的时候所确定的函数关系就是我们要求的最接近数据点所展现的趋势，在这种情况下有下列关系式成立</p><script type="math/tex; mode=display">\frac{\partial E_{(w,b)}}{\partial w}=2(w\sum_{i=1}^{m}x_{i}^{2}-\sum_{i=1}^{m}(y_{i}-b)x_{i})=0\\\quad\\\frac{\partial E_{(w,b)}}{\partial b}=2(mb-\sum_{i=1}^{m}(y_{i}-wx_{i}))=0\\整理后我们可以得到方程组：\\\left\{\begin{array}\w\sum_{i=1}^{m}x_{i}^{2}-\sum_{i=1}^{m}x_{i}{y_{i}}+b\sum_{i=1}^{m}x_{i}=0\\mb-\sum_{i=1}^{m}y_{i}+w\sum_{i=1}^{m}x_{i}=0\\解得\\w=\frac{\sum_{i=1}^{m}y_{i}(x_{i}-\overline x)}{\sum_{i=1}^{m}x_{i}^{2}-\frac{1}{m}(\sum_{i=1}^{m}x_{i})^{2}}\\b=\frac{1}{m}\sum_{i=1}^{m}(y_{i}-wx_{i})\end{array}\right.</script><p>更一般的，当函数为多元线性函数$f(x)=w_{1}x_{1}+w_{2}x_{2}+\dots+w_{m}x_{m}+b$时，函数关系为</p><script type="math/tex; mode=display">f(x)=w^{T}x+b</script><p>为方便讨论，我们把数据集D记为</p><script type="math/tex; mode=display">D=\begin{pmatrix}x_{11}&x_{12}&\dots&x_{1n}&1\\x_{21}&x_{22}&\dots&x_{2n}&1\\\vdots&\vdots&\ddots&\vdots&\vdots\\x_{n1}&x_{n2}&\dots&x_{mn}&1\end{pmatrix}=\begin{pmatrix}x_{1}^{T}&1\\x_{2}^{T}&1\\\vdots&\vdots\\x_{m}^{T}&1\\\end{pmatrix}</script><p>把$\hat w$向量记为</p><script type="math/tex; mode=display">\hat w=\begin{pmatrix}w\\b\end{pmatrix}</script><p>把y记为$(y_{1},y_{2},\dots,y_{m})^{T}$，则类似于一元函数有</p><script type="math/tex; mode=display">MSE=E_{(\hat w)}=(y-D\hat w)^{T}(y-D\hat w)\\对其求导可得\\\frac{\partial E_{\hat w}}{\partial\hat w}=2D^{T}(D\hat w-y)=0</script><p>下面进行分类讨论：</p><ol><li><p>当$D^{T}D$为满秩矩阵或正定矩阵时，可得</p><script type="math/tex; mode=display">\hat w=(D^{T}D)^{-1}D^{T}y</script></li><li><p>当$D^{T}D$为非满秩矩阵时（实际中经常参数的数量多于数据量，此时$D^{T}D$一定是非满秩），我们会解得多个$\hat w$，它们都能使均方误差最小化，这时选择哪个解作为输出取决于算法的偏好。</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Important Concepts for Html</title>
      <link href="2019/07/18/important-concepts-for-html/"/>
      <url>2019/07/18/important-concepts-for-html/</url>
      
        <content type="html"><![CDATA[<h1 id="盒子模型与定位技术"><a href="#盒子模型与定位技术" class="headerlink" title="盒子模型与定位技术"></a>盒子模型与定位技术</h1><p>盒子模型是HTML语言中一个重要的概念，如果说编程语言中一切皆对象，那么HTML中则是一切皆盒子。定位技术在HTML中也是非常重要的，虽然通过盒子模型可以解决所有的定位问题，但是这样的方法只适合于简单的网页。当网页结构异常复杂时，使用这种定位方法需要计算大量的参数，是不可行的。因此我们需要使用框架封装好的定位技术。</p><a id="more"></a><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>所谓的盒子模型即HTML中的每个元素都有position、margin、border、padding这四个属性，在谷歌浏览器中我们可以看到盒子模型的直观图，如下</p><p><img src="http://src.zhumingcj.cn/blog/20190718/Rs9A4BX1mWnK.png?imageslim" alt="mark"></p><ul><li>position——元素的位置</li><li>margin——元素的外边距</li><li>border——元素的边框（轮廓）</li><li>padding——元素的内边距</li><li>content——元素实际包含的信息（盒子最里面）</li></ul><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ol><li>margin部分不算入盒子的大小，只是用来与其他元素隔开一定距离；在默认情况下HTML的body自带有margin为8px。</li><li>padding用来使内容和border隔出一定距离，可用来调整文本的格式</li></ol><h4 id="盒子模型的简单应用"><a href="#盒子模型的简单应用" class="headerlink" title="盒子模型的简单应用"></a>盒子模型的简单应用</h4><ol><li><p>margin和padding可以用来定位</p><p>被包裹的盒子相对于包裹它的盒子的坐标定位即为margin-top和margin-left的值。如想要把一个body标签中的div标签定位到（100px,100px）的位置，只需要把div的这两个属性都设为100px即可；同理可知padding也可以实现定位</p></li><li><p>padding可用于限定盒子中文本的行数</p><p>如果不就行恰当的设置，很有可能出现文本展示不全的情况出现，会极大地影响用户体验。当我们想限定容器中显示N行文本时，我们只需要让盒子高度扣除padding后是字体行高的N倍即可；特别的，当N等于1时所展现的效果就是垂直居中</p></li></ol><h2 id="定位技术"><a href="#定位技术" class="headerlink" title="定位技术"></a>定位技术</h2><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>在网页制作排版中，需要准确的定位元素，使用盒子模型进行定位一方面十分繁琐复杂另一方面无法层次化，即元素之间无法交叉（实际中我们有这种需要）。</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>在css中通过设置position的值来选择定位方式，通过top、left等设置坐标。其中position有三个参数可选——absolute、relative、fixed。设置position后元素变为层级元素，即每个元素处于不同层级，可以层叠。</p><h4 id="三种定位方式详解"><a href="#三种定位方式详解" class="headerlink" title="三种定位方式详解"></a>三种定位方式详解</h4><ol><li><p>absolute模式</p><ul><li><p>绝对定位（脱离原来位置进行定位），对于两个块级元素来说在没有设置absolute定位时，前一个元素会把后一个元素挤开，当设置absolute定位后，后一个元素会脱离原来位置定位到默认（0，0）的位置与前一个元素发生层叠。</p></li><li><p>absolute定位会选取最近的可定位元素作为定位的参照。在复杂的父子结构中，例如下图</p><p><img src="http://src.zhumingcj.cn/blog/20190719/Lincjzi6GGBd.png?imageslim" alt="mark"></p></li></ul></li></ol><pre><code> 我们想对content进行定位，如果两个父级元素都没有设置定位，则会根据父级body进行定位；如果box设置了定位，content就会以box为参照进行定位。</code></pre><ol><li><p>relative模式</p><ul><li>相对定位（保留原来位置（出生的位置）进行定位），同样两个块级元素，如果后一个元素设置了相对定位，则元素会变成层级元素但是保留原来的位置。</li><li>由于relative保留原来位置的特性，它常被用来当做定位的参照——我们把定位元素设置成absolute，把参照物设成relative，这样既不会影响其他的元素，又可以进行定位。若将参照物设成absolute则其后面的元素可能会脱离原来的位置，这是我们不希望看到的。</li></ul></li><li><p>fixed模式</p><p>固定定位（不管页面怎么变化，始终固定在一个位置）。这种定位方式也是十分常见的，基本上所有的广告、目录等都是fixed定位的。</p></li></ol><h2 id="盒子模型中的bug"><a href="#盒子模型中的bug" class="headerlink" title="盒子模型中的bug"></a>盒子模型中的bug</h2><ol><li><p>margin塌陷</p><p>现象：在父子结构中，子元素设置margin-top时出现异常——当设置的margin-top小于父元素的margin-top 时无法发挥作用，大于父元素时子元素会带动父元素，即父子元素的margin-top联动。此bug相当于父元素上方的border没有了，故此得名。</p><p>解决方法：</p><ol><li><p>暴力法</p><p>手动在父元素上加一个border-top即可，但是此方法会破坏原有HTML的结构，因此不可取。</p></li><li><p>通过bfc（block format context）来解决。一般每个元素（盒子）都有一样的渲染规则，但是通过触发bfc可以改变盒子的渲染规则从而解决margin塌陷的问题。</p><p>触发bfc的三种方法：</p><ul><li>position：absolute/relative/fixed；</li><li>display：inline-block；</li><li>float：left/right;</li><li>overflow：hidden;</li></ul><p>通过bfc的方法解决margin塌陷问题也只能起到缓解作用，因为四种触发bfc的方法都会引起新的问题，比如设置position可能会对定位产生影响，所以我们可以选择一种不影响原有结构的方法来解决margin塌陷问题。</p></li></ol></li><li><p>margin合并</p><p>现象：在并列结构中，A元素和B元素分别设置margin-bottom和margin-top时不会正常的叠加而会取二者的最大值最为两者的间距，就像是两者何用了一个margin。</p><p>解决方法：margin合并也可以通过触发bfc来解决。但是在实际中我们也可以选择不解决margin合并问题，因为我们只要对其中一个元素设置和间距等同的margin即可。</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rotation、Grad and Divergence</title>
      <link href="2019/07/09/rotation%E3%80%81grad-and-divergence/"/>
      <url>2019/07/09/rotation%E3%80%81grad-and-divergence/</url>
      
        <content type="html"><![CDATA[<h1 id="梯度、散度、旋度"><a href="#梯度、散度、旋度" class="headerlink" title="梯度、散度、旋度"></a>梯度、散度、旋度</h1><p>梯度、散度、旋度是研究向量场的几个重要的量，它们表征着向量场的性质，在理论研究中有着重要的地位。梯度表示标量函数增加或减少的方向；散度表示向量场远离源的程度；旋度则表示向量场围绕某个中心旋转的程度。</p><a id="more"></a><h2 id="梯度、散度、旋度的计算公式"><a href="#梯度、散度、旋度的计算公式" class="headerlink" title="梯度、散度、旋度的计算公式"></a>梯度、散度、旋度的计算公式</h2><script type="math/tex; mode=display">\nabla A=(\frac{\partial A}{\partial x},\frac{\partial A}{\partial y},\frac{\partial A}{\partial z})\\\nabla\bullet A=(\frac{\partial A_{x}}{\partial x}+\frac{\partial A_{y}}{\partial y}+\frac{\partial A_{z}}{\partial z})\\\nabla \times A=(\frac{\partial A_{y}}{\partial z}-\frac{\partial A_{z}}{\partial y},\frac{\partial A_{z}}{\partial x}-\frac{\partial A_{x}}{\partial z},\frac{\partial A_{x}}{\partial y}-\frac{\partial A_{y}}{\partial x})</script><h2 id="梯度、散度、旋度的嵌套运算"><a href="#梯度、散度、旋度的嵌套运算" class="headerlink" title="梯度、散度、旋度的嵌套运算"></a>梯度、散度、旋度的嵌套运算</h2><ol><li><p>证明旋度的散度=0（$\nabla\bullet (\nabla\times A)=0$）</p><script type="math/tex; mode=display">\begin{align}\nabla\bullet (\nabla\times A)=\nabla\bullet(\frac{\partial A_{y}}{\partial z}-\frac{\partial A_{z}}{\partial y},\frac{\partial A_{z}}{\partial x}-\frac{\partial A_{x}}{\partial z},\frac{\partial A_{x}}{\partial y}-\frac{\partial A_{y}}{\partial x})\\=\frac{\partial^{2} A_{y}}{\partial z \partial x}-\frac{\partial^{2} A_{z}}{\partial y \partial x}+\frac{\partial^{2} A_{z}}{\partial x \partial y}-\frac{\partial^{2} A_{x}}{\partial z \partial y}+\frac{\partial^{2} A_{}x}{\partial y \partial z}-\frac{\partial^{2} A_{y}}{\partial x \partial z}\\=0\end{align}</script></li><li><p>旋度的梯度（$\nabla (\nabla\times A)$）</p><script type="math/tex; mode=display">\nabla (\nabla\times A)=\nabla(\frac{\partial A_{y}}{\partial z}-\frac{\partial A_{z}}{\partial y},\frac{\partial A_{z}}{\partial x}-\frac{\partial A_{x}}{\partial z},\frac{\partial A_{x}}{\partial y}-\frac{\partial A_{y}}{\partial x})\\=(\frac{\partial^{2} A_{y}}{\partial z \partial x}-\frac{\partial^{2} A_{z}}{\partial y \partial x},\frac{\partial^{2} A_{z}}{\partial x \partial y}-\frac{\partial^{2} A_{x}}{\partial z \partial y},\frac{\partial^{2} A_{}x}{\partial y \partial z}-\frac{\partial^{2} A_{y}}{\partial x \partial z})\\</script></li><li><p>旋度的旋度（$\nabla\times (\nabla\times A)$）</p><script type="math/tex; mode=display">\nabla\times (\nabla\times A)=\nabla\times(\frac{\partial A_{y}}{\partial z}-\frac{\partial A_{z}}{\partial y},\frac{\partial A_{z}}{\partial x}-\frac{\partial A_{x}}{\partial z},\frac{\partial A_{x}}{\partial y}-\frac{\partial A_{y}}{\partial x})\\=(\frac{\partial^{2} A_{z}}{\partial x \partial z}-\frac{\partial^{2} A_{x}}{\partial z^{2}}-\frac{\partial^{2} A_{x}}{\partial y^{2}}+\frac{\partial^{2} A_{y}}{\partial x \partial y},\frac{\partial^{2} A_{x}}{\partial y \partial z}-\frac{\partial^{2} A_{y}}{\partial x^{2}}-\frac{\partial^{2} A_{y}}{\partial z^{2}}+\frac{\partial^{2} A_{z}}{\partial z \partial x},\frac{\partial^{2} A_{y}}{\partial z \partial y}-\frac{\partial^{2} A_{z}}{\partial y^{2}}-\frac{\partial^{2} A_{z}}{\partial x^{2}}+\frac{\partial^{2} A_{x}}{\partial z \partial x})</script></li><li><p>梯度的旋度=$\overrightarrow{0}$（$\nabla\times(\nabla A)=0$）</p><script type="math/tex; mode=display">\nabla\times(\nabla A)=\nabla\times(\frac{\partial A}{\partial x},\frac{\partial A}{\partial y},\frac{\partial A}{\partial z})\\=(\frac{\partial^{2}A}{\partial y \partial x}-\frac{\partial^{2}A}{\partial x \partial y},\frac{\partial^{2}A}{\partial x \partial z}-\frac{\partial^{2}A}{\partial z \partial x},\frac{\partial^{2}A}{\partial x \partial y}-\frac{\partial^{2}A}{\partial y \partial x})\\=(0,0,0)梯度的梯度（略）</script></li><li><p>梯度的梯度（略）</p></li><li><p>梯度的散度（$\nabla\times(\nabla A)$）</p><script type="math/tex; mode=display">\nabla\times(\nabla A)=\frac{\partial^{2}A}{\partial x^{2}}+\frac{\partial^{2}A}{\partial y^{2}}+\frac{\partial^{2}A}{\partial z^{2}}</script></li><li><p>散度的梯度（$\nabla(\nabla\bullet A)$）</p><script type="math/tex; mode=display">\nabla(\nabla\bullet A)=\nabla(\frac{\partial A_{x}}{\partial x}+\frac{\partial A_{y}}{\partial y}+\frac{\partial A_{z}}{\partial z})</script></li></ol><h2 id="有关场："><a href="#有关场：" class="headerlink" title="有关场："></a>有关场：</h2><ol><li>若一个向量场的散度=0，则这个场是无源场；若一个向量场的旋度=0，则这个向量场是无旋场又称保守场。</li></ol><ol><li>一个旋度场的散度=0，可知旋度场是一个无源场；一个梯度场的旋度=0，可知梯度场是一个无旋场(保守场)。综上可知，仅通过散度无法确定一个向量场，因为一个旋度场叠加上一个有源场不改变这个场的散度；同样仅通过旋度也无法确定一个向量场，因为一个有旋场叠加上一个梯度场不改变其旋度。</li></ol><ol><li>散度具有指向的意义，对于匀强的向量场，散度等于零意味着向量场的方向是一致的。</li></ol><ol><li>散度的梯度用于表示源的分布情况。在实际中物质的扩散可以用散度的梯度来刻画，表示物质扩散最快的方向。（即通量密度最大的地方）。</li></ol><ol><li>旋度的分量具有实际意义，对于旋度的x分量表示yoz平面的旋转程度，其它分量也是如此。</li></ol><p>   <img src="http://src.zhumingcj.cn/blog/20190710/p61VjF1hKDeH.png?imageslim" alt="mark"></p><p>   ​    如图1为向量场$A=-x^{2}\overrightarrow{j}$,若把一块小薄板放在图的右侧，则薄板会顺时针偏转；若放在左边则逆时针偏    转。根据右手定则，右边的旋度为z轴负向；左边的旋度为z轴正向。可以想象旋转程度与x变化一个微小的    量时A的变化程度的极限有关。因为A无x的分量所以，所以旋转程度取决于y分量的变化率，即                                                                           $(\nabla\times A)_{z}=\frac{\partial A_{y}}{\partial x}$</p><p>   <img src="http://src.zhumingcj.cn/blog/20190710/OxW34dN8NETS.png?imageslim" alt="mark"></p><p>   ​        如图2所示的向量场可分解$A_{x}$为和$A_{y}$两部分，每一部分分量型如图1。此时$(\nabla\times A)_{z}=\frac{\partial A_{y}}{\partial x}-\frac{\partial A_{x}}{\partial y}$，从推导        可知$\nabla\times A$的x、y、z分量分别表示yoz平面、xoz平面以及xoy平面的旋转程度。</p><ol><li><p>亥姆霍兹定理</p><p>若矢量场在无限空间中处处单值，且其导数连续有界，而源分布在有限空间内，则矢量场由其旋度、散度和边界条件唯一确定；且可表示为一个标量场的梯度和一个矢量场的旋度之和。</p><script type="math/tex; mode=display">\overrightarrow{F}=-\nabla\varphi+\nabla\times\overrightarrow{A}</script><p>换言之，矢量场可以有一个有源场和一个有旋场以及边值条件唯一确定。其中标量场的梯度为无旋场（有源场），向量场的旋度为有旋场（无源场）。</p></li></ol><ol><li><p>有关旋度的旋度的恒等式</p><p><img src="http://src.zhumingcj.cn/blog/20190710/WEacukbenVci.png?imageslim" alt="mark"></p><p><img src="http://src.zhumingcj.cn/blog/20190710/MVW0sPAjAKDW.png?imageslim" alt="mark"></p><p><img src="http://src.zhumingcj.cn/blog/20190710/iA6oC7wgULbc.png?imageslim" alt="mark"></p></li><li><p>电磁场理论</p><p><img src="http://src.zhumingcj.cn/blog/20190710/UWll8sT8J6z0.png?imageslim" alt="mark"></p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 梯度、旋度和散度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP Algorithm</title>
      <link href="2019/07/09/kmp-algorithm/"/>
      <url>2019/07/09/kmp-algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h1><p>KMP算法是子串搜索算法中最有效、最有名的一个算法，它有效地减少了匹配子串时的比较次数，降低了时间复杂度，其中蕴含算法的思想更是值得学习的。</p><a id="more"></a><h1 id="暴力子串搜索算法"><a href="#暴力子串搜索算法" class="headerlink" title="暴力子串搜索算法"></a>暴力子串搜索算法</h1><p>步入正题之前，让我们先来看看最简单的子串搜索算法，分析其问题的所在。</p><p>暴力子串搜索就是采用双循环，先比较主串和模式串的第一位，再比较第二位，以此类推，直至比较结果不匹配，则主串前移，继续重复上述过程，；若直至模式串末位都匹配，则找到目标。</p><p>程序组织如下</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static int Search(string main_str, string pattern_str)</span><br><span class="line">           {</span><br><span class="line">               int m = main_str.Length;</span><br><span class="line">               int n = pattern_str.Length;</span><br><span class="line">               int target = -1;</span><br><span class="line">               for (int i = 0; i &lt; m-n; i++)</span><br><span class="line">               {</span><br><span class="line">                   for (int j = 0; j &lt; n; j++)</span><br><span class="line">                   {</span><br><span class="line">                       if (main_str[i+j]!=pattern_str[j])</span><br><span class="line">                       {</span><br><span class="line">                           break;</span><br><span class="line">                       }</span><br><span class="line">                       if (j == n - 1)</span><br><span class="line">                       {</span><br><span class="line">                           target = i;</span><br><span class="line">                       }</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line">               return target;</span><br><span class="line"></span><br><span class="line">           }</span><br></pre></td></tr></tbody></table></figure><h4 id="暴力子串搜索算法的分析"><a href="#暴力子串搜索算法的分析" class="headerlink" title="暴力子串搜索算法的分析"></a>暴力子串搜索算法的分析</h4><p>可以看到，以这种方式进行搜索，在最坏的情况下要进行n(m-n)次运算，所以它的时间复杂度为O(n(m-n))，当数据量很大的时候，此种算法的效率很低。</p><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>在前面我们看到暴力法搜索会耗费很多的时间，那么该如何改进呢？如果要减少运算次数，那么必须减少循环的次数，也就是不能一个一个的比较，我们希望第二次搜索可以在第一次的基础上，从最优的位置继续开始循环。也就是说，我们要充分利用前一次搜索失败的信息。下面我们来具体分析如何利用上一次搜索的信息：</p><h4 id="KMP算法的关键——next-函数"><a href="#KMP算法的关键——next-函数" class="headerlink" title="KMP算法的关键——next()函数"></a>KMP算法的关键——next()函数</h4><h5 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h5><p><img src="http://src.zhumingcj.cn/blog/20190711/3eDxaJzhJQot.png?imageslim" alt="mark"></p><p>如图，在每次不匹配时，我们可以利用前面的信息来移动模式串（实际上我们可以知道匹配开始点到不匹配点之间主串的字符），图中第一次匹配在第五个位置匹配失败，则我们可以知道主串前四位是abda，那么我们可以知道模式串向右移动1、2位都是不匹配的，因此应该移动3位，即移动到第二个a的位置。由此我们可以猜测每次匹配失败时，模式串向右移动的最佳长度和模式串自身的结构和失败的位置有关，即是关于模式串序号的一个函数。我们把这个函数记为next（i），下面是一个示例。</p><p><img src="http://src.zhumingcj.cn/blog/20190711/NfFl258kJU2a.png?imageslim" alt="mark"></p><p><strong>通过上面的示例以及分析我们可以知道，如果记模式串匹配失败前的内容为P(i),则我们希望找一个k使得P(i)的前k项和后k项是一样的，并且这个k是满足上面的条件中最大的那个，也就是说我们想找到一个P(i)的前缀，它也是模式串的后缀，并且长度是最大的，这个长度就是k。</strong></p><h5 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h5><p>上面我们得到了next（i）的求解方法，下面我们来分析一下为什么是这样的。</p><p><img src="http://src.zhumingcj.cn/blog/20190711/sp4KcQMFXAth.png?imageslim" alt="mark"></p><p>假设这是一次匹配，它将在序号为9的地方匹配失败，那么下一次匹配的时候我们应该将模式串移动到什么位置呢？显然模式串的开头是a，那么模式串一定得移到主串中a的位置（3,4,6）。如果模式串移动到3的位置，那么如下图</p><p><img src="http://src.zhumingcj.cn/blog/20190711/lUrrehoLvVUh.png?imageslim" alt="mark"></p><p>我们可以看到这种情况是不匹配的，因为从上一次的匹配中我们可以知道主串4位置是a，与b不匹配，移动到位置4的情况相同。</p><p>我们把问题抽象出来就是这样的</p><p>第一次匹配后，我们所知道的主串是这样的</p><p><img src="http://src.zhumingcj.cn/blog/20190711/SaHLEegNBynb.png?imageslim" alt="mark"></p><p>而模式串是这样的</p><p><img src="http://src.zhumingcj.cn/blog/20190711/6UpkPhhK9W6q.png?imageslim" alt="mark"></p><p>现在需要移动模式串进行第二次匹配，由于这种情况不好看清本质问题，所以我们假设第一次匹配后情况如下</p><p><img src="http://src.zhumingcj.cn/blog/20190711/Nui2Ht4Fp9wi.png?imageslim" alt="mark"></p><p><img src="http://src.zhumingcj.cn/blog/20190711/cVvBoHewd6cA.png?imageslim" alt="mark"></p><p>图中，匹配失败处i=11，并且P(i)实际上就是主串已知的内容。由上面的讨论，我们可以知道模式串移动到3,5的位置是不匹配的，在这里我们可以知道为什么next（i）要找P(i)最长的前缀（同时是后缀），<code>因为如果模式串移动到一个以a（模式串的第一个字符，这里是a）开头但不是后缀的地方，如5的位置（参照下图），虽然前五个abcab是匹配的，但是第六个字符主串是c而模式串是a,换言之处于中间的以a开头的位置需要确保其后的每一个字符与模式串对应位置是匹配的,直到主串序号i之前，那么满足这样条件的一定是P(i)的一个后缀（因为上述条件保证了P(i)的一个后缀与模式串的一个前缀对应相等，而模式串的前缀一定也是P(i)的前缀，所以我们找的是P(i)中既是前缀又是后缀的字符串，理论上符合这样条件的都可以作为模式串移动的依据，但是为了尽可能的充分利用已知信息，我们应该找寻最长的那个前/后缀）</code></p><p><img src="http://src.zhumingcj.cn/blog/20190711/OnPTCjtQ57n3.png?imageslim" alt="mark"></p><p>由此我们正式给出next(i)的定义</p><script type="math/tex; mode=display">def：\\next(i)=max(len(s))\quad\{s|s\sqsubset P(i),s\sqsupset P(i)\}\\注：\sqsubset表示...的前缀；\sqsupset表示...的后缀</script><h5 id="next函数计算的递推法"><a href="#next函数计算的递推法" class="headerlink" title="next函数计算的递推法"></a>next函数计算的递推法</h5><p>为了实现递推，我们把next(0)记为0，并记next(i)=$k_{i}$，那么递推关系如下：</p><ol><li><p>当P(i)=p($k_{i}$)时，$k_{i+1}$=$k_{i}+1$</p></li><li><p>当P(i)$\not=p(k_{i}$)时,</p><script type="math/tex; mode=display">f(i+1)=k_{i+1}=\left\{\begin{array}\k_{k_{i}}+1 \quad if \quad p(k_{k_{i}})=p(i)\\f(k_{k_{i}}+1)    \quad if \quad p(k_{k_{i}})\not=p(i)\end{array}\right.</script></li></ol><h5 id="递推法的详析"><a href="#递推法的详析" class="headerlink" title="递推法的详析"></a>递推法的详析</h5><p>下面先给出一个例子</p><p><img src="http://src.zhumingcj.cn/blog/20190712/aSQGCRgHsFKb.png?imageslim" alt="mark"></p><p>毫无疑问，next(1)一定为零（只有一个字符），next(2)也为零，next(3)等于1。</p><p>next(4)等于1可以这么计算：由于p(4)只比p(3)多了一个a，并且已知p(3)最长前后缀长度为1，那么只要比较p(4)的第一位（序号从零开始）与新增的那位是否相等，若相等，则next(4)=next(3)+1应该是显然的，若不等，并不能说next(4)=0，实际上next(4)也不为零。</p><p>因为新增位与最长前缀的下一位不相等，只能说明next(4)的值不可能大于或等于next(3)，但是可能是小于next(3)的某个值。那么应该如何计算next(4)的值呢？请看下图</p><p><img src="http://src.zhumingcj.cn/blog/20190712/XwownjjuOLc5.png?imageslim" alt="mark"></p><p>我们来观察next(10)的计算，p(10)新增的b与p(9)第六位的a，不同，所以next(10)&lt;6，现在我们任想找最长的前后缀，当然可以通过循环比较的方法来寻找，但是我们希望能充分利用已知的信息来简化计算。</p><p>刚才我们在已知最长前后缀abaaaba的基础上来比较下一位是否相等，结果不相等，自然而然，我们接下来应该找一个短一点的前后缀，再去比较这个短一点的前后缀的下一位是否相等，并且利用已知的条件可以很高效的找出这个短一点的前后缀，详析见下图</p><p><img src="http://src.zhumingcj.cn/blog/20190712/Wvtr5nrSrLeL.png?imageslim" alt="mark"></p><h2 id="KMP算法的组织"><a href="#KMP算法的组织" class="headerlink" title="KMP算法的组织"></a>KMP算法的组织</h2><p>与暴力求解不同，在KMP算法中，我们希望仅用一个循环来解决问题。循环变量为主串的下标，第一次匹配时，模式串下标自增，当匹配失败时，模式串的下标由next(i)函数来确定，然后继续与主串进行匹配。这样就比避免了每次匹配失败时模式串下标的回溯。</p><p>模式串的下标与next(i)的关系：下标=next(i)</p><h2 id="KMP的程序实现"><a href="#KMP的程序实现" class="headerlink" title="KMP的程序实现"></a>KMP的程序实现</h2><ol><li><p>next函数的实现，程序如下</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">   {</span><br><span class="line">       static void Main(string[] args)</span><br><span class="line">       {</span><br><span class="line">           //这是一个测试</span><br><span class="line">           int[] nextarray = Next("ababababca");</span><br><span class="line">           foreach (var item in nextarray)</span><br><span class="line">           {</span><br><span class="line">               Console.Write(item + " ");</span><br><span class="line">           }</span><br><span class="line">           Console.Read();</span><br><span class="line">       }</span><br><span class="line">   </span><br><span class="line">       public static int[] Next(string pattern_str)</span><br><span class="line">       {</span><br><span class="line">           int len = pattern_str.Length;</span><br><span class="line">           int[] next = new int[len];</span><br><span class="line">           //next数组的第0,1位一定是零</span><br><span class="line">           next[0] = 0;</span><br><span class="line">           next[1] = 0;</span><br><span class="line">           for (int i = 2; i &lt; len; i++)</span><br><span class="line">           {</span><br><span class="line">               //P(i)新增的字符与P(i-1)最长前缀的后一位匹配时的情况</span><br><span class="line">               if (pattern_str[i - 1] == pattern_str[next[i - 1]])</span><br><span class="line">               {</span><br><span class="line">                   next[i] = next[i - 1] + 1;</span><br><span class="line">               }</span><br><span class="line">               else</span><br><span class="line">               {</span><br><span class="line">                   //P(i)新增的字符与P(i-1)最长前缀的后一位不匹配时，寻找更小的前后缀，并继续比较p(i)新增字符与新的前缀的后一个字符是否相等，相等，计算next(i)；不等，继续寻找更小的前后缀。</span><br><span class="line">                   int j = next[i - 1];</span><br><span class="line">                   while (j &gt;= 0)</span><br><span class="line">                   {</span><br><span class="line">                       j = next[j];</span><br><span class="line">                       if (pattern_str[j] == pattern_str[i - 1])</span><br><span class="line">                       {</span><br><span class="line">                           next[i] = j + 1;</span><br><span class="line">                           break;</span><br><span class="line">                       }</span><br><span class="line">                       else</span><br><span class="line">                       {</span><br><span class="line">                           //若最小的前后缀都无法使其后一位与P(i)新增的字符相等，则说明P(i)不存在前后缀，next(i)=0.</span><br><span class="line">                           if (j==0)</span><br><span class="line">                           {</span><br><span class="line">                               next[i] = 0;</span><br><span class="line">                               break;</span><br><span class="line">                           }</span><br><span class="line">                       }</span><br><span class="line">   </span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">           return next;</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>运行上面的程序，我们将得到下面的结果</p><p><img src="http://src.zhumingcj.cn/blog/20190712/DrQfHOficE1Y.png?imageslim" alt="mark"></p><p>我们可以看到输出结果与前面计算的一样，为保证算法的准确性，使用字符串”abaabaababb”再次进行验证，得到如下输出</p><p><img src="http://src.zhumingcj.cn/blog/20190712/pp539EgdHPRh.png?imageslim" alt="mark"></p><p>经验证，与计算结果一致，则程序基本无误。</p></li><li><p>KMP算法的整体实现</p><p>按照前面的算法分析，程序如下</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">    {</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(KMP("abdadabdabadabdabbb", "abdabb"));</span><br><span class="line">            Console.Read();</span><br><span class="line">        }</span><br><span class="line">        public static int KMP(string main_str, string pattern_str)</span><br><span class="line">        {</span><br><span class="line">        //初始化工作，获取主串、模式串长度；计算next数组，循环变量初始化，结果初始化（无匹配的返回值）</span><br><span class="line">            int main_len = main_str.Length;</span><br><span class="line">            int pattern_len = pattern_str.Length;</span><br><span class="line">            int j = 0;</span><br><span class="line">            int target = -1;</span><br><span class="line">            int[] next = Next(pattern_str);</span><br><span class="line">            int i = 0;</span><br><span class="line">            //主循环为主串下标的自增</span><br><span class="line">            while (i &lt; main_len)</span><br><span class="line">            {</span><br><span class="line">            //判断主串字符和模式串字符是否相等</span><br><span class="line">                if (main_str[i] == pattern_str[j])</span><br><span class="line">                {</span><br><span class="line">                //若模式串下标已经达到最大，匹配成功，退出循环</span><br><span class="line">                    if (j == pattern_len - 1)</span><br><span class="line">                    {</span><br><span class="line">                    //此时的i为匹配成功末位的值，需要减去模式串的长度再加一才是匹配成功首位的位置</span><br><span class="line">                        target = i-pattern_len+1;</span><br><span class="line">                        break;</span><br><span class="line">                    }</span><br><span class="line">                    else</span><br><span class="line">                    {</span><br><span class="line">                        j++;</span><br><span class="line">                    }</span><br><span class="line">                    i++;</span><br><span class="line">                }</span><br><span class="line">                else</span><br><span class="line">                {</span><br><span class="line">                //如果j=0并且进入这个else说明模式串首位与主串i处不匹配，主串序号需要加一，否则下一次循环j还是0，会陷入循环比较</span><br><span class="line">                    if (j == 0)</span><br><span class="line">                    {</span><br><span class="line">                        i++;</span><br><span class="line">                    }</span><br><span class="line">                    //由next数组求得下一次j的值</span><br><span class="line">                    j = next[j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            return target;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">//next数组的求解</span><br><span class="line">        public static int[] Next(string pattern_str)</span><br><span class="line">        {</span><br><span class="line">            int pattern_len = pattern_str.Length;</span><br><span class="line">            int[] next = new int[pattern_len];</span><br><span class="line">            next[0] = 0;</span><br><span class="line">            next[1] = 0;</span><br><span class="line">            for (int i = 2; i &lt; pattern_len; i++)</span><br><span class="line">            {</span><br><span class="line">                if (pattern_str[i - 1] == pattern_str[next[i - 1]])</span><br><span class="line">                {</span><br><span class="line">                    next[i] = next[i - 1] + 1;</span><br><span class="line">                }</span><br><span class="line">                else</span><br><span class="line">                {</span><br><span class="line">                    int j = next[i - 1];</span><br><span class="line">                    while (j &gt;= 0)</span><br><span class="line">                    {</span><br><span class="line">                        j = next[j];</span><br><span class="line">                        if (pattern_str[j] == pattern_str[i - 1])</span><br><span class="line">                        {</span><br><span class="line">                            next[i] = j + 1;</span><br><span class="line">                            break;</span><br><span class="line">                        }</span><br><span class="line">                        else</span><br><span class="line">                        {</span><br><span class="line">                            if (j == 0)</span><br><span class="line">                            {</span><br><span class="line">                                next[i] = 0;</span><br><span class="line">                                break;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            return next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>我们用给出的第一个例子来验证这个算法，得到结果为</p><p><img src="http://src.zhumingcj.cn/blog/20190712/6oTF1AG6rcsc.png?imageslim" alt="mark"></p></li></ol><p>经过验证，匹配成功的首位确为12处，程序无误。</p><h2 id="KMP算法分析"><a href="#KMP算法分析" class="headerlink" title="KMP算法分析"></a>KMP算法分析</h2><p>从程序的实现可以看出，算法可以分为两部分：next函数计算和匹配过程。其中，next函数的计算的时间复杂度为O(m<sup><a href="#fn_1" id="reffn_1">1</a></sup>)，并且可以证明next函数计算耗费不会超过2m；而匹配的过程显然时间复杂度为O(n<sup><a href="#fn_2" id="reffn_2">2</a></sup>)，并且可以证明匹配计算耗费不会超过2n。（具体证明限于篇幅，此处仅给出结论）</p><p>综上，KMP算法的时间复杂度为O(m+n)，是线性的，远小于暴力法的O((m-n)*n)</p><blockquote id="fn_1"><sup>1</sup>. m为模式串的长度<a href="#reffn_1" title="Jump back to footnote [1] in the text."> ↩</a></blockquote><blockquote id="fn_2"><sup>2</sup>. n为主串的长度<a href="#reffn_2" title="Jump back to footnote [2] in the text."> ↩</a></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Improved Square Method</title>
      <link href="2019/07/08/improved-square-method/"/>
      <url>2019/07/08/improved-square-method/</url>
      
        <content type="html"><![CDATA[<h1 id="改进平方根法和追赶法"><a href="#改进平方根法和追赶法" class="headerlink" title="改进平方根法和追赶法"></a>改进平方根法和追赶法</h1><p>虽然平方根法的时间复杂度远远低于高斯消元法和lU分解，但是n个开方运算会耗费很多的时间，所以为了避免开放运算，需要对平方根法进行改进。</p><p>追赶法则是求解严格对角占优矩阵效率最高的算法之一。</p><a id="more"></a><h2 id="改进平方根法公式推导"><a href="#改进平方根法公式推导" class="headerlink" title="改进平方根法公式推导"></a>改进平方根法公式推导</h2><p>为了避免开方运算，我们使用$A=LDL^{T}$导出分解公式</p><script type="math/tex; mode=display">由\\A=LU=LDD^{-1}U=LDL^{T}\\可知L^{T}=D^{-1}U,因此\\l_{i,j}=\frac{u_{ij}}{d_{i}}=\frac{u_{ij}}{u_{ii}},\quad i=1,2,\dots,n-1;j=i+1,i+2,\dots,n\\由杜立特尔分解可知\\u_{ij}=a_{ij}-\sum_{k=1}^{i-1}l_{ik}u_{kj},\quad i=1,2,\dots,n;j=i,i+1,\dots,n\\\Rightarrow l_{ij}=\frac{a_{ij}-\sum_{k=1}^{i-1}l_{ik}u_{kj}}{u_{ii}},\quad i=1,2,\dots,n-1;j=i+1,i+2,\dots,n</script><p>用$A=LDL^{T}$分解求解方程组Ax=b就是改进平方根法，下面导出计算公式</p><script type="math/tex; mode=display">Ax=b \Rightarrow LDL^{T}\Rightarrow \left\{\begin{array}\Ly=b\\Dz=y\\L^{T}x=z\end{array}\right.\\由Ly=b可得\\y_{1}=b_{1}\\y_{i}=b_{i}-\sum_{k=1}^{i-1}l_{ik}y_{k},\quad i=2,3,\dots,n\\由Dz=y可得\\z_{i}=\frac{y_{i}}{u_{ii}},\quad i=1,2,\dots,n\\由L^{T}x=z可得\\\left\{\begin{array}\x_{n}=z_{n}\\x_{i}=z_{i}-\sum_{i+1}^{n}l_{ki}x_{k},\quad i=n-1,n-2,\dots,1\end{array}\right.\\将z_{i}和l_{ki}=\frac{u_{ik}}{u_{ii}}代入x_{i}的表达式，可得\\\left\{\begin{array}\x_{n}=\frac{y_{n}}{u_{nn}}\\x_{i}=\frac{y_{i}-\sum_{k=i+1}^{n}u_{ik}x_{k}}{u_{ii}},\quad i=n-1,n-2,\dots,2,1\end{array}\right.</script><h2 id="改进平方根法的算法分析"><a href="#改进平方根法的算法分析" class="headerlink" title="改进平方根法的算法分析"></a>改进平方根法的算法分析</h2><p>采用改进平方根法求解Ax=b共用了乘除法$\frac{1}{6}n^{3}+\frac{3}{2}n^{2}-\frac{2}{3}n$个，它比平方根法多了$\frac{1}{2}n^{2}-\frac{1}{2}n$个乘除法，但是少了n个开方运算，而相比于高斯消元法和杜立特尔分解几乎少了一半的乘除法，因此改进平方根法为求解对称正定方程组最有效的方法之一。实际上改进平方根法的分解公式和lU分解的分解公式是相同的，但是LU分解还要计算U矩阵，因此效率比较低，而改进平方根法则利用正定对称矩阵的特点，使得只需要计算L矩阵，大大减少了计算量，提高了效率。</p><h2 id="追赶法的分解公式"><a href="#追赶法的分解公式" class="headerlink" title="追赶法的分解公式"></a>追赶法的分解公式</h2><p>在样条插值、常微分方程边值问题和热传导方程的有限差分法等问题中，常遇到求解三对角方程组Ax=b,即</p><script type="math/tex; mode=display">\begin{pmatrix}b_{1}&c_{1}&\\a_{2}&b_{2}&c_{2}\\&\ddots&\ddots&\ddots\\&&a_{n-1}&b_{n-1}&c_{n-1}\\&&&a_{n}&b_{n}\end{pmatrix}\begin{pmatrix}x_{1}\\x_{2}\\\vdots\\x_{n-1}\\x_{n}\end{pmatrix}=\begin{pmatrix}d_{1}\\d_{2}\\\vdots\\d_{n-1}\\d_{n}\end{pmatrix}</script><p>通常A是严格对角占优矩阵，严格对角占优矩阵存在唯一 的杜立特分解，形式如下</p><script type="math/tex; mode=display">A=LU=\begin{pmatrix}1\\l_{2}&1\\&\ddots&\ddots\\&&l_{n-1}&1\\&&&l_{n}&1\end{pmatrix}\begin{pmatrix}u_{1}&c_{1}\\&u_{2}&c_{2}\\&&\ddots&\ddots\\&&&u_{n-1}&c_{n-1}\\&&&&u_{n}\end{pmatrix}</script><p>根据矩阵乘法，我们可以导出分解公式如下</p><script type="math/tex; mode=display">\left\{\begin{array}\u_{1}=b_{1}\\l_{i}=\frac{a_{i}}{u_{i-1}},\quad i=2,3,\dots,n\\u_{i}=b_{i}-l_{i}c_{i-1},\quad i=2,3,\dots,n\end{array}\right.</script><h2 id="追赶法求解Ax-d的计算公式"><a href="#追赶法求解Ax-d的计算公式" class="headerlink" title="追赶法求解Ax=d的计算公式"></a>追赶法求解Ax=d的计算公式</h2><script type="math/tex; mode=display">Ax=d \Rightarrow LUx=d\Rightarrow \\\left\{\begin{array}\Ly=d\\Ux=y\end{array}\right.\quad\\由Ly=d可得\\\left\{\begin{array}\y_{1}=d_{1}\\y_{i}=d_{i}-l_{i}y_{i-1},\quad i=2,3,\dots,n\end{array}\right.\quad\\由Ux=y可得\\\left\{\begin{array}\x_{n}=\frac{y_{n}}{u_{n}}\\x_{i}=\frac{y_{i}-c_{i}x_{i+1}}{u_{i}},\quad i=n-1,n-2,\dots,1\end{array}\right.</script><h2 id="追赶法的一个分解示例"><a href="#追赶法的一个分解示例" class="headerlink" title="追赶法的一个分解示例"></a>追赶法的一个分解示例</h2><script type="math/tex; mode=display">A=\begin{pmatrix}1&2&0&0&0\\2&3&1&0&0\\0&-3&4&2&0\\0&0&4&7&1\\0&0&0&-5&6\end{pmatrix}\\\quad\\</script><p>分解结果如下</p><p><img src="http://src.zhumingcj.cn/blog/20190709/vK2m6n98uhN6.png?imageslim" alt="mark"></p><h2 id="追赶法的算法分析"><a href="#追赶法的算法分析" class="headerlink" title="追赶法的算法分析"></a>追赶法的算法分析</h2><p>用追赶法来解线性方程的乘除法运算次数仅为5n-4,比高斯消元法的运算次数少得多。并且由于方程组的系数矩阵是严格对角占优的，因此能保证追赶法顺利进行，并且计算过程稳定。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Numerical Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Square Root Method</title>
      <link href="2019/07/06/square-root-method-and-improved-square-root-method/"/>
      <url>2019/07/06/square-root-method-and-improved-square-root-method/</url>
      
        <content type="html"><![CDATA[<h1 id="平方根法"><a href="#平方根法" class="headerlink" title="平方根法"></a>平方根法</h1><p>在有限元法求解结构力学和最优化方法等诸多问题中，都需要求解一个系数矩阵是正定的线性方程组Ax=b。针对这种方程组的特点，采用平方根法更加有效。所谓平方根法是将系数矩阵分解为一个下三角形矩阵和该矩阵的转置的乘积，然后在此基础上求解方程。</p><a id="more"></a><h2 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h2><ol><li><p>若矩阵的各阶顺序主子式都不为零，则矩阵可以进行LU分解（1），且矩阵的LU分解唯一。现对（2）进行证明</p><script type="math/tex; mode=display">设  \quad\quad\quad\quad A=LU \quad\\且\quad\quad\quad\quad A=L_{1}U_{1}\\则  \quad\quad\quad\quad L_{1}^{-1}AU^{-1}=L_{1}^{-1}L \quad\quad\\\quad\quad\quad L_{1}^{-1}AU^{-1}=U_{1}U^{-1}\\即 \quad\quad\quad\quad\quad\quad\quad\quad L_{1}^{-1}L=U_{1}U^{-1}\\\quad\\因为 L_{1}^{-1}L为下单位三角矩阵，而U_{1}U^{-1}为上单位三角矩阵\\所以L_{1}^{-1}L=U_{1}U^{-1}=I</script></li><li><p>A为对称矩阵，当A的各阶顺序主子式都不等于零时，A可以唯一的分解为</p><p>​                                                $A=LDL^{T}$</p><p>现证明之</p><script type="math/tex; mode=display">根据引理（1），A=LU，记D=diag(d_{1},d_{2},d_{3},\dots,d_{n})=diag(u_{11},u_{22},\dots,u_{nn})\\则 \quad A=LU=LDD^{-1}U=LDM^{T},其中M^{T}=D^{-1}U\\又 \quad A=A^{T}=MDL^{T}\\因为M为下三角矩阵，而DL^{T}为上三角矩阵，所以MDL^{T}也是A的一个LU分解\\由LU分解的唯一性可得=>L=M\\所以 \quad A=MDL^{T}=LDL^{T}</script></li></ol><h2 id="平方根法重要定理"><a href="#平方根法重要定理" class="headerlink" title="平方根法重要定理"></a>平方根法重要定理</h2><p>   (对称正定矩阵的楚列斯基分解)设A是n阶对称正定矩阵，则存在一个可逆下三角矩阵G，使得</p><p>   ​                                    $A=GG^{T}$</p><p>   且当限定G的对角元为正时，这种分解是唯一的。</p><p>   证明：</p><script type="math/tex; mode=display">   由线性代数可知，正定矩阵的各阶顺序主子式都大于零，由上面的引理2可得\\   A=LDL^{T},且可证明D的对角元都大于零\\   \forall x\not=0 ,\quad 0<x^{T}Ax=x^{T}LDL^{T}x=(L^{T}x)^{T}D(L^{T}x)\\   当x取使L^{T}=e_{i}时，i=1,2,\dots,n\\   0<(L^{T}x)^{T}D(L^{T}x)=u_{ii}\\   现在记D^{\frac{1}{2}}=diag(\sqrt u_{11},\sqrt u_{22},\dots,\sqrt u_{nn})\\   则 \quad\quad A=LDL^{T}=LD^{\frac{1}{2}}D^{\frac{1}{2}}L^{T}=(LD^{\frac{1}{2}})(LD^{\frac{1}{2}})^{T}\\   其中G=LD^{\frac{1}{2}}为下三角矩阵，即\\   G\triangleq   \begin{pmatrix}   g_{11}\\   g_{21}&g_{22}\\   g_{31}&g_{32}&g_{33}\\   \vdots&\vdots&&\ddots\\   g_{n1}&g_{n2}&\dots&g_{n,n-1}&g_{nn}   \end{pmatrix}</script><h2 id="平方根法的计算公式"><a href="#平方根法的计算公式" class="headerlink" title="平方根法的计算公式"></a>平方根法的计算公式</h2><p>根据$A=GG^{\frac{1}{2}}$，由矩阵乘法得</p><script type="math/tex; mode=display">a_{ij}=\sum_{k=1}^{n}g_{ik}g_{jk}=\sum_{k=1}^{\min(i,j)}g_{ik}g_{jk}=\sum_{k=1}^{j}g_{ik}g_{jk}=\sum_{k=1}^{j-1}g_{ik}g_{jk}+g_{ij}g_{jj}\\\quad\\当i=j时，a_{jj}=\sum_{k=1}^{j-1}g_{jk}^{2}+g_{jj}^{2}\\\quad\\所以，\quad g_{jj}=(a_{jj}-\sum_{k=1}^{j-1}g_{jk}^{2})^{\frac{1}{2}},j=1,2,\dots,n\\\quad\\当j=1时，g_{11}=\sqrt {a_{11}}\\\quad\\当i>j时，\\g_{ij}=\frac{a_{jj}-\sum_{k=1}^{j-1}g_{ik}g_{jk}}{g_{jj}},j=1,2,\dots,n-1;i=j+1,j=2，\dots,n\\\quad\\当j=1时，g_{i1}=\frac{a_{i1}}{g_{11}}(i=2,3,\dots,n)\\\quad\\综上，可得分解公式\\\left\{\begin{array}\g_{11}=\sqrt {a_{11}}\\g_{i1}=\frac{a_{i1}}{g_{11}}    \quad\quad\quad\quad i=2,3,\dots,n\\g_{jj}=(a_{ij}-\sum_{k=1}^{j-1}g_{jk}^{2})^{\frac{1}{2}} \quad\quad\quad\quad j=2,3,\dots,n\\g_{ij}=\frac{a_{jj}-\sum_{k=1}^{j-1}g_{ik}g_{jk}}{g_{jj}} \quad\quad\quad\quad j=2,3,\dots,n-1;i=j+1,j+2,\dots,n\end{array}\right.</script><p>有分解公式可知</p><p>​                            $a_{jj}=\sum_{k=1}^jg_{jk}^{2} \Rightarrow \vert g_{jk} \vert  \le\sqrt {a_{jj}},j=1,2,\dots,n;k=1,2,\dots,j.$</p><p>由此可见，G的元素是可以控制的，舍入误差不会无限增长，这种分解是稳定的。</p><h2 id="平方根法的一个分解示例"><a href="#平方根法的一个分解示例" class="headerlink" title="平方根法的一个分解示例"></a>平方根法的一个分解示例</h2><script type="math/tex; mode=display">A=\begin{pmatrix}9&18&9&-27\\18&45&0&-45\\9&0&126&9&\\-27&-45&9&135\end{pmatrix}分解\Rightarrow\\</script><p><img src="http://src.zhumingcj.cn/blog/20190706/FPzljembBuYP.png?imageslim" alt="mark"></p><h2 id="使用平方根法求解方程"><a href="#使用平方根法求解方程" class="headerlink" title="使用平方根法求解方程"></a>使用平方根法求解方程</h2><p>由$A=GG^{T}$可得</p><script type="math/tex; mode=display">Ax=b\Rightarrow GG^{T}x=b\Rightarrow\\\left\{\begin{array}\Gy=b\Rightarrow解出y\\G^{T}x=y\Rightarrow解出x\end{array}\right.\\\quad\\由Gy=b可知\left\{\begin{array}\g_{11}y_{1}=b_{1}\\g_{i1}y_{1}+g_{i2}y_{2}+\dots+g_{ii}y_{i}=b_{i},i=2,3,\dots,n\end{array}\right.\\\quad\\综上\\\left\{\begin{array}\y_{1}=\frac{b_{1}}{g_{11}}\\y_{i}=\frac{b_{i}-\sum_{k=1}^{i-1}g_{ik}y_{k}}{g_{ii}},i=2,3,\dots,n\end{array}\right.\\\quad\\然后再从G^{T}x=y,解出x</script><h2 id="平方根法算法分析"><a href="#平方根法算法分析" class="headerlink" title="平方根法算法分析"></a>平方根法算法分析</h2><p>用平方根法求解Ax=b共需要$\frac{1}{6}n^{3}+n^{2}-\frac{1}{6}n$个乘除法和n个开方运算，相比于高斯消元法和lU分解法求解方程减少了近一半的运算量。但是n个开放运算需要耗费较多的机器时间。</p><h2 id="平方根法的程序实现"><a href="#平方根法的程序实现" class="headerlink" title="平方根法的程序实现"></a>平方根法的程序实现</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace Square_Root_Method</span><br><span class="line">{</span><br><span class="line">    class Program</span><br><span class="line">    {</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">            Matrix m = new Matrix(4, 4);</span><br><span class="line">            m.CholeskyDecomposition();</span><br><span class="line">            m.DisPlay();</span><br><span class="line">            Console.Read();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    class Matrix</span><br><span class="line">    {</span><br><span class="line">        public int row = 0;</span><br><span class="line">        public int column = 0;</span><br><span class="line">        private float[,] matrix;</span><br><span class="line">        //矩阵的初始化（输入）</span><br><span class="line">        public Matrix(int row, int column)</span><br><span class="line">        {</span><br><span class="line">            this.row = row;</span><br><span class="line">            this.column = column;</span><br><span class="line">            Console.WriteLine($"Please enter a matrix with {this.row}rows,{this.column}colums");</span><br><span class="line">            matrix = new float[row, column];</span><br><span class="line">            try</span><br><span class="line">            {</span><br><span class="line">                for (int i = 0; i &lt; row; i++)</span><br><span class="line">                {</span><br><span class="line">                    for (int j = 0; j &lt; column; j++)</span><br><span class="line">                    {</span><br><span class="line">                        string mid = Console.ReadLine();</span><br><span class="line">                        var rows = mid.Split(' ');</span><br><span class="line">                        foreach (var item in rows)</span><br><span class="line">                        {</span><br><span class="line">                            matrix[i, j++] = float.Parse(item);</span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">                Console.WriteLine("\r\n");</span><br><span class="line">            }</span><br><span class="line">            catch (Exception e)</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine($"something wrong!\n{e.Message}");</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        //输出矩阵</span><br><span class="line">        public void DisPlay()</span><br><span class="line">        {</span><br><span class="line">            for (int i = 0; i &lt; this.row; i++)</span><br><span class="line">            {</span><br><span class="line">                for (int j = 0; j &lt; this.column; j++)</span><br><span class="line">                {</span><br><span class="line">                    Console.Write(matrix[i, j] + "   ");</span><br><span class="line">                }</span><br><span class="line">                Console.WriteLine("\r");</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        //矩阵的Cholesky分解</span><br><span class="line">        //我们把结果保存在原矩阵的下三角中</span><br><span class="line">        public void CholeskyDecomposition()</span><br><span class="line">        {</span><br><span class="line">            //计算第一个元素</span><br><span class="line">            matrix[0, 0] = (float)Math.Sqrt(matrix[0, 0]);</span><br><span class="line">            //计算第一列元素</span><br><span class="line">            for (int i = 1; i &lt; this.row; i++)</span><br><span class="line">            {</span><br><span class="line">                matrix[i, 0] = matrix[i, 0] / matrix[0, 0];</span><br><span class="line">            }</span><br><span class="line">            for (int i = 1; i &lt; this.row; i++)</span><br><span class="line">            {</span><br><span class="line">//计算第i,j（i!=j）个元素</span><br><span class="line">                for (int j = 1; j &lt; i; j++)</span><br><span class="line">                {</span><br><span class="line">                    matrix[i, j] = (matrix[i, j] - TempValue(i, j)) / matrix[j, j];</span><br><span class="line">                }</span><br><span class="line">                //计算第j,j个元素，也可以放到上面的循环中去，并加判断</span><br><span class="line">                //注意这一行代码不能放到上面的for之前（与LU分解不同），这是算法决定的</span><br><span class="line">                matrix[i, i] = (float)Math.Sqrt(matrix[i, i] - TempValue(i, i));</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        //用于计算中间值</span><br><span class="line">        public float TempValue(int i, int j)</span><br><span class="line">        {</span><br><span class="line">            float result = 0;</span><br><span class="line">            for (int k = 0; k &lt; j; k++)</span><br><span class="line">            {</span><br><span class="line">                result += matrix[i, k] * matrix[j, k];</span><br><span class="line">            }</span><br><span class="line">            return result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行上面的代码，输入上面示例中的矩阵，我们将得到如下结果：</p><p><img src="http://src.zhumingcj.cn/blog/20190706/TSd9nlcRg2DF.png?imageslim" alt="mark"></p><p>经验证，与上面计算结果相同</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Numerical Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Basic Skills</title>
      <link href="2019/07/05/HTML%20Basic%20Skills/"/>
      <url>2019/07/05/HTML%20Basic%20Skills/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML-HyperText-Markup-Language-、CSS和Javascript"><a href="#HTML-HyperText-Markup-Language-、CSS和Javascript" class="headerlink" title="HTML(HyperText Markup Language)、CSS和Javascript"></a>HTML(HyperText Markup Language)、CSS和Javascript</h1><p>​    对于一个网页而言，主要由    HTML、CSS和Javascript组成。其中HTML主要负责网页框架的搭建，CSS主要负责网页的样式而JavaScript主要负责网页的行为。</p><a id="more"></a><h2 id="常用的HTML标签"><a href="#常用的HTML标签" class="headerlink" title="常用的HTML标签"></a>常用的HTML标签</h2><ol><li><p><code>&lt;html&gt;&lt;/html&gt;</code></p><p> 这个标签没什么用，但是所有HTML标签都需要写在这个标签内部</p></li><li><p><code>&lt;head&gt;&lt;/head&gt;</code></p><p>head标签是用来写一些给浏览器看的内容，包括网站名，网站描述等</p><h4 id="head内部常用的标签"><a href="#head内部常用的标签" class="headerlink" title="head内部常用的标签"></a>head内部常用的标签</h4><ul><li><p>meta标签</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset="utf-8"&gt; &nbsp;&lt;!--申明网页的编码格式--&gt;</span><br><span class="line">&lt;!<span class="selector-tag">--utf-8</span>为编码字符集<span class="selector-tag">--</span>&gt;</span><br><span class="line">&lt;meta name="keywords" content="xx"&gt;&lt;!--描述网页的类别，给网络爬虫看的信息--&gt;</span><br><span class="line">&lt;meta name="description" content="xx"&gt;&lt;!--对网页的描述，也是给爬虫看的信息--&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol><pre><code> 常用的字符编码有： - gb2312(包括亚裔字符集) - gbk(在gb2312基础上增加了繁体中文) - unicode(万国码)title标签</code></pre><ul><li><p>title标签</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;    这里可以写标题（浏览器上方显示的）&lt;/title&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul><ol><li><p>body标签</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt; </span><br><span class="line">这里是网页的主体</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="body内常用的标签"><a href="#body内常用的标签" class="headerlink" title="body内常用的标签"></a>body内常用的标签</h4></li></ol><ul><li><p>p标签</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">这是一个段落，常用来换行</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>h标签</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;这是一个标题&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;这也是一个标题&lt;/h2&gt;</span><br><span class="line">&lt;!--最多到h5--&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>strong标签</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>加粗<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>em标签</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;em&gt;斜体&lt;/em&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>del标签</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;del&gt;中划线，效果参考打折的价格&lt;/del&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>div标签</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;只是一个容器，无具体功能，有利于模块化和绑定操作&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>sapn标签</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;这也是一个容器&lt;/span&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>a标签</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a herf="www.baidu.com" target="_blank"&gt;这是超链接锚点，最初的作用为&lt;/a&gt;</span><br><span class="line">&lt;!--target的值决定是在当前页面打开链接还是在新的页面中打开页面--&gt;</span><br><span class="line">&lt;!--herf的值除了URL还可以是tel(打电话)和mailto(发邮件),还可以是JavaScript（协议限定符，此标识后可写java代码，用户点击时会强行运行）--&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>br标签</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;br&gt;换行&lt;/br&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>hr标签</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;hr&gt;这是水平线&lt;/hr&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>ol和li标签</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol type="a" start="value"&gt;</span><br><span class="line">&lt;1--value的值决定最开始的序号值--&gt;</span><br><span class="line">&lt;!--type的值不同，列表的样式不同,1&gt;=序号为阿拉伯数字;I/i&gt;=序号为小写/大写罗马数字;A/a=&gt;序号为大小写英文字母--&gt;</span><br><span class="line">&lt;li&gt;这是一个有序列表，ol和li是一起使用的&lt;/li&gt;</span><br><span class="line">&lt;li&gt;苹果&lt;/li&gt;</span><br><span class="line">&lt;li&gt;橘子&lt;/li&gt;</span><br><span class="line">&lt;li&gt;樱桃&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>ul和li标签</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul type="disc"&gt;</span><br><span class="line">&lt;!--type的值决定无序列表的样式，具体不做叙述--&gt;</span><br><span class="line">&lt;li&gt;这是无序列表&lt;/li&gt;</span><br><span class="line">&lt;li&gt;圆&lt;/li&gt;</span><br><span class="line">&lt;li&gt;正方形&lt;/li&gt;</span><br><span class="line">&lt;li&gt;三角形&lt;/li&gt;</span><br><span class="line">&lt;li&gt;矩形&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></tbody></table></figure><p><code>注：ui和li常用来做导航栏，菜单栏等功能和形式差不多，天生具有父子结构的对象</code></p></li><li><p>img标签</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src="图片的相对地址或绝对地址" alt="图片的摘要" title="图片的描述"&gt;</span><br><span class="line">&lt;!--当网页文件和图片处于同一个文件夹下时，可以使用相对地址，更加简单；否则使用绝对地址才能正常加载图片--&gt;</span><br><span class="line">&lt;!--Alt的值是当图片无法正常加载时显示 在图片上的信息，用来改善用户体验--&gt;</span><br><span class="line">&lt;!--title的值是用户的鼠标放在图片上时会显示的信息--&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>form标签</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method="get/post" action="发送信息的地址"&gt;</span><br><span class="line">&lt;input type="text" name="username"&gt;&lt;!--这文本输入框--&gt;</span><br><span class="line">&lt;input type="password" name="password"&gt;&lt;!--这密码框--&gt;</span><br><span class="line">&lt;input type="submit"&gt;&lt;!--这是提交按钮--&gt;</span><br><span class="line">&lt;input type="radio" name="xx"&gt;&lt;!--这是当选框,只有当数个单选框的name值相同时，才会发挥单选的功能--&gt;</span><br><span class="line">&lt;input type="radio" name="xx"&gt;</span><br><span class="line">&lt;input type="radio" name="xx"&gt;</span><br><span class="line">&lt;input type="checkbox" name="xxx"&gt;&lt;!--这是复选框,只有当数个复选框的name值相同时，才会正常发挥复选的功能--&gt;</span><br><span class="line">&lt;input type="checkbox" name="xxx"&gt;</span><br><span class="line">&lt;input type="checkbox" name="xxx"&gt;</span><br><span class="line">&lt;select&gt;</span><br><span class="line">&lt;option&gt;北京&lt;/option&gt;&lt;!--这是一个下拉框--&gt;</span><br><span class="line">&lt;option&gt;上海&lt;/option&gt;</span><br><span class="line">&lt;option&gt;天津&lt;/option&gt;</span><br><span class="line">&lt;option&gt;广州&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;!--想要正确提交信息，必须要有name和value--&gt;</span><br><span class="line">&lt;/form&gt;复</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="标签的归类"><a href="#标签的归类" class="headerlink" title="标签的归类"></a>标签的归类</h2><ol><li><p>行级元素</p><p>feature：</p><ul><li>内容决定元素所占位置</li><li>不可以通过css改变宽高</li></ul><p>常见的有：</p><ul><li>span</li><li>strong</li><li>em</li><li>a</li><li>del</li></ul></li><li><p>块级元素</p><p>feature：</p><ul><li>独占一行</li><li>可以通过css代码改变宽高</li></ul><p>常见的有：</p><ul><li>div</li><li>p</li><li>ul</li><li>li</li><li>ol</li><li>form</li><li>address</li></ul></li><li><p>行级块元素</p><p>feature:</p><ul><li>内容决定大小</li><li>可以通过css改宽高</li></ul></li></ol><p>标签类型的实质：</p><p>都是css特性的表现——对象都有一个display的css属性，display有三个属性值=&gt;</p><ol><li>inline  (行级)</li><li>2.block  (块级)</li><li>3.inline-block  (行级块元素)</li></ol><p>所以标签的类型不是固定的，可以通过css代码来更改；此外，所有属性为inline的对象都具有文字特性，即空格会被视为文本分隔符即如果inline对象之间有空格/空行就会间隔一定距离。</p><h2 id="HTML补充"><a href="#HTML补充" class="headerlink" title="HTML补充"></a>HTML补充</h2><ol><li>HTML语言中没有空格标签，所有空格都是文本分隔符，如果想要输入空格需输入&amp;nbsp，此外，其它特殊字符还有</li></ol><ul><li><code>&lt;     &amp;lt</code></li><li><code>&gt;     &amp;gt</code></li></ul><ol><li>HTML标签是可以嵌套的，通过嵌套可以实现各种不同的功能。</li><li>html还有很多复杂的标签，但是基本上很少用，因为网络编程要求结构和样式和行为相分离，那些复杂的标签多为带有样式的标签。</li></ol><h2 id="CSS代码"><a href="#CSS代码" class="headerlink" title="CSS代码"></a>CSS代码</h2><h4 id="CSS代码引入的方式"><a href="#CSS代码引入的方式" class="headerlink" title="CSS代码引入的方式"></a>CSS代码引入的方式</h4><ol><li><p>行间样式（内联），如</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style="</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">background-color: #f40"</span><br><span class="line">&gt;&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>页面级CSS，如</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">div{</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">background-color: #f40;</span><br><span class="line">}</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>外部CSS文件（最常用），如</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div{</span><br><span class="line"></span><br><span class="line">border:1px solid black;text-align: right;</span><br><span class="line">text-indent: 2em;</span><br><span class="line">cursor: ;</span><br><span class="line">text-decoration: line-through;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但是，外部CSS文件要能作用到HTML文件上，需要在HTML文件的head中加入如下代码</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel="stylesheet" type="text/css" href="CSS文件地址"&gt;</span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="浏览器的策略"><a href="#浏览器的策略" class="headerlink" title="浏览器的策略"></a>浏览器的策略</h4><ol><li>浏览器从服务器下载HTML文件时，采取下载一行执行一行的形式</li><li>当执行到link CSS的代码时，浏览器会开启一个新的线程来同时下载CSS和HTML文件</li><li>在执行复杂选择器时，浏览器采用从右向左的方式，可以提高搜索的效率</li></ol><h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h4><ol><li><p>Id选择器</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#only</span>{</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#ff3058</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/*首先要求对象具有ID，ID是一对一唯一的标识，其中only为ID值*/</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>class选择器</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.typeone</span>{</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#345564</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/*对象应具有class，且class不唯一，其中typeone为class值*/</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>标签选择器</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>{</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#634432</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/*标签选择器会选中所有该类标签*/</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>通配符选择器</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*{</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#243543</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*此选择器会作用到全局*/</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>属性选择器，如</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[id]</span>{</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#f84</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*也可以指定属性值*/</span></span><br><span class="line"><span class="selector-attr">[id="only"]</span>{</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#f84</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>！important</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#only</span>{</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#ff3058</span><span class="meta">!important</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/*加上！important后，此选择器优先级最高*/</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>父子选择器</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span>{</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#567889</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-id">#demo1</span> <span class="selector-class">.typeone</span> <span class="selector-tag">span</span>{</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#678980</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*可以用来限定目标，可以套很多层，且形式不一定要一样*/</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>直接子元素选择器</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">span</span>{</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#779</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/*只会作用于字节的子类*/</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>并列选择器</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.demo1</span>{</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#655</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*可以用多个选择器不加空格的组合到一起，可涮选出符合所有条件的对象*/</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>分组选择器</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">em</span><span class="selector-class">.demo1</span>,</span><br><span class="line"><span class="selector-tag">strong</span> <span class="selector-id">#only</span>,</span><br><span class="line"><span class="selector-tag">div</span></span><br><span class="line">{</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#658</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*可以实现代码的复用，把具有同样样式的选择器用逗号隔开，则可作用于所有对象*/</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>伪类选择器</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>{</span><br><span class="line"><span class="attribute">background-color</span>: orange;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*当鼠标移动到对象的领域之内时，为对象加上相应的样式，当鼠标移开后，则会移除相应的样式*/</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="CSS选择器的优先级和权值"><a href="#CSS选择器的优先级和权值" class="headerlink" title="CSS选择器的优先级和权值"></a>CSS选择器的优先级和权值</h4><ul><li>优先级          ！important&gt;行间样式&gt;ID&gt;class|属性&gt;标签选择器&gt;*</li><li><p>CSS选择器的权值</p><ul><li>！important            infinity </li><li>行间样式                   1000</li><li>ID                               100</li><li>class|属性|伪类        10</li><li>标签|伪元素                1</li><li>通配符                          0</li></ul></li><li><p>CSS权重用于选择器优先级的比较，多重选择器嵌套可以将权重相加，<code>且权重的值不为十进制而是256进制！！！</code></p></li></ul><h4 id="CSS代码常用属性"><a href="#CSS代码常用属性" class="headerlink" title="CSS代码常用属性"></a>CSS代码常用属性</h4><div class="table-container"><table><thead><tr><th>font-size: 50px;</th><th>设置字体的大小（实际设置字体的高）</th></tr></thead><tbody><tr><td>font-weight: bold;</td><td>设置字体的粗细</td></tr><tr><td>font-style: italic;</td><td>斜体</td></tr><tr><td>font-family: arial;</td><td>设置字体样式</td></tr><tr><td>color: #424;</td><td>设置字体颜色</td></tr><tr><td>border: 1px solid black;</td><td>设置外边框的粗细、样式（直线，虚线等）和颜色</td></tr><tr><td>width: 100px;</td><td>设置宽</td></tr><tr><td>height: 100px;</td><td>设置高</td></tr><tr><td>text-align: right;</td><td>设置文本对齐方式（左对齐，右对齐，居中）</td></tr><tr><td>line-height: 20px;</td><td>单行字体行高，用以控制行间距</td></tr><tr><td>text-indent: 2em;</td><td>设置缩进，单位是em（当前每个字体的像素大小）</td></tr><tr><td>text-decoration: line-through;</td><td>对字体进行装饰，值不同样式不同（下划线，中划线，上划线等）</td></tr><tr><td>cursor: pointer;</td><td>设置鼠标聚焦时鼠标样式的变化</td></tr></tbody></table></div><h4 id="字体颜色的三种形式"><a href="#字体颜色的三种形式" class="headerlink" title="字体颜色的三种形式"></a>字体颜色的三种形式</h4><ol><li><p>纯英文单词</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">color: green;</span><br><span class="line">color: blue;</span><br></pre></td></tr></tbody></table></figure></li><li><p>颜色代码</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">color: #ff4400;</span><br><span class="line">color: #768798;</span><br><span class="line">color: #ff3;</span><br></pre></td></tr></tbody></table></figure></li><li><p>颜色函数</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">color: rgb(3,35,234);</span><br><span class="line">color: rgb(32,43,255);</span><br></pre></td></tr></tbody></table></figure><p><code>注：颜色代码是由光学三原色混合而成的（r[00-ff];g[00-ff];b[]00-ff）,所以需要六位的值来确定颜色，但是如果每两位都是一样的，则可以进行简写，即每两位并成一位；而颜色函数也是由光学三颜色合成的，但是只需要三个参数，每一位的范围是0-255.实际上颜色代码和颜色函数是等价的，只是颜色函数只是把两位十六进制数组成256进制位。</code></p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https protocol</title>
      <link href="2019/07/04/https-protocol/"/>
      <url>2019/07/04/https-protocol/</url>
      
        <content type="html"><![CDATA[<h1 id="https协议详析"><a href="#https协议详析" class="headerlink" title="https协议详析"></a>https协议详析</h1><p>当我们使用浏览器时可能会发现我们输入的网站有以http和以https开头的，它们的区别在于哪里呢？实际上，可以说https是http的升级版，是对其安全性的加强。</p><a id="more"></a><h2 id="浏览器的一般工作流程"><a href="#浏览器的一般工作流程" class="headerlink" title="浏览器的一般工作流程"></a>浏览器的一般工作流程</h2><ol><li>当用户输入要访问的URL后，浏览器会根据URL解析出其域名</li><li>通过DNS服务器查询出域名映射的IP地址</li><li>根据查询到的IP地址与web服务器建立通讯</li></ol><p>上述过程可以抽象为下图</p><p><img src="http://src.zhumingcj.cn/blog/20190704/GfV08GYBcmg2.png?imageslim" alt="mark"></p><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><p>http协议是构建在TCP/IP协议的基础上的，所以我们有必要了解Tcp/Ip相关的知识。</p><h4 id="TCP-IP协议的分层模型"><a href="#TCP-IP协议的分层模型" class="headerlink" title="TCP/IP协议的分层模型"></a>TCP/IP协议的分层模型</h4><p>TCP/IP协议是由四层协议组成的系统，这四层分别为：应用层、传输层、网络层、链路层，如下图所示</p><p><img src="http://src.zhumingcj.cn/blog/20190704/Hh41MJiuhBnS.png?imageslim" alt="mark"></p><ol><li><p>应用层</p><p>应用层是我们编写的应用程序，它决定了向用户提供的应用服务。应用层可通过系统调用与传输层通讯。</p><p>处于应用层的协议非常多，比如：FTP(File Transfer Protocol，文件传输协议)、DNS(Domain Name System,域名系统)以及HTTP(HyperText Transfer Protocol,超文本传输协议)等。</p></li><li><p>传输层</p><p>传输层通过系统调用向应用层提供两台计算机之间的数据传输功能。</p><p>在传输层有两个性质不同的协议：TCP(Transmission Control Protocol,传输控制协议)和UDP(User Data Protocol,用户数据协议)。其中TCP在数据传输的安全性上高于UDP，但是其传输速度比较慢，所以一般快速下载软件都是用UDP,比如迅雷。</p></li><li><p>网络层</p><p>网络层用来处理网络上流动的数据包，归顶数据包的传输路径。</p></li><li><p>链路层</p><p>链路层是用来处理连接网络的硬件部分，包括操作系统、硬件设备驱动、NIC(Network Interface Card,网络适配器)以及光纤等硬件。</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>TCP协议是全双工的字节流传输，具有可靠性高的特点，为了确保其可靠性，TCP协议采用了”三次握手“的策略，如下图</p><p><img src="http://src.zhumingcj.cn/blog/20190704/czpzDig9RaME.png?imageslim" alt="mark"></p></li></ol><p>在图中，我们可以看到：</p><ol><li>首先客户端会向服务器发送一个带有SYN标志的连接请求</li><li>服务器接收到请求会作出应答，如果能接受连接，这服务器发送ACK进行确认，并且还会发送自己的SYN请求</li><li>客户端接受到SYN和ACK后，在向服务器发送ACK确认接受连接</li><li>三次握手完毕后会在客户端和服务器之间建立双向通信</li><li>为了维持TCP协议，在数据传输的过程中，接收端在接收端数据后都要给发送端发送ACK进行确认。若发送端在一定时间内没有接受到ACK确认，则会重发丢失的数据包</li></ol><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>HTTP协议（Hyper Text Transfer Protocol，超文本传输协议）,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p><p>HTTP基于TCP/IP通信协议来传递数据。</p><p>HTTP基于客户端/服务端（C/S）架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>（1）HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p><p>（2）HTTP是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</p><p>（3）HTTP是无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p><h2 id="HTTP协议的不足"><a href="#HTTP协议的不足" class="headerlink" title="HTTP协议的不足"></a>HTTP协议的不足</h2><ol><li>HTTP协议采用明文通讯，内容很有可能被窃听</li><li>无法验证对方身份，任何第三方可以通过伪装与服务器通讯</li><li>无法确定数据的可靠性，在传输中可能会被篡改</li></ol><h2 id="HTTPs协议"><a href="#HTTPs协议" class="headerlink" title="HTTPs协议"></a>HTTPs协议</h2><p>为了解决HTTP存在的问题，HTTPs应运而生，HTTPs采用SSL/TLS协议对传输的数据进行加密，保证了传输不被窃听；同时通过CA(由第三方权威机构颁发)证书验证通信双方的身份。</p><h4 id="有关CA证书"><a href="#有关CA证书" class="headerlink" title="有关CA证书"></a>有关CA证书</h4><p>CA证书是公司向权威机构申请，由权威机构颁发的。CA证书会被安装到服务器上，其中内容包括：</p><ol><li>持有者姓名</li><li>发证机关</li><li>有效日期</li><li>证件持有人的公钥</li><li>扩展信息</li><li>发证机关对该证书的数字签名（=前5点信息的MD5摘要，然后用CA的私钥加密）</li></ol><h4 id="HTTPs的通信原理"><a href="#HTTPs的通信原理" class="headerlink" title="HTTPs的通信原理"></a>HTTPs的通信原理</h4><ol><li><p>客户端信任发证机关的证书，一般用户不需要操作。因为CA（权威）[下面简称为CAA]证书存储在浏览器中，而浏览器一般自动信任了大多数的权威机构证书。</p></li><li><p>在请求建立的过程中，首先客户端会向服务器发送一次请求，服务器向客户端返回一个CA（公司服务器）证书[后简称CAS]</p></li><li>客户端根据得到的CAS证书读得发证机关的信息，找到内置的对于机关的CAA证书，从证书中找到机关的加密公钥，用公钥（解密钥）对得到的CAS证书的第六点信息进行解密，如果解得的信息与CAS证书前五点摘要的MD5相同，则说明服务器的CAS证书确为该机构颁布的，进而证明了服务器的身份</li><li>客户端再用CAS中得到的服务器的公钥（加密钥）加密一个信息比如“123”发送给服务器，服务器则根据其持有的私钥（解密钥）对信息进行解密，然后服务器把解密结果返回给客户端，若解密得到的信息与发送信息一致，则可证明该服务器就是客户端要访问的服务器。这样可防止因域名写错而造成的错误访问。</li><li>然后客户端会向服务器发送一条信息用以约定通信过程中的对称加密钥，然后即可在双方之间建立通信，以后的通信中发送端会用该对称加密钥对传输数据进行加密，而接收端也用该对称秘钥进行解密。这样就可以防止信息被窃听。</li></ol><p>通信流程图如下</p><p><img src="http://src.zhumingcj.cn/blog/20190704/lcNKdrDAa8WQ.png?imageslim" alt="mark"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Usage of Trigonometric Decomposition</title>
      <link href="2019/07/03/usage-of-trigonometric-decomposition/"/>
      <url>2019/07/03/usage-of-trigonometric-decomposition/</url>
      
        <content type="html"><![CDATA[<h1 id="三角分解解线性方程组"><a href="#三角分解解线性方程组" class="headerlink" title="三角分解解线性方程组"></a>三角分解解线性方程组</h1><p>相比于高斯消元法，应用三角分解来解线性方程组在某些情况下能提高计算的效率。</p><a id="more"></a><h3 id="三角分解解线性方程的公式推导"><a href="#三角分解解线性方程的公式推导" class="headerlink" title="三角分解解线性方程的公式推导"></a>三角分解解线性方程的公式推导</h3><p>即，我们要解 LUx=b, 我们把这个方程拆为两个方程来解</p><script type="math/tex; mode=display">\left\{\begin{array}\Ly=b\\Ux=y\end{array}\right.</script><p>解方程组Ly=b的第一个方程为$y_{1}=b_{1}$，而第i个方程为</p><script type="math/tex; mode=display">\sum_{j=1}^{i-1}(l_{ij}y_{ij}+y_{i}=b_{i})\Longrightarrow\\\left\{\begin{array}\y_{1}=b_{1},\\y_{i}=b_{i}-\sum_{j=1}^{i-1}l_{ij}y_{j},\quad i=1,2,3,\dots,n\end{array}\right.</script><p>将解得的y代入Ux=y，由高斯消元法回代公式可得</p><script type="math/tex; mode=display">\left\{\begin{array}\x_{n}=\frac{y_{n}}{u_{nn}},\\x_{i}=\frac{y_{i}-\sum_{j=i+1}^{n}u_{ij}x_{j}}{u_{ii}},\quad i=n-1,n-2,\dots,2,1\end{array}\right.</script><hr><h3 id="一个LU分解的例子"><a href="#一个LU分解的例子" class="headerlink" title="一个LU分解的例子"></a>一个LU分解的例子</h3><script type="math/tex; mode=display">A=\begin{pmatrix}9&18&9&-27\\18&45&0&-45\\9&0&126&9\\-27&-45&9&135\end{pmatrix}\quad\quad\quad\quad\quad\quad b=\begin{pmatrix}1\\2\\16\\8\end{pmatrix}</script><p>现在对A进行分解</p><p><img src="http://src.zhumingcj.cn/blog/20190703/Vn9k4APAIbny.png?imageslim" alt="mark"></p><p>即可得</p><script type="math/tex; mode=display">L=\begin{pmatrix}1&\\2&1&\\1&-2&1\\-3&1&\frac{2}{3}&1\end{pmatrix}\quad\quad U=\begin{pmatrix}9&18&9&-27\\0&9&-18&9\\0&0&81&54\\0&0&0&9\end{pmatrix}\\\quad\\\quad\\y=\begin{pmatrix}1\\0\\15\\1\end{pmatrix}</script><h3 id="LU分解解线性方程组的算法分析"><a href="#LU分解解线性方程组的算法分析" class="headerlink" title="LU分解解线性方程组的算法分析"></a>LU分解解线性方程组的算法分析</h3><p>由矩阵LU分解公式可知，计算$u_{ij}$和$l_{ij}$各有</p><p>​                                                              $\sum_{j=2}^{n-1}(j(n-j)+n-1=\sum_{1}^{n-1}j(n-j)=1/6n^{3}-1/6n$</p><p>个乘除法，所以矩阵分解共有$1/3n^3-1/3n$个乘除法，而求解下三角方程Ly=b有$1/2n(n-1)$个乘除法，求解上三角方程Ux=y有$1/2n(n-1)+n$个乘除法，综上，用LU分解来解线性方程组共有$\frac{1}{3}n^{2}+n^{2}-\frac{1}{3}n$个乘除法，与高斯消元法的运算次数一样。</p><p>但是从LU分解的形式上看，不难发现如果我们要解一系列系数矩阵相同但右端不同的方程组时，LU分解可以大大减少计算量。</p><h3 id="编程实现LU分解"><a href="#编程实现LU分解" class="headerlink" title="编程实现LU分解"></a>编程实现LU分解</h3><ol><li>程序如下</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace Trigonometric_Decomposition</span><br><span class="line">{</span><br><span class="line">    class Program</span><br><span class="line">    {</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">           Matrix m= new Matrix(6, 6);</span><br><span class="line">            m.LuDecomposition();</span><br><span class="line">            m.DisPlay();</span><br><span class="line">            Console.Read();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        class Matrix</span><br><span class="line">        {</span><br><span class="line">            public int row = 0;</span><br><span class="line">            public int column = 0;</span><br><span class="line">            private float[,] matrix;</span><br><span class="line">            \\矩阵的输入</span><br><span class="line">            public Matrix(int row, int column)</span><br><span class="line">            {</span><br><span class="line">                this.row = row;</span><br><span class="line">                this.column = column;</span><br><span class="line">                Console.WriteLine($"Please enter a matrix with {this.row}rows,{this.column}colums");</span><br><span class="line">                matrix = new float[row, column];</span><br><span class="line">                try</span><br><span class="line">                {</span><br><span class="line">                    for (int i = 0; i &lt; row; i++)</span><br><span class="line">                    {</span><br><span class="line">                        for (int j = 0; j &lt; column; j++)</span><br><span class="line">                        {</span><br><span class="line">                            string mid = Console.ReadLine();</span><br><span class="line">                            var rows = mid.Split(' ');</span><br><span class="line">                            foreach (var item in rows)</span><br><span class="line">                            {</span><br><span class="line">                                matrix[i, j++] = float.Parse(item);</span><br><span class="line">                            }</span><br><span class="line"></span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                    }</span><br><span class="line">                    Console.WriteLine("\r\n");</span><br><span class="line">                }</span><br><span class="line">                catch (Exception e)</span><br><span class="line">                {</span><br><span class="line">                    Console.WriteLine($"something wrong!\n{e.Message}");</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            \\输出矩阵</span><br><span class="line">            public void DisPlay()</span><br><span class="line">            {</span><br><span class="line">                for (int i = 0; i &lt; this.row; i++)</span><br><span class="line">                {</span><br><span class="line">                    for (int j = 0; j &lt; this.column; j++)</span><br><span class="line">                    {</span><br><span class="line">                        Console.Write(matrix[i, j] + "   ");</span><br><span class="line">                    }</span><br><span class="line">                    Console.WriteLine("\r");</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            \\矩阵的LU分解</span><br><span class="line">            public void LuDecomposition()</span><br><span class="line">            {</span><br><span class="line">            //初始化第一行、第一列</span><br><span class="line">                for (int i = 1; i &lt; this.column; i++)</span><br><span class="line">                {</span><br><span class="line">                    matrix[i, 0] = matrix[i,0] / matrix[0, 0];</span><br><span class="line">                }</span><br><span class="line">                </span><br><span class="line">                for (int i = 1; i &lt; this.row; i++)</span><br><span class="line">                {</span><br><span class="line">                //先计算对角元，避免重复计算（放在第二个循环内会计算两次）</span><br><span class="line">                    matrix[i, i] = matrix[i, i] - FigureTemp(i, i, i );</span><br><span class="line">                    for (int j = i+1; j &lt; this.column; j++)</span><br><span class="line">                    {</span><br><span class="line">                    //第i行i列的更新</span><br><span class="line">                        matrix[i, j] = matrix[i, j] - FigureTemp(i, j, i);</span><br><span class="line">                        matrix[j, i] = (matrix[j, i] - FigureTemp(i, j, i))/matrix[i,i];</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                </span><br><span class="line">            }</span><br><span class="line">            private float FigureTemp(int i,int j,int k)</span><br><span class="line">            {</span><br><span class="line">            //用于计算求和中间量</span><br><span class="line">                float result = 0;</span><br><span class="line">                for (int s = 0; s &lt; k; s++)</span><br><span class="line">                {</span><br><span class="line">                    result += matrix[i, s] * matrix[s, j];</span><br><span class="line">                }</span><br><span class="line">                return result;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>程序的验证</li></ol><p>当我们输入矩阵</p><script type="math/tex; mode=display">A=\begin{pmatrix}9&18&9&-27\\18&45&0&-45\\9&0&126&9\\-27&-45&9&135\end{pmatrix}</script><p>将得到输出如下</p><p><img src="http://src.zhumingcj.cn/blog/20190703/1k03XAqLqCjq.png?imageslim" alt="mark"></p><p>经对比，与上面计算的一致，程序无误。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Numerical Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Triangular Decomposition</title>
      <link href="2019/07/02/triangular-decomposition/"/>
      <url>2019/07/02/triangular-decomposition/</url>
      
        <content type="html"><![CDATA[<h1 id="矩阵的LU分解"><a href="#矩阵的LU分解" class="headerlink" title="矩阵的LU分解"></a>矩阵的LU分解</h1><p><code>矩阵的分解在矩阵的研究中有着极其重要的地位，而LU分解则是矩阵分析中一种常见而又重要的分解.</code></p><a id="more"></a><h2 id="LU分解——从高斯消元法说起"><a href="#LU分解——从高斯消元法说起" class="headerlink" title="LU分解——从高斯消元法说起"></a>LU分解——从高斯消元法说起</h2><h4 id="LU分解的来龙去脉"><a href="#LU分解的来龙去脉" class="headerlink" title="LU分解的来龙去脉"></a>LU分解的来龙去脉</h4><p>在高斯消元法中，我们使用了多次倍加把主对角元以外的元素变为零，这个过程可以看成是用一系列的初等矩阵来左乘系数矩阵。</p><script type="math/tex; mode=display">A^{(0)}=A \quad\quad\quadA^{(1)}\triangleq\begin{pmatrix}a_{11}^{(0)}&a_{12}^{(0)}&\dots&a_{1n}^{(0)}\\0&a_{22}^{(1)}&\dots&a_{2n}^{(1)}\\\vdots&\vdots&&\vdots\\0&a_{n2}^{(1)}&\dots&a_{nn}^{(1)}\end{pmatrix}\quad\quad\quad\\\quad\\L_{1}\triangleq\begin{pmatrix}1&&&&\\-l_{12}&1\\-l_{13}&&1&&\\\vdots&&&\ddots\\-l_{1n}&&&&1\end{pmatrix}</script><p>则有$A^{(1)}=L_{1}A^{(0)}$,同理有</p><script type="math/tex; mode=display">A^{(2)}\triangleq\begin{pmatrix}a_{11}^{(0)}&a_{12}^{(0)}&a_{}13^{(0)}&\dots&a_{1n}^{(0)}\\0&a_{22}^{(1)}&a_{23}^{(1)}&\dots&a_{2n}^{(1)}\\0&0&a_{33}^{(2)}&\cdots&a_{3n}^{(2)}\\\vdots&\vdots&\vdots&&\vdots\\0&0&a_{n3}^{(2)}&\dots&a_{nn}^{(1)}\end{pmatrix}\quad\quad\quad\\\quad\\\quad\\L_{2}\triangleq\begin{pmatrix}1&&&&\\&1\\&-l_{32}&1\\&-l_{42}&&1&&\\&\vdots&&&\ddots\\&-l_{n2}&&&&1\end{pmatrix}\\A^{(2)}=L_{2}A^{(1)}</script><p>一般的，有</p><script type="math/tex; mode=display">A^{(k-1)}\triangleq\begin{pmatrix}a_{11}^{(0)}&a_{12}^{(0)}&&\dots &\dots&a_{1n}^{(0)}\\&a_{22}^{(1)}&&\dots&\dots&a_{2n}^{(1)}\\&&\ddots&&&\vdots\\&&&a_{kk}^{(k-1)}&\dots&a_{kn}^{(k-1)}\\&&&\vdots&\dots&\vdots\\&&&a_{nk}^{(k-1)}&\dots&a_{nn}^{(k-1)}\end{pmatrix}\quad\quad\quad\\\quad\\\quad\\L_{2}\triangleq\begin{pmatrix}1&&&&\\&\ddots\\&&1\\&&-a_{k+1,k}&1\\&&-l_{k+2,k}&&1&&\\&&\vdots&&&\ddots\\&&-l_{nk}&&&&1\end{pmatrix}\\\quad\\\quad\\\quad\\A^{(k)}\triangleqA^{(k-1)}\triangleq\begin{pmatrix}a_{11}^{(0)}&a_{12}^{(0)}&&\dots&a_{1,k+1}^{(0)} &\dots&a_{1n}^{(0)}\\&a_{22}^{(1)}&&\dots&a_{2,k+1}^{(1)} &\dots&a_{2n}^{(1)}\\&&\ddots&&\vdots&&\vdots\\&&&a_{kk}^{(k-1)}&a_{k,k+1}^{(k-1)} &\dots&a_{kn}^{(k-1)}\\&&&&a_{k+1,k+1}^{k}&\dots&a_{k+1,n}^{(k)}\\&&&&\vdots&&\vdots\\&&&&a_{n,k+1}^{(k)}&\dots&a_{nn}^{(k)}\end{pmatrix}\quad\quad\quadA^{(k)}=L_{k}A^{(k-1)}=\dots=L_{k}L_{k-1}\dots L_{1}A^{(0)}.</script><p>因为一共有n-1步消元，所以$A^{(n-1)}=L_{n}L{n-1}\dots L_{k}\dots L_{2}L_{1}A^{(0)}$</p><script type="math/tex; mode=display">A^{(n-1)}=\begin{pmatrix}a_{11}^{(0)}&a_{12}^{(0)}&\dots&a_{1n}^{(0)}\\&a_{22}^{(1)}&\dots&a{2n}^{(1)}\\&&\ddots&\vdots\\&&&a_{nn}^{n-1}\end{pmatrix}</script><p>我们注意到$L_{k}$的逆矩阵为</p><script type="math/tex; mode=display">L_{k}^{-1}=\begin{pmatrix}1&&&\\&\ddots&&\\&&1&&\\&&-l_{k+1,k}&1\\&&\vdots&&\ddots\\&&l_{n,k}&&&1\end{pmatrix}</script><p>则$A=A^{(0)}=L_{1}^{-1}L{2}^{-1}\dots L_{n-1}^{-1}A^{(n-1)}=LU$</p><p>其中</p><script type="math/tex; mode=display">L\triangleq L_{1}^{-1}L_{2}^{-1}\dots L_{n-1}^{-1}=\begin{pmatrix}1&&&&\\l_{21}&1\\l_{31}&l_{32}&1\\\vdots&\vdots&&\ddots\\l_{n1}&l_{n2}&\dots&l_{n,n-1}&l_{n,n}\end{pmatrix}\\\quad\\\quad\\U\triangleq A^{(n-1)}\begin{pmatrix}u_{11}&u_{12}&\dots&u_{1n}\\&u_{22}&\dots&u_{2n}\\&&\ddots&\vdots\\&&&u_{nn}\end{pmatrix}</script><p>显然可知L为下三角矩阵而U为上三角矩阵</p><h4 id="LU分解的公式推导"><a href="#LU分解的公式推导" class="headerlink" title="LU分解的公式推导"></a>LU分解的公式推导</h4><p>根据$A=LU$,由矩阵乘法可得</p><script type="math/tex; mode=display">a_{ij}=\sum_{k=1}^{n}l_{ik}u_{kj},\quad i,j=1,2,\dots,n \quad(1)</script><p><code>注：由L为下三角矩阵可知</code><strong>$l_{ij}=0, when j&gt;i$</strong> <code>同样的因为U是上三角矩阵，所以</code><strong>$u_{ij}=0, when i&gt;j$</strong></p><p>由（1）可先计算U的元</p><script type="math/tex; mode=display">a_{ij}=\sum_{k=1}^{i}l_{ik}u_{kj}=\sum_{k=1}^{i-1}l_{ik}u_{kj}+u_{ij}\quad\quad 故\\u_{ij}=a_{ij}-\sum_{k=1}^{i-1}l_{ik}u_{kj}\quad i=1,2,\dots,n;j=i,i+1,\dots,n \\特别的,当i=1时，u_{1j}=a_{1j}(j=1,2,\dots,n)</script><p>然后再计算L的元</p><script type="math/tex; mode=display">a_{ij}=\sum_{k=1}^{j}l_{ik}u_{kj}=\sum_{k=1}^{j-1}l_{ik}u_{kj}+l_{ij}u_{jj}\\\quad\\l_{ij}=\frac{a_{ij}-\sum_{k=1}^{j-1}l_{ik}u_{kj}}{u_{jj}}\\特别的，当j=1时，l_{i1}=\frac{a_{i1}}{u_{11}}</script><p>综上所述，我们可以得到如下公式</p><script type="math/tex; mode=display">\left\{\begin{array}\u_{1j}=a_{1j},\quad\quad\quad\quad\quad j=1,2,\dots,n\\l_{i1}=\frac{a_{i1}}{u_{11}},\quad\quad\quad\quad\quad i=2,3,\dots,n\\u_{ij}=a_{ij}-\sum_{k=1}^{i-1}l_{ik}u_{kj},\quad\quad\quad\quad\quad i=2,3,\dots,n;j=i,i+1,\dots,n\quad\quad\quad（2）\\l_{ij}=\frac{a_{ij}-\sum_{k=1}^{j-1}l_{ik}u_{kj}}{u_{jj}},\quad\quad j=2,3,\dots,n-1;i=j+1,j+2,\dots,n\end{array}\right.</script><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Numerical Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Singleton Pattern</title>
      <link href="2019/07/01/singleton-pattern/"/>
      <url>2019/07/01/singleton-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式——"><a href="#单例模式——" class="headerlink" title="单例模式——"></a>单例模式——</h1><p>单例模式是六中23种设计模式中最简单的一种，虽然如此单例模式还是有值得探讨的地方。</p><a id="more"></a><h3 id="单例模式的用处"><a href="#单例模式的用处" class="headerlink" title="单例模式的用处"></a>单例模式的用处</h3><p>顾名思义，单例模式就是想产生一个唯一的实例，而这样做的目的在于：</p><ul><li>对于某些频繁使用的全局对象，如果频繁地创建和销毁会占用很多的系统资源</li><li>在一些场景中，需要唯一的实例，比如序列号、资源管理器等，其本身要就具有唯一性。</li></ul><h3 id="单例模式的简介"><a href="#单例模式的简介" class="headerlink" title="单例模式的简介"></a>单例模式的简介</h3><p>单例模式一般分为两类，俗称懒汉式和饿汉式——懒汉式是指当真正要使用到这个对象时才去创建这个对象；而饿汉式则是在程序运行之初就完成对象的创建。</p><p>要想实现单例模式，首先就要把构造函数私有化，这样外部就无法通过调用构造函数来生成更多的实例了。但是这时就要对外提供产生实例的接口，并在内部完成单例的创建。</p><h3 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h3><ol><li><p>最简单的单例模式可以采用一个静态字段来保存单例，外界调用创建单例的方法时就把这个对象返回。静态字段会在程序一开始就初始化（由CLR实现），因此这是饿汉式的单例模式。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">       /// 最简单的单例模式，使用静态字段保存唯一单例，对外提供一个方法访问来获取单例</span><br><span class="line">       /// &lt;/summary&gt;</span><br><span class="line">       public class Singleton</span><br><span class="line">       {</span><br><span class="line">           private static Singleton _singelton = new Singleton();</span><br><span class="line">           private Singleton()</span><br><span class="line">           {</span><br><span class="line">   </span><br><span class="line">           }</span><br><span class="line">           public static Singleton CreatInstance()</span><br><span class="line">           {</span><br><span class="line">               return _singelton;</span><br><span class="line">           }</span><br><span class="line">   </span><br><span class="line">       }</span><br></pre></td></tr></tbody></table></figure></li></ol><ol><li><p>上面这种单例模式的实现方式存在一定的问题，试想如果这个单例在程序运行一开始并没有被使用，它就会占据系统的资源，会影响程序的效率（一个典型的例子是数据库链接，会占用大量资源）。所以改进的单例模式使用Lazy Loading，也就是懒汉模式。</p><figure class="highlight plain"><figcaption><span>/// &lt;summary&gt;</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">      /// 实现了Lazy Loading的单例模式，没有使用不会占用资源，但是它不是线程安全的</span><br><span class="line">      /// &lt;/summary&gt;</span><br><span class="line">      public class Singleton2</span><br><span class="line">      {</span><br><span class="line">          private long sum = 0;</span><br><span class="line">          private static Singleton2 _singelton = null;</span><br><span class="line">          private Singleton2()</span><br><span class="line">          {</span><br><span class="line">              Console.WriteLine($"{this.GetType().Name} 被构造了");</span><br><span class="line">          }</span><br><span class="line">          public void Change()</span><br><span class="line">          {</span><br><span class="line">              sum++;</span><br><span class="line">   </span><br><span class="line">          }</span><br><span class="line">          public static Singleton2 CreatInstance()</span><br><span class="line">          {</span><br><span class="line">              if (_singelton == null)</span><br><span class="line">              {</span><br><span class="line">                  _singelton = new Singleton2();</span><br><span class="line">   </span><br><span class="line">              }</span><br><span class="line">              return _singelton;</span><br><span class="line">          }</span><br><span class="line">          public static void Show()</span><br><span class="line">          {</span><br><span class="line">              Console.WriteLine(_singelton.sum);</span><br><span class="line">          }</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure></li></ol><ol><li><p>上一种单例模式可以满足一般的需求，但当涉及到多线程并发时，上一种方法会尝试问题，因为它不是线程安全的，所以需要枷锁同步</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">       /// 实现了Lazy Loading并且是线程安全的,但是在高并发的情况下会产生等待</span><br><span class="line">       /// &lt;/summary&gt;</span><br><span class="line">       public class Singleton3</span><br><span class="line">       {</span><br><span class="line">           private long sum = 0;</span><br><span class="line">           private static Singleton3 _singleton = null;</span><br><span class="line">           private static readonly object locker = new object();</span><br><span class="line">           private Singleton3()</span><br><span class="line">           {</span><br><span class="line">               Console.WriteLine($"{this.GetType().Name} 被构造了");</span><br><span class="line">           }</span><br><span class="line">           public void Change()</span><br><span class="line">           {</span><br><span class="line">               lock (locker)</span><br><span class="line">                   sum++;</span><br><span class="line">   </span><br><span class="line">           }</span><br><span class="line">           public static Singleton3 CreatInstance()</span><br><span class="line">           {</span><br><span class="line">   </span><br><span class="line">               lock (locker)</span><br><span class="line">               {</span><br><span class="line">                   if (_singleton == null)</span><br><span class="line">                   {</span><br><span class="line">                       _singleton = new Singleton3();</span><br><span class="line">   </span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line">               return _singleton;</span><br><span class="line">           }</span><br><span class="line">           public static void Show()</span><br><span class="line">           {</span><br><span class="line">               Console.WriteLine(_singleton.sum);</span><br><span class="line">           }</span><br><span class="line">       }</span><br></pre></td></tr></tbody></table></figure></li></ol><ol><li><p>现在已经接近完美了，但是任存在一个问题——性能的消耗，因为每次调用CreateInstance方法时，都要争取锁而排队，会造成阻塞。所以我们希望当单例完成创建后不要再排队，这就有名为了Double-Checked的单例模式</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">       /// 使用Double-check,与前一种方法一样，但是性能有提高，单例已生成的情况下不用等待</span><br><span class="line">       /// &lt;/summary&gt;</span><br><span class="line">       public class Singleton4</span><br><span class="line">       {</span><br><span class="line">   </span><br><span class="line">           private static Singleton4 _singelton = null;</span><br><span class="line">           private static readonly object locker = new object();</span><br><span class="line">           private Singleton4()</span><br><span class="line">           {</span><br><span class="line">               Console.WriteLine($"{this.GetType().Name} 被构造了");</span><br><span class="line">           }</span><br><span class="line">           public static Singleton4 CreatInstance()</span><br><span class="line">           {</span><br><span class="line">               if (_singelton == null)</span><br><span class="line">               {</span><br><span class="line">                   lock (locker)</span><br><span class="line">                   {</span><br><span class="line">                       if (_singelton == null)</span><br><span class="line">                       {</span><br><span class="line">                           _singelton = new Singleton4();</span><br><span class="line">   </span><br><span class="line">                       }</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line">               return _singelton;</span><br><span class="line">           }</span><br><span class="line">   </span><br><span class="line">       }</span><br></pre></td></tr></tbody></table></figure></li></ol><ol><li><p>现在事情似乎已经很完美了，但是如果细究一下我们会发现这样一个问题：当多个线程访问CreateInstance时，（单例还没有创建的情况下）它们都会进入第一个if语句开始排队，会有一个线程争得锁进入第二个if，然后调用构造函数创建单例，创建完后释放锁，第二个线程进入，第二个线程首先会检查_singleton的状态是否为空，现在问题就出现了，如果这个描述对象是否为空的属性如果没有及时更新，那么就会导致多个实例的产生。这种情况是可能存在的，这是编译器所决定的，由于读写无序则会导致前面的情况出现（先访问了实例是否存在的属性，之后才进行了这个属性的写操作）。改进的方法是在存储单例的静态字段前加上valotile关键词。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">      /// 也可以使用volatile关键字保证线程安全</span><br><span class="line">      /// &lt;/summary&gt;</span><br><span class="line">      public class Singleton5</span><br><span class="line">      {</span><br><span class="line">          private static readonly object locker = new object();</span><br><span class="line">          private static volatile Singleton5 _singelton = null;</span><br><span class="line">          public static Singleton5 CreatInstance()</span><br><span class="line">          {</span><br><span class="line">              if (_singelton == null)</span><br><span class="line">              {</span><br><span class="line">                  lock (locker)</span><br><span class="line">                  {</span><br><span class="line">                      if (_singelton == null)</span><br><span class="line">                      {</span><br><span class="line">                          _singelton = new Singleton5();</span><br><span class="line">                          Console.WriteLine("Singleton 被构造了");</span><br><span class="line">                      }</span><br><span class="line">                  }</span><br><span class="line">              }</span><br><span class="line">              return _singelton;</span><br><span class="line">          }</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure><p><code>注：volatile关键字的作用是保证被它修饰的对象（包括引用类型、指针类型、整型、具有整数基类型的枚举类型、泛型等）是和改变同步的，即永远是最新的（可以理解为volatile修饰的对象写操作先于读操作），具体原理涉及内存的操作，此处不做叙述。</code></p></li></ol><h3 id="关于单例线程安全问题的直观验证"><a href="#关于单例线程安全问题的直观验证" class="headerlink" title="关于单例线程安全问题的直观验证"></a>关于单例线程安全问题的直观验证</h3><p>   根据上面封装的类，当我们运行如下代码时</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">            List&lt;Task&gt; tasks1 = new List&lt;Task&gt;();</span><br><span class="line">            for (int i = 0; i &lt; 10000; i++)</span><br><span class="line">            {</span><br><span class="line">                Singleton2 singleton = Singleton2.CreatInstance();</span><br><span class="line">                tasks1.Add(Task.Run(() =&gt; singleton.Change()));</span><br><span class="line">            }</span><br><span class="line">            Task.WaitAll(tasks1.ToArray());</span><br><span class="line">            Singleton2.Show();</span><br><span class="line">            Console.WriteLine("***************************************************************");</span><br><span class="line">            List&lt;Task&gt; tasks2 = new List&lt;Task&gt;();</span><br><span class="line">            for (int i = 0; i &lt; 10000; i++)</span><br><span class="line">            {</span><br><span class="line">                Singleton3 singleton = Singleton3.CreatInstance();</span><br><span class="line">                tasks2.Add(Task.Run(() =&gt; singleton.Change()));</span><br><span class="line">            }</span><br><span class="line">            Task.WaitAll(tasks2.ToArray());</span><br><span class="line">            Singleton3.Show();</span><br><span class="line">            Console.Read();</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><p>会得到如下的结果</p><p><img src="http://src.zhumingcj.cn/blog/20190701/kma17CT4h8bR.png?imageslim" alt="mark"></p><p>这样我们可以直观地看到线程安全问题确实存在。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gaussian elimination method</title>
      <link href="2019/06/27/Gaussian%20elimination%20method/"/>
      <url>2019/06/27/Gaussian%20elimination%20method/</url>
      
        <content type="html"><![CDATA[<h1 id="求解矩阵的高斯消元法"><a href="#求解矩阵的高斯消元法" class="headerlink" title="求解矩阵的高斯消元法"></a>求解矩阵的高斯消元法</h1><p>高斯消元法是求解矩阵最基础的一种算法，具有泛化性强的优点。</p><a id="more"></a><h2 id="消元过程"><a href="#消元过程" class="headerlink" title="消元过程"></a>消元过程</h2><p>对于方程组$Ax=b$（其中A为n阶方阵）可由n-1个消元过程和n-1个回代过程完成求解</p><script type="math/tex; mode=display">\begin{cases}a_{11}x_1+a_{12}x_2+a_{13}x_3+\cdots+a_{1n}x_n=&b_1\\\vdots\\a_{n1}x_1+a_{n2}x_2+a_{n3}x_3+\cdots+a_{nn}x_n=&b_n&\end{cases}\\\begin{pmatrix}a_{11}&a_{12}&a_{13}&\dots&a_{1n}\\a_{21}&a_{22}&a_{23}&\dots&a_{2n}\\\vdots&&&&\vdots\\a_{n1}&a_{n2}&a_{n3}&\dots&a_{nn}\end{pmatrix}\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\end{pmatrix}=\begin{pmatrix}b_1\\b_2\\\vdots\\b_n\end{pmatrix}</script><ol><li><p>矩阵的消元过程(在矩阵有解的情况下)</p><ul><li>第一步消元</li></ul><p>$a_{ij}^{(1)}=a_{ij}^{(0)}-\frac{a_{i1}^{(0)}}  {a_{11}^{(0)}}a_{1j}^{(0)}=a_{ij}^{(0)}-l_{i1}^{(0)}a_{1j}^{(0)} ,\quad i=2,3,\dots,n;j=2,3,\dots,n$</p><p>$b_{i}^{(1)}=b_{i}^{(0)}-\frac{a_{i1}^{(0)}}  {a_{11}^{(0)}}b_{1}^{(0)}=b_{i}^{(0)}-l_{i1}^{(0)}b_{1}^{(0)} ,\quad i=2,3,\dots,n$</p><p>$l_{i1}\triangleq \frac {a_{i1}^{(0)}} {a_{11}^{(0)}},\quad i=2,3,\dots,n$</p><ul><li><p>第k步消元</p><p>$a_{ij}^{(k)}=a_{ij}^{(k-1)}-\frac{a_{ik}^{(k-1)}}  {a_{kk}^{(k-1)}}a_{kj}^{(k-1)}=a_{ij}^{(k-1)}-l_{ik}^{(k-1)}a_{kj}^{(k-1)} ,\quad i=k+1,k+2,\dots,n;j=k=1,k+2,\dots,n$</p><p>$b_{i}^{(k)}=b_{i}^{(k-1)}-\frac{a_{ik}^{(k-1)}}  {a_{kk}^{(k-1)}}b_{k}^{(k-1)}=b_{i}^{(k-1)}-l_{ik}^{(k-1)}b_{k}^{(k-1)} ,\quad i=k+1,k+2,\dots,n$</p><p>$l_{ik}\triangleq \frac {a_{ik}^{(k-1)}} {a_{kk}^{(k-1)}},\quad i=k+1,k+2,\dots,n$</p></li><li><p>消元完成后</p><script type="math/tex; mode=display">A^{(n-1)}=\begin{pmatrix}a_{11}^{(0)}&a_{12}^{(0)}&a_{13}^{(0)}&\cdots&\cdots&a_{1n}^{(0)}\\&a_{22}^{(1)}&a_{23}^{(1)}&\cdots&\cdots&a_{2n}^{(1)}\\&&\ddots\\&&&a_{kk}^{(k-1)}&\cdots&a_{kn}^{(k-1)}\\&&&&\ddots&\vdots\\&&&&&a_{nn}^{(n-1)}\end{pmatrix},\quadb^{(n-1)}=\begin{pmatrix}b_{1}^{(0)}\\b_{2}^{(1)}\\\vdots\\b_{k}^{(k-1)}\\\vdots\\b_{n}^{(n-1)}\end{pmatrix}</script></li></ul></li></ol><ol><li>回代的过程<script type="math/tex; mode=display">\left\{\begin{array}x_n=\frac{b_n^{n-1}}{a_{nn}^{(n-1)}}\\x_k=\frac{ {b_k}^{(k-1)-\sum_{j=k+1}^n(a_{kj}^{(k-1)}x_j)} } {a_{kk}^{(k-1)} },\quad k=n-1,n-2,\dots,2,1.\end{array}\right.</script></li></ol><h2 id="算法的分析"><a href="#算法的分析" class="headerlink" title="算法的分析"></a>算法的分析</h2><ul><li><p>[ ] 在消元的过程中，计算$l_{ik}\triangleq \frac {a_{ik}^{(k-1)}} {a_{kk}^{(k-1)}},\quad i=k+1,k+2,\dots,n$时共有n-k个除法，而计算$a_{ij}^{(k)}=a_{ij}^{(k-1)}-l_{ik}^{(k-1)}a_{kj}^{(k-1)} ,\quad i=k+1,k+2,\dots,n;j=k=1,k+2,\dots,n$时有$(n-k)^2$个乘法，计算$b_{i}^{(k)}=b_{i}^{(k-1)}-l_{ik}^{(k-1)}b_{k}^{(k-1)} ,\quad i=k+1,k+2,\dots,n$时也有n-k个乘法，消元共进行了n-1步，即$k=1,2,\dots,n-1$.</p></li><li><p>[ ] ==所以在消元过程中乘除法的运算量为==</p><script type="math/tex; mode=display">N_1=\sum_{k=1}^{n-1}((n-k)^2+2(n-k))=n^3/3+n^2/2-5n/6.</script></li></ul><ul><li><p>[ ] ==回代过程中乘除法的运算量为==</p><script type="math/tex; mode=display">   N_2=\sum_{k=1}^{n-1}(n-k)+n=n^2/2+n/2.</script><ul><li><p>[ ] ==所以高斯消元法解n阶矩阵的总乘除法运算量为==</p><p>$N=N_1+N_2=n^3/3+n^2-n/3$</p></li></ul></li></ul><h2 id="高斯消元法的程序实现"><a href="#高斯消元法的程序实现" class="headerlink" title="高斯消元法的程序实现"></a>高斯消元法的程序实现</h2><h6 id="我们可以封装一个Matrix类如下"><a href="#我们可以封装一个Matrix类如下" class="headerlink" title="我们可以封装一个Matrix类如下"></a>我们可以封装一个Matrix类如下</h6><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Matrix</span><br><span class="line">{</span><br><span class="line">    public int row = 0;</span><br><span class="line">    public int column = 0;           </span><br><span class="line">    private float[,] matrix;</span><br><span class="line">    public Matrix(int row, int column)</span><br><span class="line">    {</span><br><span class="line">        this.row = row;</span><br><span class="line">        this.column = column;</span><br><span class="line">        matrix = new float[row, column];</span><br><span class="line">        for (int i = 0; i &lt; row; i++)</span><br><span class="line">        {</span><br><span class="line">            for (int j = 0; j &lt; column; j++)</span><br><span class="line">            {</span><br><span class="line">                string mid = Console.ReadLine();</span><br><span class="line">                var rows = mid.Split(' ');</span><br><span class="line">                foreach (var item in rows)</span><br><span class="line">                {</span><br><span class="line">                    matrix[i, j++] = float.Parse(item);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public void DisPlay()</span><br><span class="line">    {                                         </span><br><span class="line">            for (int i = 0; i &lt; this.row; i++)</span><br><span class="line">            {</span><br><span class="line">                for (int j = 0; j &lt; this.column; j++)</span><br><span class="line">                {</span><br><span class="line">                    Console.Write(matrix[i, j] + " ");</span><br><span class="line">                }</span><br><span class="line">                Console.WriteLine("\r");</span><br><span class="line">            }                </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void Simplize()</span><br><span class="line">    {</span><br><span class="line">        for (int i = 0; i &lt; this.row ; i++)</span><br><span class="line">        {</span><br><span class="line">            if (matrix[i, i] != 0)</span><br><span class="line">            {</span><br><span class="line">                for (int k = i + 1; k &lt; row ; k++)</span><br><span class="line">                {</span><br><span class="line">                    matrix[k, i] = matrix[k, i] / matrix[i, i];</span><br><span class="line">                }</span><br><span class="line">            }//这里将消元的中间量存在被消元的位置，因为运算后，这些位置的值为零</span><br><span class="line">            for (int j = i + 1; j &lt; row; j++)</span><br><span class="line">            {</span><br><span class="line">                for (int k = i + 1; k &lt; column; k++)</span><br><span class="line">                {</span><br><span class="line">                    matrix[j, k] = matrix[j, k] - matrix[j, i] * matrix[i, k];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当我们输入</p><script type="math/tex; mode=display">\begin{pmatrix}1&2&1&0\\2&2&3&3\\-1&-3&0&2\end{pmatrix}</script><p>时，并调用Simplize和DisPlay方法，将得到结果如下</p><p><img src="http://src.zhumingcj.cn/blog/20190628/vVp4oxA9X7eB.png?imageslim" alt="mark"></p><p>事实上，这是一个矩阵的LU分解，LU分解在矩阵的研究中有着重要的地位，是十分常用的一个分解方法。</p><h2 id="高斯消元法的缺点"><a href="#高斯消元法的缺点" class="headerlink" title="高斯消元法的缺点"></a>高斯消元法的缺点</h2><ul><li>高斯消元法的运算量较大</li><li>高斯消元法的顺利进行要求矩阵满足某些要求</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Numerical Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Decoractor Pattern</title>
      <link href="2019/06/27/Decoractor-Pattern/"/>
      <url>2019/06/27/Decoractor-Pattern/</url>
      
        <content type="html"><![CDATA[<p>装饰器模式是一个很著名的设计模式，经常被用于有切面需求的场景，比如插入日志、统计等的逻辑。装饰器模式的作用是能为已经存在的对象添加额外的功能。</p><a id="more"></a><h1 id="设计模式之装饰器模式"><a href="#设计模式之装饰器模式" class="headerlink" title="设计模式之装饰器模式"></a>设计模式之装饰器模式</h1><h2 id="装饰器模式的作用"><a href="#装饰器模式的作用" class="headerlink" title="装饰器模式的作用"></a>装饰器模式的作用</h2><ul><li>在不改变现有对象结构的基础上为其添加新的功能，且并不通过继承而是通过对象之间的关联来实现，使其更加灵活。</li><li>相比于继承来增加新功能（固定的），装饰器模式可以动态的增加新功能，并且功能之间可以进行组合来产生更多的功能，避免了增加功能时对对象的修改</li><li>这是一种实现AOP（面向切面编程）的方法，即将主业务逻辑之外的aspect抽离出来，降低代码的耦合度。</li></ul><h2 id="实现装饰器模式的关键"><a href="#实现装饰器模式的关键" class="headerlink" title="实现装饰器模式的关键"></a>实现装饰器模式的关键</h2><p>装饰器模式无非是要调用一堆方法，但是又不能直接在类中增加逻辑（开闭原则），也不通过继承来实现，而是交给装饰器来实现。那么问题的关键就在于保存这一堆方法，并且使他们之间的顺序可以动态的调整。装饰器模式是通过字段对方法进行缓存（实际上是缓存一个对象，然后调用对象的方法），再通过迭代调用将各个方法以一定的顺序连接起来</p><h2 id="装饰器实现步骤"><a href="#装饰器实现步骤" class="headerlink" title="装饰器实现步骤"></a>装饰器实现步骤</h2><ol><li><p>建立一个继承自对象抽象类的装饰器基类，其中包括缓存字段，构造函数和方法调用</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class BaseStudentDecorator : AbstractStudent</span><br><span class="line">    {</span><br><span class="line">        private AbstractStudent _student = null;//用于缓存一个对象</span><br><span class="line">        public BaseStudentDecorator(AbstractStudent student)</span><br><span class="line">        {</span><br><span class="line">            this._student = student;</span><br><span class="line">        }</span><br><span class="line">        public override void Finish()</span><br><span class="line">        {</span><br><span class="line">            this._student.Finish();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></li></ol><ol><li><p>依照单一职责原则创建实现具体功能的装饰器，在其中调用父类的构造函数并复写父类的方法</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public StudentLearningDecoractor(AbstractStudent student) : base(student)</span><br><span class="line">        {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        public override void Finish()</span><br><span class="line">        {</span><br><span class="line">            {</span><br><span class="line">                //你要实现的逻辑</span><br><span class="line">            }</span><br><span class="line">            base.Finish();</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">//创建多个，根据要实现的逻辑</span><br></pre></td></tr></tbody></table></figure></li></ol><ol><li><p>对装饰器要实现的功能进行注册并调用</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">student = new StudentPreviewDecoractor(student);</span><br><span class="line">          student = new StudentLearningDecoractor(student);//添加了一个功能</span><br><span class="line">          student = new StudentReviewDecorator(student);//添加了一个功能</span><br><span class="line">          student = new StudentPlayDecoractor(student);//添加了一个功能</span><br><span class="line">          student = new StudentSleeepDecorator(student);//添加了一个功能</span><br><span class="line">          student.Finish();//调用</span><br></pre></td></tr></tbody></table></figure></li></ol><p>   抽象类和具体类</p>   <figure class="highlight plain"><figcaption><span>public abstract class AbstractStudent</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractStudent</span><br><span class="line">   {</span><br><span class="line">       public int Id { get; set; }</span><br><span class="line">       public string Name { get; set; }</span><br><span class="line">       public abstract  void Finish();</span><br><span class="line">   }</span><br><span class="line">   public class StudentCommon:AbstractStudent</span><br><span class="line">   {</span><br><span class="line">       public override void Finish()</span><br><span class="line">       {</span><br><span class="line">           Console.WriteLine($"{base.Name} finished learning");</span><br><span class="line">       }</span><br><span class="line">       public class StudentPreview: StudentCommon</span><br><span class="line">       {</span><br><span class="line">           public override void Finish()</span><br><span class="line">           {</span><br><span class="line">               base.Finish();</span><br><span class="line">               Console.WriteLine("先进行复习");</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>   运行结果：</p><p>   <img src="http://src.zhumingcj.cn/blog/20190627/5ckTbxL1rvl1.png?imageslim" alt="mark"></p><h2 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h2><ul><li><p>[ ] 当我们在注册方法时，student（不同类型）对象会被保存在基类中</p></li><li><p>[ ] 当我们最后调用finish方法时，会先调用StudentSleeepDecorator的finish方法，finish方法又会调用基类的finish方法，而基类的finish方法会调用之前缓存的student的finish方法…..，从而形成了一系列的调用，相当于一个链表结构。</p></li><li><p>[ ] 在我们实现具体的装饰器时，==base.Finish()和你要实现的逻辑的顺序直接影响到这些逻辑调用的顺序==。当你要实现的逻辑放在前面时，相当于堆栈，遵从先进后出的原则，因此先注册的方法会最后执行（1）；当base.Finish()放在前面时，相当于队列，遵从先进先出，因此先注册的方法最先执行（2）。</p></li><li><p>[ ] 所以当我们要实现在主逻辑（这里为Console.WriteLine($”{base.Name} finished learning”)，即已有对象的方法）前增加若干方法，在主逻辑后也增加若干方法时：</p><ul><li><p>在编写装饰器时时，对于主逻辑之前要执行的方法应按上述（1）来编写装饰器；而对于主逻辑之后要执行的方法应按上述（2）来编写装饰器。</p></li><li><p>在注册时，对于主逻辑之前要执行的方法要逆序注册；对于主逻辑之后要执行的方法要顺序注册</p></li></ul></li></ul><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>  观察者模式较其他设计模式来说要更难以理解，相要真正理解还是得自己敲一下代码，断点运行一下。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-观察者模式</title>
      <link href="2019/06/27/Observer%20Pattern/"/>
      <url>2019/06/27/Observer%20Pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之观察者模式"><a href="#设计模式之观察者模式" class="headerlink" title="设计模式之观察者模式"></a>设计模式之观察者模式</h1><a id="more"></a><h2 id="什么是观察者模式"><a href="#什么是观察者模式" class="headerlink" title="什么是观察者模式"></a><strong>什么是观察者模式</strong></h2><p>形象的来说，观察者模式包含一个被观察者（subject）以及若干观察者（observer），observer观察subject，当subject发出一个动作时，observer观察到后作出相应反应。在程序中则是某个类（subject）达到某种触发条件后向其他类发送通知（通常是执行某些方法的信息），然后这些类执行相应的方法。</p><h2 id="观察者模式的作用"><a href="#观察者模式的作用" class="headerlink" title="观察者模式的作用"></a><strong>观察者模式的作用</strong></h2><ol><li>用于程序的解耦。观察者模式通过依赖于抽象的接口来减少类与类之间的直接依赖。</li><li>可以作为一种通知的机制，将更新通知给其它的对象。</li></ol><h2 id="观察者模式的缺点"><a href="#观察者模式的缺点" class="headerlink" title="观察者模式的缺点"></a><strong>观察者模式的缺点</strong></h2><ul><li>当一个被观察者有很多的直接或间接的观察者时，要通知到所有的观察者需要耗费很多的时间。</li><li>当被观察者之间循环依赖时（比如：A通知B改变C，C的改变引起A的改变，继而又触发了A通知B），程序会进入循环调用，导致系统崩溃。</li></ul><h2 id="观察者模式的实现要点"><a href="#观察者模式的实现要点" class="headerlink" title="观察者模式的实现要点"></a><strong>观察者模式的实现要点</strong></h2><ol><li>要创建一个接口用以约束所有被观察者，提供消息传递的通道</li><li>被观察者需要有一个存放消息的容器，一般是接口的一个列表；同时被观察者要具有订阅观察者和取消订阅的方法，用以动态的增加减少观察者的数量。</li><li>实现消息的传递——通过调用接口列表中的各个方法。</li></ol><p>代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"> class Program</span><br><span class="line">    {</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">            Cat cat = new Cat();</span><br><span class="line">            cat.Add(new Dog());</span><br><span class="line">            cat.Add(new Duck());</span><br><span class="line">            cat.Add(new mouse());           </span><br><span class="line">            cat.Add(new people());</span><br><span class="line">            cat.Miao();</span><br><span class="line">            Console.Read();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">interface Ioberver</span><br><span class="line">{</span><br><span class="line">        void Action();</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line">class Chicken:Ioberver</span><br><span class="line">    {</span><br><span class="line">        public void Action()</span><br><span class="line">        {</span><br><span class="line">            this.Woo();</span><br><span class="line">        }</span><br><span class="line">        public void Woo()</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine("{0} Woo", this.GetType().Name);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">class Dog : Ioberver</span><br><span class="line">    {</span><br><span class="line">        public void Action()</span><br><span class="line">        {</span><br><span class="line">            this.Wang();</span><br><span class="line">        }</span><br><span class="line">        public void Wang()</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine($"{this.GetType().Name} 汪汪汪");</span><br><span class="line">        }</span><br><span class="line">    }  </span><br><span class="line"></span><br><span class="line">class Duck : Ioberver</span><br><span class="line">    {</span><br><span class="line">        public void Action()</span><br><span class="line">        {</span><br><span class="line">            this.Gaga();</span><br><span class="line">        }</span><br><span class="line">        public void Gaga()</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine($"{this.GetType().Name} 嘎嘎嘎");</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"> class mouse : Ioberver</span><br><span class="line">    {</span><br><span class="line">        public void Action()</span><br><span class="line">        {</span><br><span class="line">            this.Zhi();</span><br><span class="line">        }</span><br><span class="line">        public void Zhi()</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine($"{this.GetType().Name} 吱吱吱");</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Cat</span><br><span class="line">{</span><br><span class="line">        public void Miao()</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine("{0} miao",this.GetType().Name);</span><br><span class="line">            if(this._ObserverList!=null &amp;&amp; this._ObserverList.Count &gt; 0)</span><br><span class="line">            {</span><br><span class="line">                foreach (var observer in _ObserverList)</span><br><span class="line">                {</span><br><span class="line">                    observer.Action();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        public List&lt;Ioberver&gt; _ObserverList = new List&lt;Ioberver&gt;();</span><br><span class="line">        public void Add(Ioberver observer)</span><br><span class="line">        {</span><br><span class="line">            this._ObserverList.Add(observer);</span><br><span class="line">        }</span><br><span class="line">        public void Remove(Ioberver observer)</span><br><span class="line">        {</span><br><span class="line">            this._ObserverList.Remove(observer);</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><p><a href="http://src.zhumingcj.cn/blog/20190627/Pwc2H0fM3pGs.png?imageslim" target="_blank" rel="noopener"><img src="http://src.zhumingcj.cn/blog/20190627/Pwc2H0fM3pGs.png?imageslim" alt="mark"></a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShortCut Key for Typora</title>
      <link href="2019/06/21/Tips%20for%20Typora/"/>
      <url>2019/06/21/Tips%20for%20Typora/</url>
      
        <content type="html"><![CDATA[<p>刚建立了自己的博客，来发一篇文章<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8">😃</span></p><p>最近刚学会使用Typora，刚好把一些快捷键整理一下。</p><a id="more"></a><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><ol><li><p>标题    ctrl+1/2/3…</p><p>数字表示标题的级数 </p></li><li><p>下划线    ctrl+u</p><p>效果：<u>这是下划线</u></p></li><li><p>删除线    shift+alt+5</p><p>效果：<del>这是删除线</del></p></li><li><p>字体加粗    ctrl+b</p><p>效果：<strong>加粗了</strong></p></li><li><p>字体倾斜   ctrl+i</p><p>效果：<em>倾斜的字</em></p></li><li><p>无序列表   -+space+内容</p><p>效果  </p><ul><li>牛奶</li><li>面包<ul><li>巧克力（可嵌套）</li></ul></li></ul></li><li><p>引用   &gt;+space或ctrl+shift+q</p><blockquote><p>效果：这是引用</p></blockquote></li><li><p>插入地址   ctrl+k</p><p><a href="www.baidu.com">百度</a></p></li><li><p>插入表格   ctrl+t</p><p>效果：</p></li></ol><div class="table-container"><table><thead><tr><th>周一</th><th>周二</th><th>周三</th><th>周四</th><th>周五</th></tr></thead><tbody><tr><td>微积分</td><td>放假</td><td>放假</td><td>放假</td><td>放假</td></tr><tr><td>大学物理</td><td>放假</td><td>放假</td><td>放假</td><td>放假</td></tr><tr><td>英语</td><td>放假</td><td>放假</td><td>放假</td><td>放假</td></tr></tbody></table></div><ol><li><p>回到文章顶部   ctrl+home</p><p>效果：无法展示<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span></p></li><li><p>自动产生目录   [TOC]+enter</p><p>效果：(只有一个标题，将就看一下效果)</p><p>[TOC]</p></li><li><p>选中一整行   ctrl+l</p><p>额，无法展示效果</p></li><li><p>插入代码块   ctrl+alt+b(可能需要自己设置)</p><p>效果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Diagnostics;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">public static void main(string[]args){</span><br><span class="line">    ConSole.WriteLine("Hello World");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><ol><li><p>搜索内容   ctrl+f    替换   ctrl+h</p><p>效果：无</p></li><li><p>强调、着重标记   ctrl+shift+~(tab上面那个)</p><p>效果：<code>这是重点 这是重点 则是重点</code></p></li><li><p>分隔线   —-+enter或<em>*</em>+enter</p><p>效果：</p><hr></li></ol><ol><li><p>数学公式   $$+enter</p><p>效果：</p><script type="math/tex; mode=display">|i j k |a+b+c^5=2ab</script></li><li><p>表情   :+表情的英文单词</p><p>效果：<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f6f0.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f6f0.png?v8">🛰</span></p></li><li><p>快速创建新文件   ctrl +n    快速关闭  ctrl+w</p></li><li><p>显示/隐藏大纲   ctrl+shift+l</p></li><li><p>高亮   == 文字 ==（中间没有空格）</p></li><li><p>标题变为普通文本   ctrl+0</p></li><li><p>脚注   <sup><a href="#fn_" id="reffn_"></a></sup></p><p>效果：这是一个脚注<sup><a href="#fn_1" id="reffn_1">1</a></sup></p></li><li><p>行内数学公式   $+esc(然后输入Tex命令)</p></li></ol><p>$\lim_{x\to\infty}\exp(-x)=0$</p><ol><li><p>上下标   <code>x^2^2</code>   <code>H~2~O</code></p><p>效果：x^2^   H~2~O</p></li></ol><blockquote id="fn_1"><sup>1</sup>. 注释<a href="#reffn_1" title="Jump back to footnote [1] in the text."> ↩</a></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文本编辑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my first blog</title>
      <link href="2019/06/21/my-first-blog/"/>
      <url>2019/06/21/my-first-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="这是我的第一篇blog"><a href="#这是我的第一篇blog" class="headerlink" title="这是我的第一篇blog"></a>这是我的第一篇blog</h1><h2 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h2><p>终于成功了很开心</p><p>:happy:</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
