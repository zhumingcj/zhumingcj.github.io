[{"title":"Improved Square Method","date":"2019-07-08T13:56:00.000Z","text":"改进平方根法和追赶法虽然平方根法的时间复杂度远远低于高斯消元法和lU分解，但是n个开方运算会耗费很多的时间，所以为了避免开放运算，需要对平方根法进行改进。 追赶法则是求解严格对角占优矩阵效率最高的算法之一。 改进平方根法公式推导为了避免开方运算，我们使用$A=LDL^{T}$导出分解公式 由\\\\ A=LU=LDD^{-1}U=LDL^{T}\\\\ 可知L^{T}=D^{-1}U,因此\\\\ l_{i,j}=\\frac{u_{ij}}{d_{i}}=\\frac{u_{ij}}{u_{ii}},\\quad i=1,2,\\dots,n-1;j=i+1,i+2,\\dots,n\\\\ 由杜立特尔分解可知\\\\ u_{ij}=a_{ij}-\\sum_{k=1}^{i-1}l_{ik}u_{kj},\\quad i=1,2,\\dots,n;j=i,i+1,\\dots,n\\\\ \\Rightarrow l_{ij}=\\frac{a_{ij}-\\sum_{k=1}^{i-1}l_{ik}u_{kj}}{u_{ii}},\\quad i=1,2,\\dots,n-1;j=i+1,i+2,\\dots,n用$A=LDL^{T}$分解求解方程组Ax=b就是改进平方根法，下面导出计算公式 Ax=b \\Rightarrow LDL^{T}\\Rightarrow \\left\\{ \\begin{array}\\ Ly=b\\\\ Dz=y\\\\ L^{T}x=z \\end{array} \\right.\\\\ 由Ly=b可得\\\\ y_{1}=b_{1}\\\\ y_{i}=b_{i}-\\sum_{k=1}^{i-1}l_{ik}y_{k},\\quad i=2,3,\\dots,n\\\\ 由Dz=y可得\\\\ z_{i}=\\frac{y_{i}}{u_{ii}},\\quad i=1,2,\\dots,n\\\\ 由L^{T}x=z可得\\\\ \\left\\{ \\begin{array}\\ x_{n}=z_{n}\\\\ x_{i}=z_{i}-\\sum_{i+1}^{n}l_{ki}x_{k},\\quad i=n-1,n-2,\\dots,1 \\end{array} \\right.\\\\ 将z_{i}和l_{ki}=\\frac{u_{ik}}{u_{ii}}代入x_{i}的表达式，可得\\\\ \\left\\{ \\begin{array}\\ x_{n}=\\frac{y_{n}}{u_{nn}}\\\\ x_{i}=\\frac{y_{i}-\\sum_{k=i+1}^{n}u_{ik}x_{k}}{u_{ii}},\\quad i=n-1,n-2,\\dots,2,1 \\end{array} \\right.改进平方根法的算法分析采用改进平方根法求解Ax=b共用了乘除法$\\frac{1}{6}n^{3}+\\frac{3}{2}n^{2}-\\frac{2}{3}n$个，它比平方根法多了$\\frac{1}{2}n^{2}-\\frac{1}{2}n$个乘除法，但是少了n个开方运算，而相比于高斯消元法和杜立特尔分解几乎少了一半的乘除法，因此改进平方根法为求解对称正定方程组最有效的方法之一。实际上改进平方根法的分解公式和lU分解的分解公式是相同的，但是LU分解还要计算U矩阵，因此效率比较低，而改进平方根法则利用正定对称矩阵的特点，使得只需要计算L矩阵，大大减少了计算量，提高了效率。 追赶法的分解公式在样条插值、常微分方程边值问题和热传导方程的有限差分法等问题中，常遇到求解三对角方程组Ax=b,即 \\begin{pmatrix} b_{1}&c_{1}&\\\\ a_{2}&b_{2}&c_{2}\\\\ &\\ddots&\\ddots&\\ddots\\\\ &&a_{n-1}&b_{n-1}&c_{n-1}\\\\ &&&a_{n}&b_{n} \\end{pmatrix} \\begin{pmatrix} x_{1}\\\\ x_{2}\\\\ \\vdots\\\\ x_{n-1}\\\\ x_{n} \\end{pmatrix} = \\begin{pmatrix} d_{1}\\\\ d_{2}\\\\ \\vdots\\\\ d_{n-1}\\\\ d_{n} \\end{pmatrix}通常A是严格对角占优矩阵，严格对角占优矩阵存在唯一 的杜立特分解，形式如下 A=LU= \\begin{pmatrix} 1\\\\ l_{2}&1\\\\ &\\ddots&\\ddots\\\\ &&l_{n-1}&1\\\\ &&&l_{n}&1 \\end{pmatrix} \\begin{pmatrix} u_{1}&c_{1}\\\\ &u_{2}&c_{2}\\\\ &&\\ddots&\\ddots\\\\ &&&u_{n-1}&c_{n-1}\\\\ &&&&u_{n} \\end{pmatrix}根据矩阵乘法，我们可以导出分解公式如下 \\left\\{ \\begin{array}\\ u_{1}=b_{1}\\\\ l_{i}=\\frac{a_{i}}{u_{i-1}},\\quad i=2,3,\\dots,n\\\\ u_{i}=b_{i}-l_{i}c_{i-1},\\quad i=2,3,\\dots,n \\end{array} \\right.追赶法求解Ax=d的计算公式 Ax=d \\Rightarrow LUx=d\\Rightarrow \\\\ \\left\\{ \\begin{array}\\ Ly=d\\\\ Ux=y \\end{array} \\right. \\quad\\\\ 由Ly=d可得\\\\ \\left\\{ \\begin{array}\\ y_{1}=d_{1}\\\\ y_{i}=d_{i}-l_{i}y_{i-1},\\quad i=2,3,\\dots,n \\end{array} \\right. \\quad\\\\ 由Ux=y可得\\\\ \\left\\{ \\begin{array}\\ x_{n}=\\frac{y_{n}}{u_{n}}\\\\ x_{i}=\\frac{y_{i}-c_{i}x_{i+1}}{u_{i}},\\quad i=n-1,n-2,\\dots,1 \\end{array} \\right.追赶法的一个分解示例 A= \\begin{pmatrix} 1&2&0&0&0\\\\ 2&3&1&0&0\\\\ 0&-3&4&2&0\\\\ 0&0&4&7&1\\\\ 0&0&0&-5&6 \\end{pmatrix}\\\\ \\quad\\\\分解结果如下 追赶法的算法分析用追赶法来解线性方程的乘除法运算次数仅为5n-4,比高斯消元法的运算次数少得多。并且由于方程组的系数矩阵是严格对角占优的，因此能保证追赶法顺利进行，并且计算过程稳定。","link":"","permalink":"http://zhumingcj.github.io/2019/07/08/improved-square-method/","tags":[{"name":"Numerical Analysis","slug":"numerical-analysis","permalink":"http://zhumingcj.github.io/tags/numerical-analysis/"}]},{"title":"Square Root Method","date":"2019-07-06T07:36:28.000Z","text":"平方根法在有限元法求解结构力学和最优化方法等诸多问题中，都需要求解一个系数矩阵是正定的线性方程组Ax=b。针对这种方程组的特点，采用平方根法更加有效。所谓平方根法是将系数矩阵分解为一个下三角形矩阵和该矩阵的转置的乘积，然后在此基础上求解方程。 引理 若矩阵的各阶顺序主子式都不为零，则矩阵可以进行LU分解（1），且矩阵的LU分解唯一。现对（2）进行证明 设 \\quad\\quad\\quad\\quad A=LU \\quad\\\\ 且\\quad\\quad\\quad\\quad A=L_{1}U_{1}\\\\ 则 \\quad\\quad\\quad\\quad L_{1}^{-1}AU^{-1}=L_{1}^{-1}L \\quad\\quad\\\\ \\quad\\quad\\quad L_{1}^{-1}AU^{-1}=U_{1}U^{-1}\\\\ 即 \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad L_{1}^{-1}L=U_{1}U^{-1}\\\\ \\quad\\\\ 因为 L_{1}^{-1}L为下单位三角矩阵，而U_{1}U^{-1}为上单位三角矩阵\\\\所以L_{1}^{-1}L=U_{1}U^{-1}=I A为对称矩阵，当A的各阶顺序主子式都不等于零时，A可以唯一的分解为 ​ $A=LDL^{T}$ 现证明之 根据引理（1），A=LU，记D=diag(d_{1},d_{2},d_{3},\\dots,d_{n})=diag(u_{11},u_{22},\\dots,u_{nn})\\\\ 则 \\quad A=LU=LDD^{-1}U=LDM^{T},其中M^{T}=D^{-1}U\\\\ 又 \\quad A=A^{T}=MDL^{T}\\\\ 因为M为下三角矩阵，而DL^{T}为上三角矩阵，所以MDL^{T}也是A的一个LU分解\\\\ 由LU分解的唯一性可得=>L=M\\\\ 所以 \\quad A=MDL^{T}=LDL^{T} 平方根法重要定理 (对称正定矩阵的楚列斯基分解)设A是n阶对称正定矩阵，则存在一个可逆下三角矩阵G，使得 ​ $A=GG^{T}$ 且当限定G的对角元为正时，这种分解是唯一的。 证明： 由线性代数可知，正定矩阵的各阶顺序主子式都大于零，由上面的引理2可得\\\\ A=LDL^{T},且可证明D的对角元都大于零\\\\ \\forall x\\not=0 ,\\quad 0","link":"","permalink":"http://zhumingcj.github.io/2019/07/06/square-root-method-and-improved-square-root-method/","tags":[{"name":"Matrix","slug":"matrix","permalink":"http://zhumingcj.github.io/tags/matrix/"}]},{"title":"Web Basic Skills","date":"2019-07-05T08:15:57.000Z","text":"HTML(HyperText Markup Language)、CSS和Javascript​ 对于一个网页而言，主要由 HTML、CSS和Javascript组成。其中HTML主要负责网页框架的搭建，CSS主要负责网页的样式而JavaScript主要负责网页的行为。 常用的HTML标签 &lt;html&gt;&lt;/html&gt; 这个标签没什么用，但是所有HTML标签都需要写在这个标签内部 &lt;head&gt;&lt;/head&gt; head标签是用来写一些给浏览器看的内容，包括网站名，网站描述等 head内部常用的标签 meta标签 1234&lt;meta charset=\"utf-8\"&gt; &lt;!--申明网页的编码格式--&gt;&lt;!--utf-8为编码字符集--&gt;&lt;meta name=\"keywords\" content=\"xx\"&gt;&lt;!--描述网页的类别，给网络爬虫看的信息--&gt;&lt;meta name=\"description\" content=\"xx\"&gt;&lt;!--对网页的描述，也是给爬虫看的信息--&gt; 常用的字符编码有： - gb2312(包括亚裔字符集) - gbk(在gb2312基础上增加了繁体中文) - unicode(万国码)title标签 title标签 1&lt;title&gt; 这里可以写标题（浏览器上方显示的）&lt;/title&gt; body标签 123&lt;body&gt; 这里是网页的主体&lt;/body&gt; body内常用的标签 p标签 123&lt;p&gt;这是一个段落，常用来换行&lt;/p&gt; h标签 123&lt;h1&gt;这是一个标题&lt;/h1&gt;&lt;h2&gt;这也是一个标题&lt;/h2&gt;&lt;!--最多到h5--&gt; strong标签 1&lt;strong&gt;加粗&lt;/strong&gt; em标签 1&lt;em&gt;斜体&lt;/em&gt; del标签 1&lt;del&gt;中划线，效果参考打折的价格&lt;/del&gt; div标签 1&lt;div&gt;只是一个容器，无具体功能，有利于模块化和绑定操作&lt;/div&gt; sapn标签 1&lt;span&gt;这也是一个容器&lt;/span&gt; a标签 123&lt;a herf=\"www.baidu.com\" target=\"_blank\"&gt;这是超链接锚点，最初的作用为&lt;/a&gt;&lt;!--target的值决定是在当前页面打开链接还是在新的页面中打开页面--&gt;&lt;!--herf的值除了URL还可以是tel(打电话)和mailto(发邮件),还可以是JavaScript（协议限定符，此标识后可写java代码，用户点击时会强行运行）--&gt; br标签 1&lt;br&gt;换行&lt;/br&gt; hr标签 1&lt;hr&gt;这是水平线&lt;/hr&gt; ol和li标签 12345678&lt;ol type=\"a\" start=\"value\"&gt;&lt;1--value的值决定最开始的序号值--&gt;&lt;!--type的值不同，列表的样式不同,1&gt;=序号为阿拉伯数字;I/i&gt;=序号为小写/大写罗马数字;A/a=&gt;序号为大小写英文字母--&gt; &lt;li&gt;这是一个有序列表，ol和li是一起使用的&lt;/li&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;橘子&lt;/li&gt; &lt;li&gt;樱桃&lt;/li&gt;&lt;/ol&gt; ul和li标签 12345678&lt;ul type=\"disc\"&gt;&lt;!--type的值决定无序列表的样式，具体不做叙述--&gt; &lt;li&gt;这是无序列表&lt;/li&gt; &lt;li&gt;圆&lt;/li&gt; &lt;li&gt;正方形&lt;/li&gt; &lt;li&gt;三角形&lt;/li&gt; &lt;li&gt;矩形&lt;/li&gt;&lt;/ul&gt; 注：ui和li常用来做导航栏，菜单栏等功能和形式差不多，天生具有父子结构的对象 img标签 1234&lt;img src=\"图片的相对地址或绝对地址\" alt=\"图片的摘要\" title=\"图片的描述\"&gt;&lt;!--当网页文件和图片处于同一个文件夹下时，可以使用相对地址，更加简单；否则使用绝对地址才能正常加载图片--&gt;&lt;!--Alt的值是当图片无法正常加载时显示 在图片上的信息，用来改善用户体验--&gt;&lt;!--title的值是用户的鼠标放在图片上时会显示的信息--&gt; form标签 123456789101112131415161718&lt;form method=\"get/post\" action=\"发送信息的地址\"&gt; &lt;input type=\"text\" name=\"username\"&gt;&lt;!--这文本输入框--&gt; &lt;input type=\"password\" name=\"password\"&gt;&lt;!--这密码框--&gt; &lt;input type=\"submit\"&gt;&lt;!--这是提交按钮--&gt; &lt;input type=\"radio\" name=\"xx\"&gt;&lt;!--这是当选框,只有当数个单选框的name值相同时，才会发挥单选的功能--&gt; &lt;input type=\"radio\" name=\"xx\"&gt; &lt;input type=\"radio\" name=\"xx\"&gt; &lt;input type=\"checkbox\" name=\"xxx\"&gt;&lt;!--这是复选框,只有当数个复选框的name值相同时，才会正常发挥复选的功能--&gt; &lt;input type=\"checkbox\" name=\"xxx\"&gt; &lt;input type=\"checkbox\" name=\"xxx\"&gt; &lt;select&gt; &lt;option&gt;北京&lt;/option&gt;&lt;!--这是一个下拉框--&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option&gt;天津&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;!--想要正确提交信息，必须要有name和value--&gt;&lt;/form&gt;复 标签的归类 行级元素 feature： 内容决定元素所占位置 不可以通过css改变宽高 常见的有： span strong em a del 块级元素 feature： 独占一行 可以通过css代码改变宽高 常见的有： div p ul li ol form address 行级块元素 feature: 内容决定大小 可以通过css改宽高 标签类型的实质： 都是css特性的表现——对象都有一个display的css属性，display有三个属性值=&gt; inline (行级) 2.block (块级) 3.inline-block (行级块元素) 所以标签的类型不是固定的，可以通过css代码来更改；此外，所有属性为inline的对象都具有文字特性，即空格会被视为文本分隔符即如果inline对象之间有空格/空行就会间隔一定距离。 HTML补充 HTML语言中没有空格标签，所有空格都是文本分隔符，如果想要输入空格需输入&amp;nbsp，此外，其它特殊字符还有 &lt; &amp;lt &gt; &amp;gt HTML标签是可以嵌套的，通过嵌套可以实现各种不同的功能。 html还有很多复杂的标签，但是基本上很少用，因为网络编程要求结构和样式和行为相分离，那些复杂的标签多为带有样式的标签。 CSS代码CSS代码引入的方式 行间样式（内联），如 12345&lt;div style=\"width: 100px;height: 100px;background-color: #f40\"&gt;&lt;/div&gt; 页面级CSS，如 1234567&lt;style type=\"text/css\"&gt; div&#123; width: 100px; height: 100px; background-color: #f40; &#125; &lt;/style&gt; 外部CSS文件（最常用），如 12345678div&#123; border:1px solid black;text-align: right; text-indent: 2em; cursor: ; text-decoration: line-through;&#125; 但是，外部CSS文件要能作用到HTML文件上，需要在HTML文件的head中加入如下代码 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"CSS文件地址\"&gt; 浏览器的策略 浏览器从服务器下载HTML文件时，采取下载一行执行一行的形式 当执行到link CSS的代码时，浏览器会开启一个新的线程来同时下载CSS和HTML文件 在执行复杂选择器时，浏览器采用从右向左的方式，可以提高搜索的效率 CSS选择器 Id选择器 1234#only&#123; background-color: #ff3058&#125;/*首先要求对象具有ID，ID是一对一唯一的标识，其中only为ID值*/ class选择器 1234.typeone&#123; background-color: #345564&#125;/*对象应具有class，且class不唯一，其中typeone为class值*/ 标签选择器 1234div&#123; background-color: #634432&#125;/*标签选择器会选中所有该类标签*/ 通配符选择器 1234*&#123; background-color: #243543;&#125;/*此选择器会作用到全局*/ 属性选择器，如 1234567[id]&#123; background-color: #f84;&#125;/*也可以指定属性值*/[id=\"only\"]&#123; background-color: #f84;&#125; ！important 1234#only&#123; background-color: #ff3058!important&#125;/*加上！important后，此选择器优先级最高*/ 父子选择器 1234567div span&#123; background-color: #567889;&#125;#demo1 .typeone span&#123; background-color: #678980;&#125;/*可以用来限定目标，可以套很多层，且形式不一定要一样*/ 直接子元素选择器 1234div &gt; span&#123; background-color: #779&#125;/*只会作用于字节的子类*/ 并列选择器 1234div.demo1&#123; background-color: #655;&#125;/*可以用多个选择器不加空格的组合到一起，可涮选出符合所有条件的对象*/ 分组选择器 1234567em.demo1,strong #only,div&#123; background-color: #658;&#125;/*可以实现代码的复用，把具有同样样式的选择器用逗号隔开，则可作用于所有对象*/ 伪类选择器 1234a:hover&#123; background-color: orange;&#125;/*当鼠标移动到对象的领域之内时，为对象加上相应的样式，当鼠标移开后，则会移除相应的样式*/ CSS选择器的优先级和权值 优先级 ！important&gt;行间样式&gt;ID&gt;class|属性&gt;标签选择器&gt;* CSS选择器的权值 ！important infinity 行间样式 1000 ID 100 class|属性|伪类 10 标签|伪元素 1 通配符 0 CSS权重用于选择器优先级的比较，多重选择器嵌套可以将权重相加，且权重的值不为十进制而是256进制！！！ CSS代码常用属性 font-size: 50px; 设置字体的大小（实际设置字体的高） font-weight: bold; 设置字体的粗细 font-style: italic; 斜体 font-family: arial; 设置字体样式 color: #424; 设置字体颜色 border: 1px solid black; 设置外边框的粗细、样式（直线，虚线等）和颜色 width: 100px; 设置宽 height: 100px; 设置高 text-align: right; 设置文本对齐方式（左对齐，右对齐，居中） line-height: 20px; 单行字体行高，用以控制行间距 text-indent: 2em; 设置缩进，单位是em（当前每个字体的像素大小） text-decoration: line-through; 对字体进行装饰，值不同样式不同（下划线，中划线，上划线等） cursor: pointer; 设置鼠标聚焦时鼠标样式的变化 字体颜色的三种形式 纯英文单词 12color: green;color: blue; 颜色代码 123color: #ff4400;color: #768798;color: #ff3; 颜色函数 12color: rgb(3,35,234);color: rgb(32,43,255); 注：颜色代码是由光学三原色混合而成的（r[00-ff];g[00-ff];b[]00-ff）,所以需要六位的值来确定颜色，但是如果每两位都是一样的，则可以进行简写，即每两位并成一位；而颜色函数也是由光学三颜色合成的，但是只需要三个参数，每一位的范围是0-255.实际上颜色代码和颜色函数是等价的，只是颜色函数只是把两位十六进制数组成256进制位。","link":"","permalink":"http://zhumingcj.github.io/2019/07/05/HTML Basic Skills/","tags":[{"name":"HTML","slug":"html","permalink":"http://zhumingcj.github.io/tags/html/"}]},{"title":"https protocol","date":"2019-07-04T12:35:04.000Z","text":"https协议详析当我们使用浏览器时可能会发现我们输入的网站有以http和以https开头的，它们的区别在于哪里呢？实际上，可以说https是http的升级版，是对其安全性的加强。 浏览器的一般工作流程 当用户输入要访问的URL后，浏览器会根据URL解析出其域名 通过DNS服务器查询出域名映射的IP地址 根据查询到的IP地址与web服务器建立通讯 上述过程可以抽象为下图 TCP/IP协议http协议是构建在TCP/IP协议的基础上的，所以我们有必要了解Tcp/Ip相关的知识。 TCP/IP协议的分层模型TCP/IP协议是由四层协议组成的系统，这四层分别为：应用层、传输层、网络层、链路层，如下图所示 应用层 应用层是我们编写的应用程序，它决定了向用户提供的应用服务。应用层可通过系统调用与传输层通讯。 处于应用层的协议非常多，比如：FTP(File Transfer Protocol，文件传输协议)、DNS(Domain Name System,域名系统)以及HTTP(HyperText Transfer Protocol,超文本传输协议)等。 传输层 传输层通过系统调用向应用层提供两台计算机之间的数据传输功能。 在传输层有两个性质不同的协议：TCP(Transmission Control Protocol,传输控制协议)和UDP(User Data Protocol,用户数据协议)。其中TCP在数据传输的安全性上高于UDP，但是其传输速度比较慢，所以一般快速下载软件都是用UDP,比如迅雷。 网络层 网络层用来处理网络上流动的数据包，归顶数据包的传输路径。 链路层 链路层是用来处理连接网络的硬件部分，包括操作系统、硬件设备驱动、NIC(Network Interface Card,网络适配器)以及光纤等硬件。 TCP协议TCP协议是全双工的字节流传输，具有可靠性高的特点，为了确保其可靠性，TCP协议采用了”三次握手“的策略，如下图 在图中，我们可以看到： 首先客户端会向服务器发送一个带有SYN标志的连接请求 服务器接收到请求会作出应答，如果能接受连接，这服务器发送ACK进行确认，并且还会发送自己的SYN请求 客户端接受到SYN和ACK后，在向服务器发送ACK确认接受连接 三次握手完毕后会在客户端和服务器之间建立双向通信 为了维持TCP协议，在数据传输的过程中，接收端在接收端数据后都要给发送端发送ACK进行确认。若发送端在一定时间内没有接受到ACK确认，则会重发丢失的数据包 HTTP协议简介HTTP协议（Hyper Text Transfer Protocol，超文本传输协议）,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP基于TCP/IP通信协议来传递数据。 HTTP基于客户端/服务端（C/S）架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。 特点（1）HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 （2）HTTP是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 （3）HTTP是无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP协议的不足 HTTP协议采用明文通讯，内容很有可能被窃听 无法验证对方身份，任何第三方可以通过伪装与服务器通讯 无法确定数据的可靠性，在传输中可能会被篡改 HTTPs协议为了解决HTTP存在的问题，HTTPs应运而生，HTTPs采用SSL/TLS协议对传输的数据进行加密，保证了传输不被窃听；同时通过CA(由第三方权威机构颁发)证书验证通信双方的身份。 有关CA证书CA证书是公司向权威机构申请，由权威机构颁发的。CA证书会被安装到服务器上，其中内容包括： 持有者姓名 发证机关 有效日期 证件持有人的公钥 扩展信息 发证机关对该证书的数字签名（=前5点信息的MD5摘要，然后用CA的私钥加密） HTTPs的通信原理 客户端信任发证机关的证书，一般用户不需要操作。因为CA（权威）[下面简称为CAA]证书存储在浏览器中，而浏览器一般自动信任了大多数的权威机构证书。 在请求建立的过程中，首先客户端会向服务器发送一次请求，服务器向客户端返回一个CA（公司服务器）证书[后简称CAS] 客户端根据得到的CAS证书读得发证机关的信息，找到内置的对于机关的CAA证书，从证书中找到机关的加密公钥，用公钥（解密钥）对得到的CAS证书的第六点信息进行解密，如果解得的信息与CAS证书前五点摘要的MD5相同，则说明服务器的CAS证书确为该机构颁布的，进而证明了服务器的身份 客户端再用CAS中得到的服务器的公钥（加密钥）加密一个信息比如“123”发送给服务器，服务器则根据其持有的私钥（解密钥）对信息进行解密，然后服务器把解密结果返回给客户端，若解密得到的信息与发送信息一致，则可证明该服务器就是客户端要访问的服务器。这样可防止因域名写错而造成的错误访问。 然后客户端会向服务器发送一条信息用以约定通信过程中的对称加密钥，然后即可在双方之间建立通信，以后的通信中发送端会用该对称加密钥对传输数据进行加密，而接收端也用该对称秘钥进行解密。这样就可以防止信息被窃听。 通信流程图如下","link":"","permalink":"http://zhumingcj.github.io/2019/07/04/https-protocol/","tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://zhumingcj.github.io/tags/网络协议/"}]},{"title":"Usage of Trigonometric Decomposition","date":"2019-07-03T00:38:07.000Z","text":"三角分解解线性方程组相比于高斯消元法，应用三角分解来解线性方程组在某些情况下能提高计算的效率。 三角分解解线性方程的公式推导即，我们要解 LUx=b, 我们把这个方程拆为两个方程来解 \\left\\{ \\begin{array}\\ Ly=b\\\\ Ux=y \\end{array} \\right.解方程组Ly=b的第一个方程为$y_{1}=b_{1}$，而第i个方程为 \\sum_{j=1}^{i-1}(l_{ij}y_{ij}+y_{i}=b_{i})\\Longrightarrow\\\\ \\left\\{ \\begin{array}\\ y_{1}=b_{1},\\\\ y_{i}=b_{i}-\\sum_{j=1}^{i-1}l_{ij}y_{j},\\quad i=1,2,3,\\dots,n \\end{array} \\right.将解得的y代入Ux=y，由高斯消元法回代公式可得 \\left\\{ \\begin{array}\\ x_{n}=\\frac{y_{n}}{u_{nn}},\\\\ x_{i}=\\frac{y_{i}-\\sum_{j=i+1}^{n}u_{ij}x_{j}}{u_{ii}},\\quad i=n-1,n-2,\\dots,2,1 \\end{array} \\right. 一个LU分解的例子 A= \\begin{pmatrix} 9&18&9&-27\\\\ 18&45&0&-45\\\\ 9&0&126&9\\\\ -27&-45&9&135 \\end{pmatrix} \\quad\\quad\\quad\\quad\\quad\\quad b= \\begin{pmatrix} 1\\\\ 2\\\\ 16\\\\ 8 \\end{pmatrix}现在对A进行分解 即可得 L= \\begin{pmatrix} 1&\\\\ 2&1&\\\\ 1&-2&1\\\\ -3&1&\\frac{2}{3}&1 \\end{pmatrix} \\quad\\quad U= \\begin{pmatrix} 9&18&9&-27\\\\ 0&9&-18&9\\\\ 0&0&81&54\\\\ 0&0&0&9 \\end{pmatrix}\\\\ \\quad\\\\ \\quad\\\\ y= \\begin{pmatrix} 1\\\\0\\\\15\\\\1 \\end{pmatrix}LU分解解线性方程组的算法分析由矩阵LU分解公式可知，计算$u_{ij}$和$l_{ij}$各有 ​ $\\sum_{j=2}^{n-1}(j(n-j)+n-1=\\sum_{1}^{n-1}j(n-j)=1/6n^{3}-1/6n$ 个乘除法，所以矩阵分解共有$1/3n^3-1/3n$个乘除法，而求解下三角方程Ly=b有$1/2n(n-1)$个乘除法，求解上三角方程Ux=y有$1/2n(n-1)+n$个乘除法，综上，用LU分解来解线性方程组共有$\\frac{1}{3}n^{2}+n^{2}-\\frac{1}{3}n$个乘除法，与高斯消元法的运算次数一样。 但是从LU分解的形式上看，不难发现如果我们要解一系列系数矩阵相同但右端不同的方程组时，LU分解可以大大减少计算量。 编程实现LU分解 程序如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Trigonometric_Decomposition&#123; class Program &#123; static void Main(string[] args) &#123; Matrix m= new Matrix(6, 6); m.LuDecomposition(); m.DisPlay(); Console.Read(); &#125; class Matrix &#123; public int row = 0; public int column = 0; private float[,] matrix; \\\\矩阵的输入 public Matrix(int row, int column) &#123; this.row = row; this.column = column; Console.WriteLine($\"Please enter a matrix with &#123;this.row&#125;rows,&#123;this.column&#125;colums\"); matrix = new float[row, column]; try &#123; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; column; j++) &#123; string mid = Console.ReadLine(); var rows = mid.Split(' '); foreach (var item in rows) &#123; matrix[i, j++] = float.Parse(item); &#125; &#125; &#125; Console.WriteLine(\"\\r\\n\"); &#125; catch (Exception e) &#123; Console.WriteLine($\"something wrong!\\n&#123;e.Message&#125;\"); &#125; &#125; \\\\输出矩阵 public void DisPlay() &#123; for (int i = 0; i &lt; this.row; i++) &#123; for (int j = 0; j &lt; this.column; j++) &#123; Console.Write(matrix[i, j] + \" \"); &#125; Console.WriteLine(\"\\r\"); &#125; &#125; \\\\矩阵的LU分解 public void LuDecomposition() &#123; //初始化第一行、第一列 for (int i = 1; i &lt; this.column; i++) &#123; matrix[i, 0] = matrix[i,0] / matrix[0, 0]; &#125; for (int i = 1; i &lt; this.row; i++) &#123; //先计算对角元，避免重复计算（放在第二个循环内会计算两次） matrix[i, i] = matrix[i, i] - FigureTemp(i, i, i ); for (int j = i+1; j &lt; this.column; j++) &#123; //第i行i列的更新 matrix[i, j] = matrix[i, j] - FigureTemp(i, j, i); matrix[j, i] = (matrix[j, i] - FigureTemp(i, j, i))/matrix[i,i]; &#125; &#125; &#125; private float FigureTemp(int i,int j,int k) &#123; //用于计算求和中间量 float result = 0; for (int s = 0; s &lt; k; s++) &#123; result += matrix[i, s] * matrix[s, j]; &#125; return result; &#125; &#125; &#125;&#125; 程序的验证 当我们输入矩阵 A= \\begin{pmatrix} 9&18&9&-27\\\\ 18&45&0&-45\\\\ 9&0&126&9\\\\ -27&-45&9&135 \\end{pmatrix}将得到输出如下 经对比，与上面计算的一致，程序无误。","link":"","permalink":"http://zhumingcj.github.io/2019/07/03/usage-of-trigonometric-decomposition/","tags":[{"name":"Matrix","slug":"matrix","permalink":"http://zhumingcj.github.io/tags/matrix/"}]},{"title":"","date":"2019-07-02T12:26:18.000Z","text":"矩阵的LU分解矩阵的分解在矩阵的研究中有着极其重要的地位，而LU分解则是矩阵分析中一种常见而又重要的分解. LU分解——从高斯消元法说起LU分解的来龙去脉在高斯消元法中，我们使用了多次倍加把主对角元以外的元素变为零，这个过程可以看成是用一系列的初等矩阵来左乘系数矩阵。 A^{(0)}=A \\quad\\quad\\quad A^{(1)}\\triangleq \\begin{pmatrix} a_{11}^{(0)}&a_{12}^{(0)}&\\dots&a_{1n}^{(0)}\\\\ 0&a_{22}^{(1)}&\\dots&a_{2n}^{(1)}\\\\ \\vdots&\\vdots&&\\vdots\\\\ 0&a_{n2}^{(1)}&\\dots&a_{nn}^{(1)} \\end{pmatrix}\\quad\\quad\\quad\\\\ \\quad\\\\ L_{1}\\triangleq \\begin{pmatrix} 1&&&&\\\\ -l_{12}&1\\\\ -l_{13}&&1&&\\\\ \\vdots&&&\\ddots\\\\ -l_{1n}&&&&1 \\end{pmatrix}则有$A^{(1)}=L_{1}A^{(0)}$,同理有 A^{(2)}\\triangleq \\begin{pmatrix} a_{11}^{(0)}&a_{12}^{(0)}&a_{}13^{(0)}&\\dots&a_{1n}^{(0)}\\\\ 0&a_{22}^{(1)}&a_{23}^{(1)}&\\dots&a_{2n}^{(1)}\\\\ 0&0&a_{33}^{(2)}&\\cdots&a_{3n}^{(2)}\\\\ \\vdots&\\vdots&\\vdots&&\\vdots\\\\ 0&0&a_{n3}^{(2)}&\\dots&a_{nn}^{(1)} \\end{pmatrix}\\quad\\quad\\quad\\\\ \\quad\\\\ \\quad\\\\ L_{2}\\triangleq \\begin{pmatrix} 1&&&&\\\\ &1\\\\ &-l_{32}&1\\\\ &-l_{42}&&1&&\\\\ &\\vdots&&&\\ddots\\\\ &-l_{n2}&&&&1 \\end{pmatrix} \\\\A^{(2)}=L_{2}A^{(1)}一般的，有 A^{(k-1)}\\triangleq \\begin{pmatrix} a_{11}^{(0)}&a_{12}^{(0)}&&\\dots &\\dots&a_{1n}^{(0)}\\\\ &a_{22}^{(1)}&&\\dots&\\dots&a_{2n}^{(1)}\\\\ &&\\ddots&&&\\vdots\\\\ &&&a_{kk}^{(k-1)}&\\dots&a_{kn}^{(k-1)}\\\\ &&&\\vdots&\\dots&\\vdots\\\\ &&&a_{nk}^{(k-1)}&\\dots&a_{nn}^{(k-1)} \\end{pmatrix}\\quad\\quad\\quad\\\\ \\quad\\\\ \\quad\\\\ L_{2}\\triangleq \\begin{pmatrix} 1&&&&\\\\ &\\ddots\\\\ &&1\\\\ &&-a_{k+1,k}&1\\\\ &&-l_{k+2,k}&&1&&\\\\ &&\\vdots&&&\\ddots\\\\ &&-l_{nk}&&&&1 \\end{pmatrix}\\\\ \\quad\\\\ \\quad\\\\ \\quad\\\\ A^{(k)}\\triangleq A^{(k-1)}\\triangleq \\begin{pmatrix} a_{11}^{(0)}&a_{12}^{(0)}&&\\dots&a_{1,k+1}^{(0)} &\\dots&a_{1n}^{(0)}\\\\ &a_{22}^{(1)}&&\\dots&a_{2,k+1}^{(1)} &\\dots&a_{2n}^{(1)}\\\\ &&\\ddots&&\\vdots&&\\vdots\\\\ &&&a_{kk}^{(k-1)}&a_{k,k+1}^{(k-1)} &\\dots&a_{kn}^{(k-1)}\\\\ &&&&a_{k+1,k+1}^{k}&\\dots&a_{k+1,n}^{(k)}\\\\ &&&&\\vdots&&\\vdots\\\\ &&&&a_{n,k+1}^{(k)}&\\dots&a_{nn}^{(k)} \\end{pmatrix}\\quad\\quad\\quad A^{(k)}=L_{k}A^{(k-1)}=\\dots=L_{k}L_{k-1}\\dots L_{1}A^{(0)}.因为一共有n-1步消元，所以$A^{(n-1)}=L_{n}L{n-1}\\dots L_{k}\\dots L_{2}L_{1}A^{(0)}$ A^{(n-1)}= \\begin{pmatrix} a_{11}^{(0)}&a_{12}^{(0)}&\\dots&a_{1n}^{(0)}\\\\ &a_{22}^{(1)}&\\dots&a{2n}^{(1)}\\\\ &&\\ddots&\\vdots\\\\ &&&a_{nn}^{n-1} \\end{pmatrix}我们注意到$L_{k}$的逆矩阵为 L_{k}^{-1}= \\begin{pmatrix} 1&&&\\\\ &\\ddots&&\\\\ &&1&&\\\\ &&-l_{k+1,k}&1\\\\ &&\\vdots&&\\ddots\\\\ &&l_{n,k}&&&1 \\end{pmatrix}则$A=A^{(0)}=L_{1}^{-1}L{2}^{-1}\\dots L_{n-1}^{-1}A^{(n-1)}=LU$ 其中 L\\triangleq L_{1}^{-1}L_{2}^{-1}\\dots L_{n-1}^{-1}= \\begin{pmatrix} 1&&&&\\\\ l_{21}&1\\\\ l_{31}&l_{32}&1\\\\ \\vdots&\\vdots&&\\ddots\\\\ l_{n1}&l_{n2}&\\dots&l_{n,n-1}&l_{n,n} \\end{pmatrix}\\\\ \\quad\\\\ \\quad\\\\ U\\triangleq A^{(n-1)} \\begin{pmatrix} u_{11}&u_{12}&\\dots&u_{1n}\\\\ &u_{22}&\\dots&u_{2n}\\\\ &&\\ddots&\\vdots\\\\ &&&u_{nn} \\end{pmatrix}显然可知L为下三角矩阵而U为上三角矩阵 LU分解的公式推导根据$A=LU$,由矩阵乘法可得 a_{ij}=\\sum_{k=1}^{n}l_{ik}u_{kj},\\quad i,j=1,2,\\dots,n \\quad(1)注：由L为下三角矩阵可知$l_{ij}=0, when j&gt;i$ 同样的因为U是上三角矩阵，所以$u_{ij}=0, when i&gt;j$ 由（1）可先计算U的元 a_{ij}=\\sum_{k=1}^{i}l_{ik}u_{kj}=\\sum_{k=1}^{i-1}l_{ik}u_{kj}+u_{ij}\\quad\\quad 故\\\\ u_{ij}=a_{ij}-\\sum_{k=1}^{i-1}l_{ik}u_{kj}\\quad i=1,2,\\dots,n;j=i,i+1,\\dots,n \\\\ 特别的,当i=1时，u_{1j}=a_{1j}(j=1,2,\\dots,n)然后再计算L的元 a_{ij}=\\sum_{k=1}^{j}l_{ik}u_{kj}=\\sum_{k=1}^{j-1}l_{ik}u_{kj}+l_{ij}u_{jj}\\\\ \\quad\\\\ l_{ij}=\\frac{a_{ij}-\\sum_{k=1}^{j-1}l_{ik}u_{kj}}{u_{jj}}\\\\ 特别的，当j=1时，l_{i1}=\\frac{a_{i1}}{u_{11}}综上所述，我们可以得到如下公式 \\left\\{ \\begin{array}\\ u_{1j}=a_{1j},\\quad\\quad\\quad\\quad\\quad j=1,2,\\dots,n\\\\ l_{i1}=\\frac{a_{i1}}{u_{11}},\\quad\\quad\\quad\\quad\\quad i=2,3,\\dots,n\\\\ u_{ij}=a_{ij}-\\sum_{k=1}^{i-1}l_{ik}u_{kj},\\quad\\quad\\quad\\quad\\quad i=2,3,\\dots,n;j=i,i+1,\\dots,n\\quad\\quad\\quad（2）\\\\ l_{ij}=\\frac{a_{ij}-\\sum_{k=1}^{j-1}l_{ik}u_{kj}}{u_{jj}},\\quad\\quad j=2,3,\\dots,n-1;i=j+1,j+2,\\dots,n \\end{array} \\right.","link":"","permalink":"http://zhumingcj.github.io/2019/07/02/triangular-decomposition/","tags":[{"name":"Matrix","slug":"matrix","permalink":"http://zhumingcj.github.io/tags/matrix/"}]},{"title":"Singleton Pattern","date":"2019-07-01T10:52:18.000Z","text":"单例模式——单例模式是六中23种设计模式中最简单的一种，虽然如此单例模式还是有值得探讨的地方。 单例模式的用处顾名思义，单例模式就是想产生一个唯一的实例，而这样做的目的在于： 对于某些频繁使用的全局对象，如果频繁地创建和销毁会占用很多的系统资源 在一些场景中，需要唯一的实例，比如序列号、资源管理器等，其本身要就具有唯一性。 单例模式的简介单例模式一般分为两类，俗称懒汉式和饿汉式——懒汉式是指当真正要使用到这个对象时才去创建这个对象；而饿汉式则是在程序运行之初就完成对象的创建。 要想实现单例模式，首先就要把构造函数私有化，这样外部就无法通过调用构造函数来生成更多的实例了。但是这时就要对外提供产生实例的接口，并在内部完成单例的创建。 单例模式的几种实现方式 最简单的单例模式可以采用一个静态字段来保存单例，外界调用创建单例的方法时就把这个对象返回。静态字段会在程序一开始就初始化（由CLR实现），因此这是饿汉式的单例模式。 12345678910111213141516/// &lt;summary&gt; /// 最简单的单例模式，使用静态字段保存唯一单例，对外提供一个方法访问来获取单例 /// &lt;/summary&gt; public class Singleton &#123; private static Singleton _singelton = new Singleton(); private Singleton() &#123; &#125; public static Singleton CreatInstance() &#123; return _singelton; &#125; &#125; 上面这种单例模式的实现方式存在一定的问题，试想如果这个单例在程序运行一开始并没有被使用，它就会占据系统的资源，会影响程序的效率（一个典型的例子是数据库链接，会占用大量资源）。所以改进的单例模式使用Lazy Loading，也就是懒汉模式。 /// &lt;summary&gt;123456789101112131415161718192021222324252627282930/// &lt;summary&gt; /// 实现了Lazy Loading的单例模式，没有使用不会占用资源，但是它不是线程安全的 /// &lt;/summary&gt; public class Singleton2 &#123; private long sum = 0; private static Singleton2 _singelton = null; private Singleton2() &#123; Console.WriteLine($\"&#123;this.GetType().Name&#125; 被构造了\"); &#125; public void Change() &#123; sum++; &#125; public static Singleton2 CreatInstance() &#123; if (_singelton == null) &#123; _singelton = new Singleton2(); &#125; return _singelton; &#125; public static void Show() &#123; Console.WriteLine(_singelton.sum); &#125; &#125; 上一种单例模式可以满足一般的需求，但当涉及到多线程并发时，上一种方法会尝试问题，因为它不是线程安全的，所以需要枷锁同步 123456789101112131415161718192021222324252627282930313233343536/// &lt;summary&gt; /// 实现了Lazy Loading并且是线程安全的,但是在高并发的情况下会产生等待 /// &lt;/summary&gt; public class Singleton3 &#123; private long sum = 0; private static Singleton3 _singleton = null; private static readonly object locker = new object(); private Singleton3() &#123; Console.WriteLine($\"&#123;this.GetType().Name&#125; 被构造了\"); &#125; public void Change() &#123; lock (locker) sum++; &#125; public static Singleton3 CreatInstance() &#123; lock (locker) &#123; if (_singleton == null) &#123; _singleton = new Singleton3(); &#125; &#125; return _singleton; &#125; public static void Show() &#123; Console.WriteLine(_singleton.sum); &#125; &#125; 现在已经接近完美了，但是任存在一个问题——性能的消耗，因为每次调用CreateInstance方法时，都要争取锁而排队，会造成阻塞。所以我们希望当单例完成创建后不要再排队，这就有名为了Double-Checked的单例模式 1234567891011121314151617181920212223242526272829/// &lt;summary&gt; /// 使用Double-check,与前一种方法一样，但是性能有提高，单例已生成的情况下不用等待 /// &lt;/summary&gt; public class Singleton4 &#123; private static Singleton4 _singelton = null; private static readonly object locker = new object(); private Singleton4() &#123; Console.WriteLine($\"&#123;this.GetType().Name&#125; 被构造了\"); &#125; public static Singleton4 CreatInstance() &#123; if (_singelton == null) &#123; lock (locker) &#123; if (_singelton == null) &#123; _singelton = new Singleton4(); &#125; &#125; &#125; return _singelton; &#125; &#125; 现在事情似乎已经很完美了，但是如果细究一下我们会发现这样一个问题：当多个线程访问CreateInstance时，（单例还没有创建的情况下）它们都会进入第一个if语句开始排队，会有一个线程争得锁进入第二个if，然后调用构造函数创建单例，创建完后释放锁，第二个线程进入，第二个线程首先会检查_singleton的状态是否为空，现在问题就出现了，如果这个描述对象是否为空的属性如果没有及时更新，那么就会导致多个实例的产生。这种情况是可能存在的，这是编译器所决定的，由于读写无序则会导致前面的情况出现（先访问了实例是否存在的属性，之后才进行了这个属性的写操作）。改进的方法是在存储单例的静态字段前加上valotile关键词。 1234567891011121314151617181920212223/// &lt;summary&gt; /// 也可以使用volatile关键字保证线程安全 /// &lt;/summary&gt; public class Singleton5 &#123; private static readonly object locker = new object(); private static volatile Singleton5 _singelton = null; public static Singleton5 CreatInstance() &#123; if (_singelton == null) &#123; lock (locker) &#123; if (_singelton == null) &#123; _singelton = new Singleton5(); Console.WriteLine(\"Singleton 被构造了\"); &#125; &#125; &#125; return _singelton; &#125; &#125; 注：volatile关键字的作用是保证被它修饰的对象（包括引用类型、指针类型、整型、具有整数基类型的枚举类型、泛型等）是和改变同步的，即永远是最新的（可以理解为volatile修饰的对象写操作先于读操作），具体原理涉及内存的操作，此处不做叙述。 关于单例线程安全问题的直观验证 根据上面封装的类，当我们运行如下代码时 123456789101112131415161718192021static void Main(string[] args) &#123; List&lt;Task&gt; tasks1 = new List&lt;Task&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; Singleton2 singleton = Singleton2.CreatInstance(); tasks1.Add(Task.Run(() =&gt; singleton.Change())); &#125; Task.WaitAll(tasks1.ToArray()); Singleton2.Show(); Console.WriteLine(\"***************************************************************\"); List&lt;Task&gt; tasks2 = new List&lt;Task&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; Singleton3 singleton = Singleton3.CreatInstance(); tasks2.Add(Task.Run(() =&gt; singleton.Change())); &#125; Task.WaitAll(tasks2.ToArray()); Singleton3.Show(); Console.Read(); &#125; 会得到如下的结果 这样我们可以直观地看到线程安全问题确实存在。","link":"","permalink":"http://zhumingcj.github.io/2019/07/01/singleton-pattern/","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://zhumingcj.github.io/tags/设计模式/"}]},{"title":"Gaussian elimination method","date":"2019-06-27T12:06:11.000Z","text":"求解矩阵的高斯消元法高斯消元法是求解矩阵最基础的一种算法，具有泛化性强的优点。 消元过程对于方程组$Ax=b$（其中A为n阶方阵）可由n-1个消元过程和n-1个回代过程完成求解 \\begin{cases} a_{11}x_1+a_{12}x_2+a_{13}x_3+\\cdots+a_{1n}x_n=&b_1 \\\\\\vdots\\\\ a_{n1}x_1+a_{n2}x_2+a_{n3}x_3+\\cdots+a_{nn}x_n=&b_n& \\end{cases} \\\\ \\begin{pmatrix} a_{11}&a_{12}&a_{13}&\\dots&a_{1n}\\\\ a_{21}&a_{22}&a_{23}&\\dots&a_{2n}\\\\ \\vdots&&&&\\vdots\\\\ a_{n1}&a_{n2}&a_{n3}&\\dots&a_{nn} \\end{pmatrix} \\begin{pmatrix} x_1\\\\ x_2\\\\ \\vdots\\\\ x_n \\end{pmatrix}= \\begin{pmatrix} b_1\\\\ b_2\\\\ \\vdots\\\\ b_n \\end{pmatrix} 矩阵的消元过程(在矩阵有解的情况下) 第一步消元 $a_{ij}^{(1)}=a_{ij}^{(0)}-\\frac{a_{i1}^{(0)}} {a_{11}^{(0)}}a_{1j}^{(0)}=a_{ij}^{(0)}-l_{i1}^{(0)}a_{1j}^{(0)} ,\\quad i=2,3,\\dots,n;j=2,3,\\dots,n$ $b_{i}^{(1)}=b_{i}^{(0)}-\\frac{a_{i1}^{(0)}} {a_{11}^{(0)}}b_{1}^{(0)}=b_{i}^{(0)}-l_{i1}^{(0)}b_{1}^{(0)} ,\\quad i=2,3,\\dots,n$ $l_{i1}\\triangleq \\frac {a_{i1}^{(0)}} {a_{11}^{(0)}},\\quad i=2,3,\\dots,n$ 第k步消元 $a_{ij}^{(k)}=a_{ij}^{(k-1)}-\\frac{a_{ik}^{(k-1)}} {a_{kk}^{(k-1)}}a_{kj}^{(k-1)}=a_{ij}^{(k-1)}-l_{ik}^{(k-1)}a_{kj}^{(k-1)} ,\\quad i=k+1,k+2,\\dots,n;j=k=1,k+2,\\dots,n$ $b_{i}^{(k)}=b_{i}^{(k-1)}-\\frac{a_{ik}^{(k-1)}} {a_{kk}^{(k-1)}}b_{k}^{(k-1)}=b_{i}^{(k-1)}-l_{ik}^{(k-1)}b_{k}^{(k-1)} ,\\quad i=k+1,k+2,\\dots,n$ $l_{ik}\\triangleq \\frac {a_{ik}^{(k-1)}} {a_{kk}^{(k-1)}},\\quad i=k+1,k+2,\\dots,n$ 消元完成后 A^{(n-1)}= \\begin{pmatrix} a_{11}^{(0)}&a_{12}^{(0)}&a_{13}^{(0)}&\\cdots&\\cdots&a_{1n}^{(0)}\\\\ &a_{22}^{(1)}&a_{23}^{(1)}&\\cdots&\\cdots&a_{2n}^{(1)}\\\\ &&\\ddots\\\\ &&&a_{kk}^{(k-1)}&\\cdots&a_{kn}^{(k-1)}\\\\ &&&&\\ddots&\\vdots\\\\ &&&&&a_{nn}^{(n-1)} \\end{pmatrix},\\quad b^{(n-1)}= \\begin{pmatrix} b_{1}^{(0)}\\\\ b_{2}^{(1)}\\\\ \\vdots\\\\ b_{k}^{(k-1)}\\\\ \\vdots\\\\ b_{n}^{(n-1)} \\end{pmatrix} 回代的过程 \\left\\{ \\begin{array} x_n=\\frac{b_n^{n-1}}{a_{nn}^{(n-1)}}\\\\ x_k=\\frac{ {b_k}^{(k-1)-\\sum_{j=k+1}^n(a_{kj}^{(k-1)}x_j)} } {a_{kk}^{(k-1)} },\\quad k=n-1,n-2,\\dots,2,1. \\end{array} \\right. 算法的分析 [ ] 在消元的过程中，计算$l_{ik}\\triangleq \\frac {a_{ik}^{(k-1)}} {a_{kk}^{(k-1)}},\\quad i=k+1,k+2,\\dots,n$时共有n-k个除法，而计算$a_{ij}^{(k)}=a_{ij}^{(k-1)}-l_{ik}^{(k-1)}a_{kj}^{(k-1)} ,\\quad i=k+1,k+2,\\dots,n;j=k=1,k+2,\\dots,n$时有$(n-k)^2$个乘法，计算$b_{i}^{(k)}=b_{i}^{(k-1)}-l_{ik}^{(k-1)}b_{k}^{(k-1)} ,\\quad i=k+1,k+2,\\dots,n$时也有n-k个乘法，消元共进行了n-1步，即$k=1,2,\\dots,n-1$. [ ] ==所以在消元过程中乘除法的运算量为== N_1=\\sum_{k=1}^{n-1}((n-k)^2+2(n-k))=n^3/3+n^2/2-5n/6. [ ] ==回代过程中乘除法的运算量为== N_2=\\sum_{k=1}^{n-1}(n-k)+n=n^2/2+n/2. [ ] ==所以高斯消元法解n阶矩阵的总乘除法运算量为== $N=N_1+N_2=n^3/3+n^2-n/3$ 高斯消元法的程序实现我们可以封装一个Matrix类如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Matrix&#123; public int row = 0; public int column = 0; private float[,] matrix; public Matrix(int row, int column) &#123; this.row = row; this.column = column; matrix = new float[row, column]; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; column; j++) &#123; string mid = Console.ReadLine(); var rows = mid.Split(&apos; &apos;); foreach (var item in rows) &#123; matrix[i, j++] = float.Parse(item); &#125; &#125; &#125; &#125; public void DisPlay() &#123; for (int i = 0; i &lt; this.row; i++) &#123; for (int j = 0; j &lt; this.column; j++) &#123; Console.Write(matrix[i, j] + &quot; &quot;); &#125; Console.WriteLine(&quot;\\r&quot;); &#125; &#125; public void Simplize() &#123; for (int i = 0; i &lt; this.row ; i++) &#123; if (matrix[i, i] != 0) &#123; for (int k = i + 1; k &lt; row ; k++) &#123; matrix[k, i] = matrix[k, i] / matrix[i, i]; &#125; &#125;//这里将消元的中间量存在被消元的位置，因为运算后，这些位置的值为零 for (int j = i + 1; j &lt; row; j++) &#123; for (int k = i + 1; k &lt; column; k++) &#123; matrix[j, k] = matrix[j, k] - matrix[j, i] * matrix[i, k]; &#125; &#125; &#125; &#125;&#125; 当我们输入 \\begin{pmatrix} 1&2&1&0\\\\ 2&2&3&3\\\\ -1&-3&0&2 \\end{pmatrix}时，并调用Simplize和DisPlay方法，将得到结果如下 事实上，这是一个矩阵的LU分解，LU分解在矩阵的研究中有着重要的地位，是十分常用的一个分解方法。 高斯消元法的缺点 高斯消元法的运算量较大 高斯消元法的顺利进行要求矩阵满足某些要求","link":"","permalink":"http://zhumingcj.github.io/2019/06/27/Gaussian elimination method/","tags":[{"name":"Matrix","slug":"matrix","permalink":"http://zhumingcj.github.io/tags/matrix/"}]},{"title":"Decoractor Pattern","date":"2019-06-27T02:57:06.000Z","text":"装饰器模式是一个很著名的设计模式，经常被用于有切面需求的场景，比如插入日志、统计等的逻辑。装饰器模式的作用是能为已经存在的对象添加额外的功能。 设计模式之装饰器模式装饰器模式的作用 在不改变现有对象结构的基础上为其添加新的功能，且并不通过继承而是通过对象之间的关联来实现，使其更加灵活。 相比于继承来增加新功能（固定的），装饰器模式可以动态的增加新功能，并且功能之间可以进行组合来产生更多的功能，避免了增加功能时对对象的修改 这是一种实现AOP（面向切面编程）的方法，即将主业务逻辑之外的aspect抽离出来，降低代码的耦合度。 实现装饰器模式的关键装饰器模式无非是要调用一堆方法，但是又不能直接在类中增加逻辑（开闭原则），也不通过继承来实现，而是交给装饰器来实现。那么问题的关键就在于保存这一堆方法，并且使他们之间的顺序可以动态的调整。装饰器模式是通过字段对方法进行缓存（实际上是缓存一个对象，然后调用对象的方法），再通过迭代调用将各个方法以一定的顺序连接起来 装饰器实现步骤 建立一个继承自对象抽象类的装饰器基类，其中包括缓存字段，构造函数和方法调用 123456789101112class BaseStudentDecorator : AbstractStudent &#123; private AbstractStudent _student = null;//用于缓存一个对象 public BaseStudentDecorator(AbstractStudent student) &#123; this._student = student; &#125; public override void Finish() &#123; this._student.Finish(); &#125; &#125; 依照单一职责原则创建实现具体功能的装饰器，在其中调用父类的构造函数并复写父类的方法 12345678910111213public StudentLearningDecoractor(AbstractStudent student) : base(student) &#123; &#125; public override void Finish() &#123; &#123; //你要实现的逻辑 &#125; base.Finish(); &#125;//创建多个，根据要实现的逻辑 对装饰器要实现的功能进行注册并调用 123456student = new StudentPreviewDecoractor(student); student = new StudentLearningDecoractor(student);//添加了一个功能 student = new StudentReviewDecorator(student);//添加了一个功能 student = new StudentPlayDecoractor(student);//添加了一个功能 student = new StudentSleeepDecorator(student);//添加了一个功能 student.Finish();//调用 抽象类和具体类 public abstract class AbstractStudent123456789101112131415161718192021public abstract class AbstractStudent &#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public abstract void Finish(); &#125; public class StudentCommon:AbstractStudent &#123; public override void Finish() &#123; Console.WriteLine($&quot;&#123;base.Name&#125; finished learning&quot;); &#125; public class StudentPreview: StudentCommon &#123; public override void Finish() &#123; base.Finish(); Console.WriteLine(&quot;先进行复习&quot;); &#125; &#125; &#125; 运行结果： 深入分析 [ ] 当我们在注册方法时，student（不同类型）对象会被保存在基类中 [ ] 当我们最后调用finish方法时，会先调用StudentSleeepDecorator的finish方法，finish方法又会调用基类的finish方法，而基类的finish方法会调用之前缓存的student的finish方法…..，从而形成了一系列的调用，相当于一个链表结构。 [ ] 在我们实现具体的装饰器时，==base.Finish()和你要实现的逻辑的顺序直接影响到这些逻辑调用的顺序==。当你要实现的逻辑放在前面时，相当于堆栈，遵从先进后出的原则，因此先注册的方法会最后执行（1）；当base.Finish()放在前面时，相当于队列，遵从先进先出，因此先注册的方法最先执行（2）。 [ ] 所以当我们要实现在主逻辑（这里为Console.WriteLine($”{base.Name} finished learning”)，即已有对象的方法）前增加若干方法，在主逻辑后也增加若干方法时： 在编写装饰器时时，对于主逻辑之前要执行的方法应按上述（1）来编写装饰器；而对于主逻辑之后要执行的方法应按上述（2）来编写装饰器。 在注册时，对于主逻辑之前要执行的方法要逆序注册；对于主逻辑之后要执行的方法要顺序注册 tips 观察者模式较其他设计模式来说要更难以理解，相要真正理解还是得自己敲一下代码，断点运行一下。","link":"","permalink":"http://zhumingcj.github.io/2019/06/27/Decoractor-Pattern/","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://zhumingcj.github.io/tags/设计模式/"}]},{"title":"设计模式-观察者模式","date":"2019-06-26T16:52:38.000Z","text":"设计模式之观察者模式 什么是观察者模式形象的来说，观察者模式包含一个被观察者（subject）以及若干观察者（observer），observer观察subject，当subject发出一个动作时，observer观察到后作出相应反应。在程序中则是某个类（subject）达到某种触发条件后向其他类发送通知（通常是执行某些方法的信息），然后这些类执行相应的方法。 观察者模式的作用 用于程序的解耦。观察者模式通过依赖于抽象的接口来减少类与类之间的直接依赖。 可以作为一种通知的机制，将更新通知给其它的对象。 观察者模式的缺点 当一个被观察者有很多的直接或间接的观察者时，要通知到所有的观察者需要耗费很多的时间。 当被观察者之间循环依赖时（比如：A通知B改变C，C的改变引起A的改变，继而又触发了A通知B），程序会进入循环调用，导致系统崩溃。 观察者模式的实现要点 要创建一个接口用以约束所有被观察者，提供消息传递的通道 被观察者需要有一个存放消息的容器，一般是接口的一个列表；同时被观察者要具有订阅观察者和取消订阅的方法，用以动态的增加减少观察者的数量。 实现消息的传递——通过调用接口列表中的各个方法。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 class Program &#123; static void Main(string[] args) &#123; Cat cat = new Cat(); cat.Add(new Dog()); cat.Add(new Duck()); cat.Add(new mouse()); cat.Add(new people()); cat.Miao(); Console.Read(); &#125; &#125;interface Ioberver&#123; void Action();&#125; class Chicken:Ioberver &#123; public void Action() &#123; this.Woo(); &#125; public void Woo() &#123; Console.WriteLine(&quot;&#123;0&#125; Woo&quot;, this.GetType().Name); &#125; &#125; class Dog : Ioberver &#123; public void Action() &#123; this.Wang(); &#125; public void Wang() &#123; Console.WriteLine($&quot;&#123;this.GetType().Name&#125; 汪汪汪&quot;); &#125; &#125; class Duck : Ioberver &#123; public void Action() &#123; this.Gaga(); &#125; public void Gaga() &#123; Console.WriteLine($&quot;&#123;this.GetType().Name&#125; 嘎嘎嘎&quot;); &#125; &#125; class mouse : Ioberver &#123; public void Action() &#123; this.Zhi(); &#125; public void Zhi() &#123; Console.WriteLine($&quot;&#123;this.GetType().Name&#125; 吱吱吱&quot;); &#125; &#125;class Cat&#123; public void Miao() &#123; Console.WriteLine(&quot;&#123;0&#125; miao&quot;,this.GetType().Name); if(this._ObserverList!=null &amp;&amp; this._ObserverList.Count &gt; 0) &#123; foreach (var observer in _ObserverList) &#123; observer.Action(); &#125; &#125; &#125; public List&lt;Ioberver&gt; _ObserverList = new List&lt;Ioberver&gt;(); public void Add(Ioberver observer) &#123; this._ObserverList.Add(observer); &#125; public void Remove(Ioberver observer) &#123; this._ObserverList.Remove(observer); &#125;&#125; 运行结果：","link":"","permalink":"http://zhumingcj.github.io/2019/06/27/Observer Pattern/","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://zhumingcj.github.io/tags/设计模式/"}]},{"title":"ShortCut Key for Typora","date":"2019-06-21T05:36:41.000Z","text":"刚建立了自己的博客，来发一篇文章:smiley: 最近刚学会使用Typora，刚好把一些快捷键整理一下。 常用快捷键 标题 ctrl+1/2/3… 数字表示标题的级数 下划线 ctrl+u 效果：这是下划线 删除线 shift+alt+5 效果：这是删除线 字体加粗 ctrl+b 效果：加粗了 字体倾斜 ctrl+i 效果：倾斜的字 无序列表 -+space+内容 效果 牛奶 面包 巧克力（可嵌套） 引用 &gt;+space或ctrl+shift+q 效果：这是引用 插入地址 ctrl+k 百度 插入表格 ctrl+t 效果： 周一 周二 周三 周四 周五 微积分 放假 放假 放假 放假 大学物理 放假 放假 放假 放假 英语 放假 放假 放假 放假 回到文章顶部 ctrl+home 效果：无法展示:joy: 自动产生目录 [TOC]+enter 效果：(只有一个标题，将就看一下效果) [TOC] 选中一整行 ctrl+l 额，无法展示效果 插入代码块 ctrl+alt+b(可能需要自己设置) 效果： 1234567891011using System;using System.Collections.Generic;using System.Diagnostics;using System.Linq;using System.Text;using System.Threading;using System.Threading.Tasks;public static void main(string[]args)&#123; ConSole.WriteLine(\"Hello World\");&#125; 搜索内容 ctrl+f 替换 ctrl+h 效果：无 强调、着重标记 ctrl+shift+~(tab上面那个) 效果：这是重点 这是重点 则是重点 分隔线 —-+enter或*+enter 效果： 数学公式 $$+enter 效果： |i j k | a+b+c^5=2ab 表情 :+表情的英文单词 效果：:artificial_satellite: 快速创建新文件 ctrl +n 快速关闭 ctrl+w 显示/隐藏大纲 ctrl+shift+l 高亮 == 文字 ==（中间没有空格） 标题变为普通文本 ctrl+0 脚注 效果：这是一个脚注1 行内数学公式 $+esc(然后输入Tex命令) $\\lim_{x\\to\\infty}\\exp(-x)=0$ 上下标 x^2^2 H~2~O 效果：x^2^ H~2~O 1. 注释 &#8617;","link":"","permalink":"http://zhumingcj.github.io/2019/06/21/Tips for Typora/","tags":[{"name":"文本编辑","slug":"文本编辑","permalink":"http://zhumingcj.github.io/tags/文本编辑/"}]},{"title":"my first blog","date":"2019-06-21T00:32:12.000Z","text":"这是我的第一篇blog序章终于成功了很开心 :happy:","link":"","permalink":"http://zhumingcj.github.io/2019/06/21/my-first-blog/","tags":[]}]