[{"title":"Matrix","date":"2019-06-27T12:06:11.000Z","text":"求解矩阵的高斯消元法高斯消元法是求解矩阵最基础的一种算法，具有泛化性强的优点。 消元过程对于方程组$Ax=b$（其中A为n阶方阵）可由n-1个消元过程和n-1个回代过程完成求解 \\begin{cases} a_{11}x_1+a_{12}x_2+a_{13}x_3+\\cdots+a_{1n}x_n=&b_1 \\\\\\vdots\\\\ a_{n1}x_1+a_{n2}x_2+a_{n3}x_3+\\cdots+a_{nn}x_n=&b_n& \\end{cases} \\\\ \\begin{pmatrix} a_{11}&a_{12}&a_{13}&\\dots&a_{1n}\\\\ a_{21}&a_{22}&a_{23}&\\dots&a_{2n}\\\\ \\vdots&&&&\\vdots\\\\ a_{n1}&a_{n2}&a_{n3}&\\dots&a_{nn} \\end{pmatrix} \\begin{pmatrix} x_1\\\\ x_2\\\\ \\vdots\\\\ x_n \\end{pmatrix}= \\begin{pmatrix} b_1\\\\ b_2\\\\ \\vdots\\\\ b_n \\end{pmatrix} 矩阵的消元过程(在矩阵有解的情况下) 第一步消元 $a_{ij}^{(1)}=a_{ij}^{(0)}-\\frac{a_{i1}^{(0)}} {a_{11}^{(0)}}a_{1j}^{(0)}=a_{ij}^{(0)}-l_{i1}^{(0)}a_{1j}^{(0)} ,\\quad i=2,3,\\dots,n;j=2,3,\\dots,n$ $b_{i}^{(1)}=b_{i}^{(0)}-\\frac{a_{i1}^{(0)}} {a_{11}^{(0)}}b_{1}^{(0)}=b_{i}^{(0)}-l_{i1}^{(0)}b_{1}^{(0)} ,\\quad i=2,3,\\dots,n$ $l_{i1}\\triangleq \\frac {a_{i1}^{(0)}} {a_{11}^{(0)}},\\quad i=2,3,\\dots,n$ 第k步消元 $a_{ij}^{(k)}=a_{ij}^{(k-1)}-\\frac{a_{ik}^{(k-1)}} {a_{kk}^{(k-1)}}a_{kj}^{(k-1)}=a_{ij}^{(k-1)}-l_{ik}^{(k-1)}a_{kj}^{(k-1)} ,\\quad i=k+1,k+2,\\dots,n;j=k=1,k+2,\\dots,n$ $b_{i}^{(k)}=b_{i}^{(k-1)}-\\frac{a_{ik}^{(k-1)}} {a_{kk}^{(k-1)}}b_{k}^{(k-1)}=b_{i}^{(k-1)}-l_{ik}^{(k-1)}b_{k}^{(k-1)} ,\\quad i=k+1,k+2,\\dots,n$ $l_{ik}\\triangleq \\frac {a_{ik}^{(k-1)}} {a_{kk}^{(k-1)}},\\quad i=k+1,k+2,\\dots,n$ 消元完成后 A^{(n-1)}= \\begin{pmatrix} a_{11}^{(0)}&a_{12}^{(0)}&a_{13}^{(0)}&\\cdots&\\cdots&a_{1n}^{(0)}\\\\ &a_{22}^{(1)}&a_{23}^{(1)}&\\cdots&\\cdots&a_{2n}^{(1)}\\\\ &&\\ddots\\\\ &&&a_{kk}^{(k-1)}&\\cdots&a_{kn}^{(k-1)}\\\\ &&&&\\ddots&\\vdots\\\\ &&&&&a_{nn}^{(n-1)} \\end{pmatrix},\\quad b^{(n-1)}= \\begin{pmatrix} b_{1}^{(0)}\\\\ b_{2}^{(1)}\\\\ \\vdots\\\\ b_{k}^{(k-1)}\\\\ \\vdots\\\\ b_{n}^{(n-1)} \\end{pmatrix} 回代的过程 \\left\\{ \\begin{array}{c} x_n=\\frac{b_n^{n-1}}{a_{nn}^{(n-1)}}\\\\ x_k=\\frac{ {b_k}^{(k-1)-\\sum_{j=k+1}^n(a_{kj}^{(k-1)}x_j)} } {a_{kk}^{(k-1)} },\\quad k=n-1,n-2,\\dots,2,1. \\end{array} \\right. 算法的分析 [ ] 在消元的过程中，计算$l_{ik}\\triangleq \\frac {a_{ik}^{(k-1)}} {a_{kk}^{(k-1)}},\\quad i=k+1,k+2,\\dots,n$时共有n-k个除法，而计算$a_{ij}^{(k)}=a_{ij}^{(k-1)}-l_{ik}^{(k-1)}a_{kj}^{(k-1)} ,\\quad i=k+1,k+2,\\dots,n;j=k=1,k+2,\\dots,n$时有$(n-k)^2$个乘法，计算$b_{i}^{(k)}=b_{i}^{(k-1)}-l_{ik}^{(k-1)}b_{k}^{(k-1)} ,\\quad i=k+1,k+2,\\dots,n$时也有n-k个乘法，消元共进行了n-1步，即$k=1,2,\\dots,n-1$. [ ] ==所以在消元过程中乘除法的运算量为== N_1=\\sum_{k=1}^{n-1}((n-k)^2+2(n-k))=n^3/3+n^2/2-5n/6. [ ] ==回代过程中乘除法的运算量为== N_2=\\sum_{k=1}^{n-1}(n-k)+n=n^2/2+n/2. [ ] ==所以高斯消元法解n阶矩阵的总乘除法运算量为== $N=N_1+N_2=n^3/3+n^2-n/3$","link":"","permalink":"http://zhumingcj.github.io/2019/06/27/Matrix/","tags":[{"name":"Matrix","slug":"Matrix","permalink":"http://zhumingcj.github.io/tags/Matrix/"}]},{"title":"Decoractor Pattern","date":"2019-06-27T02:57:06.000Z","text":"装饰器模式是一个很著名的设计模式，经常被用于有切面需求的场景，比如插入日志、统计等的逻辑。装饰器模式的作用是能为已经存在的对象添加额外的功能。 设计模式之装饰器模式装饰器模式的作用 在不改变现有对象结构的基础上为其添加新的功能，且并不通过继承而是通过对象之间的关联来实现，使其更加灵活。 相比于继承来增加新功能（固定的），装饰器模式可以动态的增加新功能，并且功能之间可以进行组合来产生更多的功能，避免了增加功能时对对象的修改 这是一种实现AOP（面向切面编程）的方法，即将主业务逻辑之外的aspect抽离出来，降低代码的耦合度。 实现装饰器模式的关键装饰器模式无非是要调用一堆方法，但是又不能直接在类中增加逻辑（开闭原则），也不通过继承来实现，而是交给装饰器来实现。那么问题的关键就在于保存这一堆方法，并且使他们之间的顺序可以动态的调整。装饰器模式是通过字段对方法进行缓存（实际上是缓存一个对象，然后调用对象的方法），再通过迭代调用将各个方法以一定的顺序连接起来 装饰器实现步骤 建立一个继承自对象抽象类的装饰器基类，其中包括缓存字段，构造函数和方法调用 123456789101112class BaseStudentDecorator : AbstractStudent &#123; private AbstractStudent _student = null;//用于缓存一个对象 public BaseStudentDecorator(AbstractStudent student) &#123; this._student = student; &#125; public override void Finish() &#123; this._student.Finish(); &#125; &#125; 依照单一职责原则创建实现具体功能的装饰器，在其中调用父类的构造函数并复写父类的方法 12345678910111213public StudentLearningDecoractor(AbstractStudent student) : base(student) &#123; &#125; public override void Finish() &#123; &#123; //你要实现的逻辑 &#125; base.Finish(); &#125;//创建多个，根据要实现的逻辑 对装饰器要实现的功能进行注册并调用 123456student = new StudentPreviewDecoractor(student); student = new StudentLearningDecoractor(student);//添加了一个功能 student = new StudentReviewDecorator(student);//添加了一个功能 student = new StudentPlayDecoractor(student);//添加了一个功能 student = new StudentSleeepDecorator(student);//添加了一个功能 student.Finish();//调用 抽象类和具体类 public abstract class AbstractStudent123456789101112131415161718192021public abstract class AbstractStudent &#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public abstract void Finish(); &#125; public class StudentCommon:AbstractStudent &#123; public override void Finish() &#123; Console.WriteLine($\"&#123;base.Name&#125; finished learning\"); &#125; public class StudentPreview: StudentCommon &#123; public override void Finish() &#123; base.Finish(); Console.WriteLine(\"先进行复习\"); &#125; &#125; &#125; 运行结果： 深入分析 [ ] 当我们在注册方法时，student（不同类型）对象会被保存在基类中 [ ] 当我们最后调用finish方法时，会先调用StudentSleeepDecorator的finish方法，finish方法又会调用基类的finish方法，而基类的finish方法会调用之前缓存的student的finish方法…..，从而形成了一系列的调用，相当于一个链表结构。 [ ] 在我们实现具体的装饰器时，==base.Finish()和你要实现的逻辑的顺序直接影响到这些逻辑调用的顺序==。当你要实现的逻辑放在前面时，相当于堆栈，遵从先进后出的原则，因此先注册的方法会最后执行（1）；当base.Finish()放在前面时，相当于队列，遵从先进先出，因此先注册的方法最先执行（2）。 [ ] 所以当我们要实现在主逻辑（这里为Console.WriteLine($”{base.Name} finished learning”)，即已有对象的方法）前增加若干方法，在主逻辑后也增加若干方法时： 在编写装饰器时时，对于主逻辑之前要执行的方法应按上述（1）来编写装饰器；而对于主逻辑之后要执行的方法应按上述（2）来编写装饰器。 在注册时，对于主逻辑之前要执行的方法要逆序注册；对于主逻辑之后要执行的方法要顺序注册 tips 观察者模式较其他设计模式来说要更难以理解，相要真正理解还是得自己敲一下代码，断点运行一下。","link":"","permalink":"http://zhumingcj.github.io/2019/06/27/Decoractor-Pattern/","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://zhumingcj.github.io/tags/设计模式/"}]},{"title":"设计模式-观察者模式","date":"2019-06-26T16:52:38.000Z","text":"设计模式之观察者模式 什么是观察者模式形象的来说，观察者模式包含一个被观察者（subject）以及若干观察者（observer），observer观察subject，当subject发出一个动作时，observer观察到后作出相应反应。在程序中则是某个类（subject）达到某种触发条件后向其他类发送通知（通常是执行某些方法的信息），然后这些类执行相应的方法。 观察者模式的作用 用于程序的解耦。观察者模式通过依赖于抽象的接口来减少类与类之间的直接依赖。 可以作为一种通知的机制，将更新通知给其它的对象。 观察者模式的缺点 当一个被观察者有很多的直接或间接的观察者时，要通知到所有的观察者需要耗费很多的时间。 当被观察者之间循环依赖时（比如：A通知B改变C，C的改变引起A的改变，继而又触发了A通知B），程序会进入循环调用，导致系统崩溃。 观察者模式的实现要点 要创建一个接口用以约束所有被观察者，提供消息传递的通道 被观察者需要有一个存放消息的容器，一般是接口的一个列表；同时被观察者要具有订阅观察者和取消订阅的方法，用以动态的增加减少观察者的数量。 实现消息的传递——通过调用接口列表中的各个方法。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 class Program &#123; static void Main(string[] args) &#123; Cat cat = new Cat(); cat.Add(new Dog()); cat.Add(new Duck()); cat.Add(new mouse()); cat.Add(new people()); cat.Miao(); Console.Read(); &#125; &#125;interface Ioberver&#123; void Action();&#125; class Chicken:Ioberver &#123; public void Action() &#123; this.Woo(); &#125; public void Woo() &#123; Console.WriteLine(\"&#123;0&#125; Woo\", this.GetType().Name); &#125; &#125; class Dog : Ioberver &#123; public void Action() &#123; this.Wang(); &#125; public void Wang() &#123; Console.WriteLine($\"&#123;this.GetType().Name&#125; 汪汪汪\"); &#125; &#125; class Duck : Ioberver &#123; public void Action() &#123; this.Gaga(); &#125; public void Gaga() &#123; Console.WriteLine($\"&#123;this.GetType().Name&#125; 嘎嘎嘎\"); &#125; &#125; class mouse : Ioberver &#123; public void Action() &#123; this.Zhi(); &#125; public void Zhi() &#123; Console.WriteLine($\"&#123;this.GetType().Name&#125; 吱吱吱\"); &#125; &#125;class Cat&#123; public void Miao() &#123; Console.WriteLine(\"&#123;0&#125; miao\",this.GetType().Name); if(this._ObserverList!=null &amp;&amp; this._ObserverList.Count &gt; 0) &#123; foreach (var observer in _ObserverList) &#123; observer.Action(); &#125; &#125; &#125; public List&lt;Ioberver&gt; _ObserverList = new List&lt;Ioberver&gt;(); public void Add(Ioberver observer) &#123; this._ObserverList.Add(observer); &#125; public void Remove(Ioberver observer) &#123; this._ObserverList.Remove(observer); &#125;&#125; 运行结果：","link":"","permalink":"http://zhumingcj.github.io/2019/06/27/Observer Pattern/","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://zhumingcj.github.io/tags/设计模式/"}]},{"title":"ShortCut Key for Typora","date":"2019-06-21T05:36:41.000Z","text":"刚建立了自己的博客，来发一篇文章:smiley: 最近刚学会使用Typora，刚好把一些快捷键整理一下。 常用快捷键 标题 ctrl+1/2/3… 数字表示标题的级数 下划线 ctrl+u 效果：这是下划线 删除线 shift+alt+5 效果：这是删除线 字体加粗 ctrl+b 效果：加粗了 字体倾斜 ctrl+i 效果：倾斜的字 无序列表 -+space+内容 效果 牛奶 面包 巧克力（可嵌套） 引用 &gt;+space或ctrl+shift+q 效果：这是引用 插入地址 ctrl+k 百度 插入表格 ctrl+t 效果： | 周一 | 周二 | 周三 | 周四 | 周五 || ———— | —— | —— | —— | —— || 微积分 | 放假 | 放假 | 放假 | 放假 || 大学物理 | 放假 | 放假 | 放假 | 放假 || 英语 | 放假 | 放假 | 放假 | 放假 | 回到文章顶部 ctrl+home 效果：无法展示:joy: 自动产生目录 [TOC]+enter 效果：(只有一个标题，将就看一下效果) [TOC] 选中一整行 ctrl+l 额，无法展示效果 插入代码块 ctrl+alt+b(可能需要自己设置) 效果： 1234567891011using System;using System.Collections.Generic;using System.Diagnostics;using System.Linq;using System.Text;using System.Threading;using System.Threading.Tasks;public static void main(string[]args)&#123; ConSole.WriteLine(\"Hello World\");&#125; 搜索内容 ctrl+f 替换 ctrl+h 效果：无 强调、着重标记 ctrl+shift+~(tab上面那个) 效果：这是重点 这是重点 则是重点 分隔线 —-+enter或*+enter 效果： 数学公式 $$+enter 效果： |i j k | a+b+c^5=2ab 表情 :+表情的英文单词 效果：:artificial_satellite: 快速创建新文件 ctrl +n 快速关闭 ctrl+w 显示/隐藏大纲 ctrl+l 高亮 == 文字 ==（中间没有空格） 标题变为普通文本 ctrl+0 脚注 效果：这是一个脚注1 行内数学公式 $+esc(然后输入Tex命令) $\\lim_{x\\to\\infty}\\exp(-x)=0$ 上下标 x^2^2 H~2~O 效果：x^2^ H~2~O ​ ​ 1. 注释 &#8617;","link":"","permalink":"http://zhumingcj.github.io/2019/06/21/Tips for Typora/","tags":[{"name":"文本编辑","slug":"文本编辑","permalink":"http://zhumingcj.github.io/tags/文本编辑/"}]},{"title":"my first blog","date":"2019-06-21T00:32:12.000Z","text":"这是我的第一篇blog序章终于成功了很开心 :happy:","link":"","permalink":"http://zhumingcj.github.io/2019/06/21/my-first-blog/","tags":[]}]