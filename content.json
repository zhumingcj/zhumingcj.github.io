[{"title":"three ways of coding","date":"2019-10-02T19:10:04.000Z","text":"三种编码方式：原码、反码、补码学过大学计算机基础的人可能对原码、反码、补码有所了解，但是对于三种编码的意义一脸懵逼或是一知半解，本文希望能透彻的讲清楚三者的意义及联系。清楚地理解原码、反码、补码的概念对于编写嵌入式开发的程序有着巨大的帮助。 原码原码由符号位、真值组成，下面给出一些例子： 二进制原码 对应十进制数 10011001 -25 00111010 57 01010110 86 原码是很直观的一个概念，就是第一位保存符号，第二位保存真值。 反码既然有了原码，又为什么需要反码呢？这要从加减法运算讲起，如果使用原码，我们在运算时需要分两部分计算，即符号位的运算和真值的运算 ，下面用例子来说明。 算式 说明 2+3=00000010+00000011=00000101=5 正数相加，符号位一样运算后还是0，真值位直接相加 2+（-1）=00000010+10000001=00000001 正数和负数相加，符号位不一样，运算后取决于真值大的数的符号，真值位用大值减小值 -2+（-1） 负数相加，符号位相同运算后为1，真值位直接相加 2-3 符号位不同，运算后取决于真值大的数的符号，真值位用大值减小值 -3-（-2） 转换成2-3 可以看到，运算时先去括号进行符号的运算，可以归结为两种情况 两个数的符号相同，如2+3，-2-3，此时符号位不变，真值位相加 两个数的符号位不同，如-3+2,3-4，-4+2，此时一律当成减法来做，符号取决于真值大的数，运算结果的数组为大值减小值。 但是这样的运算法则对计算机来说是很复杂的，对于计算机如果能直接相加而不考虑符号位是最好不过的，但是我们发现2+（-1）=00000010+10000001=10000011=-3，说明原码直接相加的结果是不正确的。为了解决这一问题，反码被创造了出来。反码是在原码的基础上，对于正数保持不变；对于负数保持符号位不变，真值位取反得到的。下面给出例子： 二进制原码 二进制反码 对应十进制数 10011001 11100110 -25 00111010 00111010 57 01010110 01010110 86 现在我们再来考察一下反码的运算 算式 说明 $2+3=(00000010)_反+(00000011)_反=（00000101）_{反}=5$ 正数相加，无误 2+-3=$(00000010)_反+(11111100)_反=(11111110)_反=-1$ 正负数相加，负数的真值大，无误 3+-1=$(00000011)_反+(11111110)_反=(00000001)_反=1$ 正负数相加，正数的真值大，出现错误 3+-2=$(00000011)_反+(11111101)_反=(00000000)_反=0$ 正负数相加，正数的真值大，出现错误 -2+-3=$(11111101)_反+(11111100)_反=(11111001)_反=-6$ 负数相加，出现错误 1+-1=$(00000001)_反+(11111110)_反=(11111111)_反=+0$ 正负数相加且真值相等，结果为+0 +0+(+0)=$(00000000)_反+(00000000)_反=(00000000)_反=+0$-0+(-0)=$(11111111)_反+(11111111)_反=(11111110)_反=-1$ 0+(-0)=$(00000000)_反+(11111111)_反=(11111111)_反=-0$ 由于符号位的存在，导致有+0和-0之分，因此0+0有三种情况，也会产生三种结果 0+(-1)=$(00000000)_反+(11111110)_反=(11111110)_反=-1$-0+(-1)=$(11111111)_反+(11111110)_反=(11111101)_反=-$2 同样由于$\\pm0$的存在导致了不同的运算结果 综上，我们总结出规律(减法一律视为加法，硬件中没有减法器只有加法器)： 正数的反码运算是正确的 正数与负数相加时，当负数的真值大于等于正数时，结果正确 对于正数与负数相加时，当负数的真值小于正数、负数相加的情况，结果错误但都与正确结果相差一 存在+0和-0的问题 分析 反码的意义 根据取反码的定义，我们可以知道对于正数无变化，对于负数相当于取真值相对于127的补，即负数反码的真值和本身的真值之和等于127。 正数与负数反码相加的情况 设正数a的真值为$x_{a}$，负数b的真值为$x_{b}$，记a的反码为$\\tilde a$;记b的反码为$\\tilde b$，则取反码后： $\\tilde a$的真值为$x_{a},\\tilde b$的真值为$127-x_{b}$ 那么$\\tilde a + \\tilde b$的真值为$127+x_{a}-x_{b}$,这里会产生一个进位问题： 当$x_{b}127$产生进位，符号位因为进位置零。相应的实际上正数大于负数,符号 位 正确。 结果的真值为$x_{a}-x_{b}-1$与正确结果相差1，可知错误的产生是由于进位 当$x_{b}&gt;x_{a}$时，$127+x_{a}-x_{b}&gt;127$不进位,符号位任为1，相应的实际上正数小于负数,符号位正确。 结果真值为$x_{b}-x_{a}$,结果正确，到此与上表相符。 对于负数相加的情况，结果的真值为$254-x_{a}-x_{b}$，因为不能溢出，所以$x_{a}+x_{b}&lt;=127$ 当$x_{a}+x_{b}&lt;127$ 时，会发生一个进位，符号位因此置1，符号正确，结果真值为$x_{a}+x_{b}-1$,与上表相符。 当$x_{a}+x_{b}=127$时，不进位，符号位置0，符号错误，结果真值为127，结果错误 总的来看采用反码来运算有以下问题： $\\pm$ 0的问题 进位导致的偏差 边界运算的跳变 补码为了解决反码存在的问题，补码应运而生。在将补码之前，我们来看看如何改进反码。 由上面的分析，我们发现进位的产生导致运算结果与正确的结果相差1，那么我们可以进行修正，由于正数之间的运算没有问题，那么我们不能修正正数，因为这样会引起正数运算的错误，于是我们应该对负数进行修正。 根据式$x_{a}-x_{b}-1$（正负数相加的情况），保持$x_{a}$不变，则只能将-$x_{b}$修正为1-$x_{b}$，往上追溯即把$\\tilde b $的真值修正为$128-x_{b}$，即负数b在取反的基础上，再加一(逆回去的时候也是如此)，经过验证，我们发现负数相加时的问题也解决了。 巧合的是，此时边界问题也得到了解决，简单的来看，我们可以这么想：负数相加，两个数都多加了1，逆回去要减去1，总的来看修正了1；正负数相加，正数大于负数时，负数多加了1，运算结果由于是正的，逆回去的时候不再减1，总的来看修正了1；正负数相加，负数大于正数，负数多加了1，运算结果由于是负的，逆回去的时候减去1，总的来看修正零。这样我们就把上面的错误都修正了。 再来看一下$\\pm0$的问题，我们发现+0取反加1后为00000000，-0取反加1后也为00000000，因此$\\pm0$在某种程度上得到了统一。 在这里我们引出补码，补码的一种计算方式就是取反加一（对于负数，正数补码是本身），但是切记补码不是通过反码定义的，这只是一种巧合而已。在反码中，我们还做了一个规定是-128=10000000，这是因为用补码表示数的时候0只有一种补码，这导致补码少了一个，即10000000没有出现，因此扩充定义。但是-128没有反码，它不在反码表示范围之内。 补码的真正含义不管是补码还是反码，它们都是为了解决带符号运算的问题的。由于数值类型的限制，确定的类型的长度是固定的，因此我们可以通过舍弃进位的方式将负数转为正数。 以8位的数为例： 3+（-2）与3+（256-2）=00000011+（100000000-00000010）=00000011+11111110=00000001 两者的结果是一样的，因为后者产生了一个进位（一个进位代表了256的产生）舍弃后结果也为1。这里不得不拿钟来说事，假设现在钟显示3点，但是走快了一个小时，我们要把它调到2点，方式有两种——我们既可以往后拨1个小时也可以往前拨23个小时，这是因为钟表上只能记录0-23这24个数，3+23=26并不在其中，只能丢弃一个24变为2。因此我们不能分清2与26的区别，也就是说（假设x+y=res,y为负数）我们完全有理由可以认为x+y=res+256，为保证等式的成立，必然有等价关系$y_{左}+256=y_{右}$（左边的式子两边+256，与右边比较，对应相等得出） 按这种方式，我们实际上是对负数做了一个映射，关系为$x_{补}=256+x$,这样x+y和256-x+y在丢弃进位后是一样的（x为负数）。这样，我们构建了这样一个世界：一切减法变加法，一切负数变正数，想求原值逆映射。 下面我们再解释一下为什么负数补码等于反码加一。假设负数x的真值为a,则由于取反保留了符号位，相当于加了1000000即128，真值部分取反，得到的结果的真值为127-a，那么取反得到的数相当于128+127-a=255-a，再加上1等于256-a即补码的定义。 最后给出补码的数学验证，这里我们会用到同余的概念。如果两个数除以同一个数得到的余数相等，则这两个数关于除数同余，例如11%4==35%4，则11与35关于4同余，记为$11\\equiv35(mod \\ \\ 4)$ 由于(x为负数)$x\\equiv x+256(mod \\ \\ 256)$,并且$y\\equiv y(mod \\ \\ 256)$,则根据同余的线性运算法则有： $x+y\\equiv x+y+256(mod \\ \\ 256)$ 在限定了数的范围之后，同余数x+y和x+y+256是一样的，拿钟来说就是相差一圈，但是就结果而言我们无法区分这两种情况，这是一种等效的思想。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/10/03/three-ways-of-coding/","tags":[{"name":"编码","slug":"编码","permalink":"http://zhumingcj.github.io/tags/编码/"}]},{"title":"指针的使用","date":"2019-09-28T12:13:28.000Z","text":"指针的用法指针在C语言中的地位就好比反射之于java/C#，起着十分重要的作用。指针能让萌新落泪，让大神起飞，让C语言屹立不倒。正是指针的存在让C语言变得十分灵活但同样也带来了一些令程序员头疼的问题。 为什么需要指针指针，顾名思义是指向一个地方的标识，与存储有着密切的关系。指针指向内存中的一个地址，这个地址可能包含存储的信息，或者指向信息的指针（指针也一种信息），这样才能很好的管理内存。如果不给内存划分区域，编上地址，我们根本无法描述我们要比信息存储在哪，就行我们定位一个地方也是通过地址来找。以此指针就是告诉程序变量存放的位置，这样程序就能找到地方取出或存入信息。 如何定义指针定义指针只需要在 基本类型后加*即可，以下是示例： 12345int* i_num\\\\指向一个int变量的指针char* ch\\\\指向字符类型的指针float* f_numint** num\\\\指向指针的指针，即num指向的地址存放的也是一个地址struct student* st_point\\\\指向结果体的指针 指针的基操123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//一些简单的准备int a=3;int b[]={23,45,6787,98};int c[4][5];//二维数组，可理解为矩阵 struct task{ int count; char Descirption[50]; };struct student{ char name[20]; int id; void Learning(){ printf(\"Learning something\"); } struct task tasks;};struct student st;//声明指针并赋值int* p=&amp;a;// &amp;是取地址符，获取变量的地址//数组的特性int* p1=b;/*一维数组名是数组存储的首地址，相当于一个指针，不同的是一维数组名是一个指针常量，即指向固定的地址，不能给它赋值来改变其指向的地址（注意是不能赋值，而不是赋值了不改变地址）*/int** p2=c;//类似的，二维数组名是一个二重指针struct student* stp=&amp;st;/*不同于数组，结构体名虽然也是结构体首地址，但不能当成指针传递（实际上数组名也不是指针，只是赋值的时候自动转换了）*///访问指针指向的地址存储的信息，用**a//取出a存储的值*b//取出b的地址存储的值，即b[0]的值23*c//c[0][0]的值 //结构体的不同，用-&gt;('-'加上'&gt;'中间不能有空格)访问，如(*stp).name[0]='a';stp-&gt;id=4;stp-&gt;tasks.count=6;//step.task-&gt;count//这是错误的，-&gt;只适用于结构体指针类型,step.task以不是指针//指针的运算p++;//指针+1，表示指针的地址+一个数据类型长度，对于int型来说是4个字节p--;p+3;--p; 二维数组指针详解在写代码之前我们来看看二维数组在内存中存储的方式 对于一维数组，存储肯定是线性的，但是二维数组并不是以矩阵的形式存储，还是以线性的方式存储，如下图： 对于二维数组可以理解为以一元数组为元素的数组，所以a相当于一个二维指针（但不是），a[0]代表一个一维数组，a[0]是这个数组的名字，即指向a[0][0]到a[0][3]这块内存的首地址。 1234567891011int a[4][4];int*p1;int**p2;p1=a[0];//正确//p2=a;//错误，a实际上不是一个指针p2=(int**)a;//因为a相当于一个指针，因此可以强制转换int(*p2)[4]=a;//这样也可以，P2是二维指针，理解为p2是int[4]的指针p1++;/*指针移动4个字节（1个int的存储大小），因为p1指向的数组存储int，如果移动的距离不是4个字节会导致数据存储重叠或者有空隙，读取的时候会有问题*/p2++;//p2指向的数组以int[4]为元素，因此移动16个字节 指针之痛——野指针在使用指针处理有关数组的问题时往往会简化程序，有相当大的灵活性。但是在使用中往往出现野指针的问题，所谓野指针就是指向不知道的地方的指针。 产生野指针的常见错误有两种： 声明指针后没有初始化，这是初学者经常犯的毛病，不多说。 使用指针的自增运算时没有节制，超出数组存储的范围；操作指针后没有复位，再次操作时出现越界，典型的有使用指针遍历数组后指针指向最后一个元素，但是再次使用指针访问数组前没有复位。 在方法中返回一个局部的指针变量，因为局部变量是有生命周期的，当函数运行完毕就会销毁。函数最后一个语句一般是return，当你return一个指针的时候，这个指针还是存在的，即指针指向地址存储着你需要的信息，但是一旦return执行完毕，这个局部指针就会被销毁（其中的值被销毁，内存的地址编码是固定的，地址是不会被消除的）。当你在外面的程序访问时，你访问的确实还是这个地址，但是里面的内容是不可预测的，因为局部指针销毁后，程序会认为这个地址对应的存储空间是空闲的，会分配给程序中的其他变量。所以从效果上看就像是指针不知道指到哪里去了，也就是野指针。 指针传参与形参传参的区别123456void change_value_1(int a){ a=a*a+1;}void change_value_1(int* a){ *a=(*a)*(*a)+1;} 对于这两个函数，调用执行的效果是不一样的，对于第一个方法，使用的是形参，形参可以看做是函数的局部变量，传递参数的过程可以等效为在函数中声明一个局部变量，再把传递的实参的值赋给这个局部变量。因此我们后续在函数中操作这个变量都不会影响到传递过来的实参，相当于我们开了个副本来操作，当函数执行完毕就会销毁。但如果参数是个指针，同样的我们也是声明一个局部指针，拷贝传参的实参，但是不一样的是：当地址一样时，我们访问的就是同一个变量，所以我们在函数通过局部指针访问和在程序外通过实参访问的是一个变量，修改自然也就会生效。 关于指针有太多的用法和注意点，学好指针是每个合格的C程序员所必须的，本文也只是讲了最基础的语法，指针的运用才是最为迷人的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/09/28/Usage of pointer/","tags":[{"name":"指针","slug":"指针","permalink":"http://zhumingcj.github.io/tags/指针/"}]},{"title":"Web_Spider_3","date":"2019-09-02T04:15:11.000Z","text":"网络爬虫入门教程（3）这篇博客将继续介绍爬虫程序中模拟登陆的解决方法、post方式和信息提取的方法。 使用post方式进行模拟登陆在之前的博客中所介绍的爬虫都是以get的方式来访问服务器的，这篇博客将讲述post方式的基本用法。 前一篇博客引出了登陆问题，（这里解释一下）由于HTTP协议是无状态的（下一次请求并不知道上一次请求的信息），所以登陆之后服务器与浏览器之间进行的各种请求与响应需要确定用户是否登陆，自然而然我们需要一个标志，而cookie就充当了这样一个角色。所以我们要想解决登陆问题，就必须想办法获取cookie，上一篇博客中采用抓包是一种方式，但是显然不是我们想要的，下面就给出纯代码模拟登陆的方法： 在这个代码中，我们要爬取人人网个人页面的html文件，显然需要先进行登陆。在写代码前我们需要用fiddler抓取登陆时的包，找到host的URL和表单数据，为post请求做准备，为解决cookie问题，我们要引入cookiejar这个模块，用cookiejar创建handler再用handler创建opener，此后的请求都使用opener，cookiejar对象在登陆成功后会自动保存cookie 1234567891011121314151617181920212223242526272829303132333435import urllib.requestimport urllib.parseimport http.cookiejar#创建一个cookiejar对象cj=http.cookiejar.CookieJar()#通过cookiejar对象创建一个handlerhandler=urllib.request.HTTPCookieProcessor(cj)#根据handler创建一个openeropener=urllib.request.build_opener(handler)post_url=\"http://www.renren.com/ajaxLogin/login?1=1&amp;uniqueTimestamp=2019822154521\"#这是表单数据，从fiddler中复制过来，改成字典格式form_data={ 'email':'18258317595', 'icode':'', 'origURL':'http://www.renren.com/home', 'domain':'renren.com', 'key_id':'1', 'captcha_type':'web_login', 'password':'567e34db122fc42aa42d8fbe6b76f32beee819ea7aa6639d1e5994ef6c2f85e3', 'rkey':'88c3ce72a86f84868e5006432a0566bc', 'f':'http%3A%2F%2Fwww.renren.com%2F971983124%2Fnewsfeed%2Fphoto', }headers={ 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36 Edge/18.18362', }request=urllib.request.Request(url=post_url,headers=headers)form_data=urllib.parse.urlencode(form_data).encode()response=opener.open(request,form_data)print(response.read().decode())#登陆后再用get请求获取HTML文件get_url=\"http://www.renren.com/971983124/profile\"request=urllib.request.Request(get_url,headers=headers)response=opener.open(request)print(response.read().decode()) post请求的一般格式post请求的格式和get很相似，不同之处在于：get请求传输的数据是querystring，通过拼接的方式附在URL后面，而post传输数据则以表单的方式，相对安全性要高。在编写代码时，get方式要注意参数的拼接，而post方式要以字典的形式把formdata数据传递给服务器。下面再给出一个post方式的例子： 这个例子模拟用户使用百度翻译，获取搜索结果（由于百度采取了加密，所以当我们更改搜索的单词时，爬虫程序会失效，想要破解需要分析js代码，找出加密的方式，理论可行，实际非常困难） 123456789101112131415161718192021222324252627282930import urllib.requestimport urllib.parseword='baby'post_url=\"https://fanyi.baidu.com/v2transapi\"headers={ 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36 Edge/18.18362',# 'Accept': '*/*',# 'Accept-Language': 'zh-Hans-CN,zh-Hans;q=0.5',# 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',# 'X-Requested-With': 'XMLHttpRequest',# 'Accept-Encoding': 'gzip, deflate, br',# 'Host': 'fanyi.baidu.com',# 'Content-Length': '121',# 'Connection': 'Keep-Alive',# 'Cache-Control': 'no-cache', 'Cookie': 'BDRCVFR[k2U9xfnuVt6]=mk3SLVN4HKm; H_PS_PSSID=; delPer=0; PSINO=1; BAIDUID=B25FFDAC5A102DA419F1283CC7BE770D:FG=1; BIDUPSID=B25FFDAC5A102DA419F1283CC7BE770D; PSTM=1567391659; BDORZ=FFFB88E999055A3F8A630C64834BD6D0; yjs_js_security_passport=9dad9c7e98f7c96362e0901326330787f15c901f_1567511321_js; BDUSS=gzQmJoTUlJMTJ4NjRLS0IzdGNPOWZRcGNrT1F-U1dEOFI1N0JvczlnbmJrWlJkRVFBQUFBJCQAAAAAAAAAAAEAAADg1FhMt-e5~c7eutt6bQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANsEbV3bBG1dN2; __yjsv5_shitong=1.0_7_77bc4d143bb6e9e9889cea03584640024746_300_1567511320184_60.247.46.118_8ba4d331; locale=zh; Hm_lpvt_64ecd82404c51e03dc91cb9e8c025574=1567511320; from_lang_often=%5B%7B%22value%22%3A%22zh%22%2C%22text%22%3A%22%u4E2D%u6587%22%7D%2C%7B%22value%22%3A%22en%22%2C%22text%22%3A%22%u82F1%u8BED%22%7D%5D; SOUND_PREFER_SWITCH=1; APPGUIDE_8_0_0=1; to_lang_often=%5B%7B%22value%22%3A%22en%22%2C%22text%22%3A%22%u82F1%u8BED%22%7D%2C%7B%22value%22%3A%22zh%22%2C%22text%22%3A%22%u4E2D%u6587%22%7D%5D; FANYI_WORD_SWITCH=1; Hm_lvt_64ecd82404c51e03dc91cb9e8c025574=1567511320; SOUND_SPD_SWITCH=1; REALTIME_TRANS_SWITCH=1; HISTORY_SWITCH=1', }form_data={ 'from':'en', 'to':'zh', 'query':word, 'transtype':'realtime', 'simple_means_flag':'3', 'sign':'814534.560887', 'token':'4b7ec249cc1766cf4cb6d26480abbce4', }form_data=urllib.parse.urlencode(form_data).encode()request=urllib.request.Request(post_url,headers=headers)response=urllib.request.urlopen(request,form_data)print(response.read().decode()) post方式的表单数据无法在浏览器找到，必须进行抓包来获取。在这个例子中，我们在headers中仅仅模拟User-agent这一项无法获取到html，此时我们应该把header中的内容全部复制过来（Accept-Encoding除外，加入这一项则服务器返回的资源进行了压缩，而我们无法用程序进行解压缩，所以不能加入这一项），当然并不是所有的项都起作用。在这个例子中，经过检验可知header中只有UA和cookie起作用。 页面数据提取的三种方式1.正则表达式（基于python，其他语言或有不同） 匹配单个字符 \\d 匹配一个数字（0-9） \\w 匹配一个字母或数字（0-9 或 a-z 或 A-Z） . 匹配除换行以为所有单字符 [0-9] 匹配一个0-9的数字相当于\\d，非固定形式，也可以[3-7]等等，下同 [a-z] 匹配一个小写英文字符 [A-Z] 匹配一个大写英文字符 [0-9a-z]等 上述的组合，比如这个式子匹配一个数字或小写英文字符，还可以有其他组合 \\n 匹配一个换行符 \\r 匹配一个回车符 \\t 匹配一个制表符 \\v 匹配一个垂直制表符（很少用） 匹配多个字符 \\s 匹配任何空白字符（亲测python包括空格、换行符、制表符、回车符） \\S 匹配任何非空白字符 匹配数量限定符 * 匹配前面的表达式零次或多次 + 匹配前面的表达式一次或多次 ？ 匹配前面的表达式零次或一次 {n} 写在表达式后面，n是一个整数，表示匹配n次（不能多也不能少）。如r”o{p}”可以匹配apple中的“pp”而不能匹配person中的“p” {n,} 写在表达式后面，n是一个整数,表示至少匹配n次（注意，没有{，n}这种形式） {n,m} 写在表达式后面，n，m是一个整数，表示至少匹配n次，至多匹配m次 特殊符号 $ 用在表达式开头，限定从字符串结尾开始匹配，如r”$(app\\w*?)”不能匹配“application”，但是能匹配“wapp” ^ 用在表达式开头，限定从字符串开头开始匹配 \\b 匹配处于边界的字符串，即从开头或结尾开始匹配 \\B 匹配非边界字符串，即匹配处于中间的字符串 () 括号内的表达式所匹配的字符将是你想要获取的，可使用多个括号，但不能嵌套，有多个括号时用\\n(n为括号的标号，n从0开始)代表第n+1个括号。如r”ab(\\w)oul(\\d+)ge\\1”中\\1代表再次匹配第二个括号，且调用方法如re.findall时返回的将是括号内匹配到的内容，单个括号返回字符，多个括号返回列表 ？ 限定非贪婪模式，即匹配?前面的表达式时，尽量匹配最少的字符。如当r”\\d+”会匹配”23232dfe”中的”23232”，而r”\\d+?”只会匹配最少的“2”，因为+限定了最少匹配一个 \\ 逻辑或，\\ 两边的表达式，只要满足一个就会匹配成功，可使用多次 \\ 取消转义，若要匹配上述表格中的符号需要在前面使用\\取消转义，如r”\\?”匹配“?”字符 尾部的修饰符 re.I 大小写不敏感，即匹配时不区分大小写 re.M 多行匹配，作用于^和$。正常模式下r” ^she$”只会匹配第一行中的she，而指定re.M则会匹配每一行中的she re.S 使得.可以匹配包括\\n在内的所有字符 下面是爬虫常用的一些正则表达式： Email地址：^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? Internet URL：[a-zA-z]+://[^\\s] 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=])?$ html标签： 单标签 (&lt;.*?&gt;) 双标签 r”(&lt;\\w+?.?&gt;.?&lt;/.*?&gt;)” 2. xpathxpath是基于树结构来查找标签元素的，因此用来解析HTML非常方便，下面给出xpath的语法 // 选取当前的所有节点（标配的开头） . 选取当前节点（二次Xpath提取时会使用） .. 选取当前节点父节点 @ 选取属性 * 匹配任何元素节点 @* 选取所有有属性的节点 / 从根节点选取，即选取根节点下的元素，如//div/span选取div下的span label[@xxx=”###”] 选取某个有属性xxx,且属性值为###的标签 contains(@property,’key’) 选取有property属性且属性值包含key的元素 starts-with(@property,’key’) 选取有property属性且属性值开头为key的元素 div[text()=’key’] 选取内容为key的div（可换为其他标签） /text() 获取某个元素的文本内容，即html标签之间的内容 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"content\"&gt; &lt;span id=\"button\"&gt; &lt;p link=\"www.baidu.com\"&gt; &lt;div class=\"sp\"&gt;7&lt;/div&gt; &lt;div class=\"main\" name=\"hello\"&gt;65&lt;/div&gt; &lt;div name=\"bjiu\"&gt;7467&lt;/div&gt; &lt;/p&gt; &lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 例如要选择最内层第三个div，xpath可写为： \\\\div[@class=”content”]\\\\p[contains(@link,”baidu”)]\\div[2] 当xpath匹配的不是一个元素而是多个元素时，可以像数组一样使用下标来获取其中的元素 xpath选取出来的元素可以继续用xpath来提取内容，所以当难以一次性的xpath比较难写时，或者要提取的内容处于不同位置单其父级具有相同的结构时可以考虑先定位到父元素，再提取最终想要的内容。 3. beautifulsoup首先要构建一个beautifulsoup的对象 1soup = BeautifulSoup(open('xxx.html', encoding='utf8'), 'lxml') 可以以”.”来访问某个元素的子元素;可以使用字典索引的方式访问元素的属性值 如soup.a[‘herf’]表示提取整个html中a标签的链接 可以通过“.text”或者”get_text()”或者”.string”获取标签中的文本 如soup.div.text/.string/.get_text()表示提取div中的文本。 .text和.string有一些区别，详细请参考https://blog.csdn.net/zqxnum1/article/details/84587357这篇博客 find(label,property=value),选取有属性property且值为value的label，找到一个就返回 find_all(label,property=value)，同上，但是返回一个列表，可通过索引访问其中元素 如：soup.find_all(‘span’,’class’=’gave’)选取所有class=gave的span标签 select(‘标签选择器’) select里面写css中的标签选择器 如：select(div&gt;span&gt;ul)表示选取div下的span下的ul ​ select(.book&gt;span&gt;div)表示选取class=book的元素下的span下的ul 如想了解更多用法，右转官方文档$\\rightarrow$https://beautifulsoup.readthedocs.io/zh_CN/latest/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/09/02/web-spider-3/","tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://zhumingcj.github.io/tags/爬虫/"}]},{"title":"Web Spider_2","date":"2019-08-28T09:25:36.000Z","text":"网络爬虫入门教程（2）接着上一篇博客，这篇博客会具体讲述网络爬虫代码的构建。 何为爬虫相信很多人都听说过网络爬虫，但是就我的经验而言，很多人并不了解它究竟是什么。（问这是一种什么虫子的人 😂 ）实际上网络爬虫只是在网络上收集资源的程序，简单的来说就是去网上批量下载各种资源，并且完成目标内容的提取。 代码编写大纲 想要去网上下载资源，首先得有URL，批量下载资源时URL不能简单的认为获取，而要从网上获取 虽然有了URL就可以访问网页，但是程序毕竟和浏览器不一样，所以得进行伪装 向服务器发起请求，下载资源 编码问题 在网络传输数据时，由于是tcp协议，所以采用字节传输，因此传输的内容（string）要先转换成二进制，同样的，当我们从网上下载得到的信息要进行解码。编码常用的编码字符集有utf-8和gbk两种，在解码时要用编码时的字符集进行解码 URL中只能出现限定的字符，中文、特殊字符不能出现（浏览器地址栏可以显示中文，应该是自动解码了）因此URL在进行拼接完后必须进行编码，否则会报错 代码示例 最简单的爬虫 1234567import urllib.requestimport urllib.parseurl='http://www.baidu.com'response=urllib.request.urlopen(url)#其中decode()函数就是对获得的HTML内容进行解码print(response.read().decode()) 结果如图所示，我们就能得到百度的HTML文件，但是其实我们并没有成功的得到百度的HTML，在第三点中会讲到。 爬取百度贴吧 打开百度贴吧，我们可以得到URL为[https://tieba.baidu.com](https://tieba.baidu.com/)，然后我们输入“励志”，页面跳转，URL变为https://tieba.baidu.com/f?ie=utf-8&amp;kw=励志&amp;fr=search，改变搜索的词多试几次，我们会发现URL变化的只有kw=##这一项，于是我们可以知道##与搜索的内容有关。当然有的浏览器可能地址栏不显示中文（亲测edge显示编码后的内容，Chrome显示中文），但是有相同的规律，于是我们可以猜测##为搜索内容编码后的东西。我们可以通过站长工具这个网站在线进行URL的解码，发现##解码后就是搜索的内容。有时候我们会发现URL可能很长，这时我们可以删掉一些内容，用缩短后的URL进行访问，如果还能访问说明删除的那些参数是多于的，在这个例子中删除头和尾的参数并不影响正常访问，所以程序中的URL与浏览器地址栏中显示的并不一样 1234567891011121314import urllib.requestimport urllib.parse#原始URLurl='https://tieba.baidu.com/'query_string=input('请输入要下载的贴吧:')#urlencode函数需要传递一个字典data={ 'kw':query_string }query_string=urllib.parse.urlencode(data)#URL参数前要加？url=url+'?'+query_stringresponse=urllib.request.urlopen(url)print(response.read().decode()) 这个程序就能下载你想要的贴吧的HTML文件，经验证和在浏览器中搜索得到的是一样的 让代码伪装成服务器 如果像上面那样写程序去访问服务器，有时候可能会被服务器拒绝（其实第一个示例中返回的HTML只有这么短是不正常的，出现这种情况就是因为服务器识破了爬虫的身份），因为，有的服务器可以知道我们不是浏览器而是爬虫程序，所以必须进行伪装,伪装的方法只需要在请求中包含User-Agent这一项，User-Agent表明访问者的身份。User-Agent可以在谷歌浏览器中F12，然后在http请求中找到，也可以自行百度。 12345678910import urllib.requestimport urllib.parseurl='http://www.baidu.com'headers={ 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36',}request=urllib.request.Request(url,headers=headers)response=urllib.request.urlopen(request)print(response.read().decode()) 运行这个程序，我们才会得到百度真正的HTML，如图： 一个综合型的示例，获取指定贴吧的指定页内容，包括了URL拼接、请求构建、文件的写入 123456789101112131415161718192021222324252627282930313233import urllib.requestimport urllib.parseimport osba_name=input('请输入要查询的贴吧名')start_page=int(input('请输入起始页'))end_page=int(input('请输入结束页'))#创建用来保存的文件夹if not (os.path.exists(ba_name)): os.mkdir(ba_name)#URL中不变的内容url='http://tieba.baidu.com/f?ie=utf-8&amp;'data={ 'kw':ba_name, }url+=urllib.parse.urlencode(data)for page in range(start_page,end_page+1): #此处str((page-1)*50)这个规律是通过观察的出的--在浏览器访问不同页数，观察URL的变化，在这个例子中起始页URL中pn=0，第二页pn=50,第三页pn=100...规律可得 url_new=url+('&amp;pn='+str((page-1)*50))# print(url_new) proxy=urllib.request.ProxyHandler() opener=urllib.request.build_opener(proxy) headers={ 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36', } request=urllib.request.Request(url=url_new,headers=headers) print('第%s页开始下载...'% page) response= opener.open(request) filename=ba_name+'_'+ str(page) + '.html' filepath=ba_name+'/'+filename with open(filepath,'wb')as fp: fp.write(response.read()) print('第%s页结束下载...'% page) 运行这个程序我们就可以得到HTML文件（貌似不怎么完整，应该是百度搞了防盗措施），但是这个例子是很理想化的，在大多数情况下我们很有可能找不到页码变化和URL变化之间的规律 为了解决页码变化和URL变化“无联系”（联系肯定有，只是做了加密）的问题，我们可以从已经得到HTML中获取下一页的URL，因为在浏览器中我们去往下一页需要点击某“下一页”的按钮，如果了解HTML语言，我们就知道“下一页”按钮在HTML中就是一个a标签，而a标签中就会有下一页的URL，因为涉及到内容的解析，这只做说明，相关例子将在下一篇博客中给出。 正所谓道高一尺，魔高一丈，爬虫多了对服务器来说压力会很大，所以很多服务器会有反爬的措施，常见的有防盗链、ip检测、验证码等等，其中比较好处理的是ip检测。要想解决ip检测的问题首先你得有代理服务器（网上可租，也有免费的，哎，免费的不敢保证），通过代理的方式我们就能避免这个问题。代理这个概念在生活中很常见，代理就是找第三方帮你做事，也就是爬虫程序不直接向服务器发起请求，而是由代理服务器向服务器发起请求，然后再返回给爬虫程序，因此服务器不会知道你的ip，也就封不了。 12345678910111213141516171819import urllib.requestimport urllib.parseurl = 'http://www.baidu.com/'#设置代理，在ProxyHandler中传入代理ip加端口号proxy = urllib.request.ProxyHandler({'http': 'http://127.0.0.1:8888/'})#创建一个打开器，opener比urlopen强大得多，有很多urlopen做不到的功能，比如代理、验证cookieopener = urllib.request.build_opener(proxy)#install_opener会使得代理全局生效，即使用urlopen方法其实会调用创建的opener的open方法urllib.request.install_opener(opener)headers={ 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36', }request=urllib.request.Request(url=url,headers=headers)response =urllib.request.urlopen(request)print(response) 对于需要登录的网站，如果我们采取上面的方法来下载HTML文件，虽然可能不报错，但是肯定获取不到HTML文件。这说明我们没有完全模仿浏览器，这时如果我们在谷歌浏览器中审查元素，把http协议中的请求头黏贴到headers中，再运行程序发现又可以获取到HTML了。其实在登录过程中，服务器的响应中会返回设置cookie的一个命令，然后浏览器就会保存这个cookie，作为登录过的凭证，每次浏览器访问登录后才能访问的内容时都要携带这个cookie服务器才会返回请求的资源，解决登录问题简单粗暴的方法就是在浏览器找到cookie粘贴到headers中，如 12345678910111213import urllib.requestimport urllib.parseurl='http://www.renren.com/971983124/newsfeed/photo'headers={ 'user-agent': 'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50', 'Cookie': 'anonymid=jzjetqke-tjiod7; depovince=BJ; _r01_=1; JSESSIONID=abcj8ylTjQ-n3_4qbLTYw; ick_login=5929d602-a414-4f1b-b8fa-83f01844c486; t=fdfdca524711412440e3aa2f89ddd00a4; societyguester=fdfdca524711412440e3aa2f89ddd00a4; id=971983124; xnsid=526b61a2; ver=7.0; loginfrom=null; jebe_key=5d8a8bf3-cf7c-441b-bc60-65f236cb5832%7Cbf794041c970cd1607a6fc82acb47392%7C1566280296884%7C1%7C1566280297531; jebe_key=5d8a8bf3-cf7c-441b-bc60-65f236cb5832%7Cbf794041c970cd1607a6fc82acb47392%7C1566280296884%7C1%7C1566280297535; wp_fold=0; jebecookies=576b6d5f-c52d-4d79-a6a6-6724e7aa3b0a|||||' }request=urllib.request.Request(url,headers=headers)response=urllib.request.urlopen(request)with open('renren.html','wb')as fp: fp.write(response.read()) 当然这个cookie早已过期，现在运行无法得到任何东西 限于篇幅，更好的解决cookie的方法将在下一篇博客中给出 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/08/28/web-spider-2/","tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://zhumingcj.github.io/tags/爬虫/"}]},{"title":"Web Spider_1","date":"2019-08-28T02:44:35.000Z","text":"网络爬虫入门教程（1）刚入门网络爬虫，期望通过三篇博客来总结一下入门级爬虫程序的写法，希望能给那些想要入爬虫这个坑的人提供一些帮助。为了结构化的介绍爬虫，将分为：http协议、网络爬虫代码构建、内容提取三篇博客进行全面的讲解。 注：写爬虫要遵守相关法规，不能侵犯他人著作权！！！（简单的来说免费的网站都能爬，付费的很难爬也不能以此盈利，否则有前车之鉴，千万赔偿劝退） http协议下面先列出以下http协议的特性，但与爬虫关系不大，仅作了解（想要详细了解http，参见这篇博客）： http协议是明文传送非加密的，即是不安全的 http协议是无状态的，这并不是只连接（TCP）无状态，而是指服务器不会记录前一次访问的信息，通俗的讲就是： 浏览器：服务器，你欠我一百万 服务器：好，我给你一百万 浏览器：服务器，你还是欠我一百万 服务器：（傻傻的）给你一百万…. 也就是说，即使浏览器发起N多个相同的请求，服务器都会响应 http协议连接不上持续的，即每次连接只处理一个请求，处理完就关闭连接，下一个请求会新建一个连接而不是保持前一个连接继续处理。 http的内容（重点）一个完整的http协议由请求行、请求头、空行、请求体四部分组成，下图是一个示例： 请求行：请求方法+URL+http版本号 请求方法常见的有： get（最多）：向服务器请求某个资源，get会把数据（参数）拼接在URL中，在浏览器地址栏中可见，一般为？key=value&amp;key=value……的形式如https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1，因此get的安全性较低 post:用于向服务器提交数据，常见的场合为用户登录、注册等，post传输数据在请求体中，对用户不可见，安全性相对较高 其他还有（仅作了解，很少碰到）： OPTIONS - 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。 HEAD- 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。 PUT - 向指定资源位置上传其最新内容。DELETE - 请求服务器删除Request-URI所标识的资源。 TRACE- 回显服务器收到的请求，主要用于测试或诊断。 CONNECT - HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 PATCH - 用来将局部修改应用于某一资源，添加于规范RFC5789。 请求头：有多个部分，下面列出常见的 Accept：指定客户端能够接收的内容 Accept-Language：指定客户端能够接受的语言 Accept-Ecoding：指定客户端能够接受的编码类型 User-Agent：用户代理，向服务器说明自己的操作系统、浏览器等信息 Connection：是否开启持久连接（keepalive） Host： 服务器域名 Cookie：最重要的请求头之一, 将cookie的值发送给HTTP服务器。 Content-Length：表示请求消息正文的长度。例如：Content-Length: 38。 请求体：请求的正文，内容不一，也可空http的响应HTTP响应由三部分组成：状态行、响应头、响应正文； 状态行：包括协议版本Version、状态码Status Code、回应短语； 响应头：包括搭建服务器的软件，发送响应的时间，回应数据的格式等信息； 响应正文：就是响应的具体数据。 下面是一个示例 其中常见的状态码有： ​ 200—-OK/请求已经正常处理完毕 ​ 301—-/请求永久重定向 ​ 302—-/请求临时重定向 ​ 304—-/请求被重定向到客户端本地缓存 ​ 400—-/客户端请求存在语法错误 ​ 401—-/客户端请求没有经过授权 ​ 403—-/客户端的请求被服务器拒绝，一般为客户端没有访问权限 ​ 404—-/客户端请求的URL在服务端不存在 ​ 500—-/服务端永久错误 ​ 503—-/服务端发生临时错误 想要编写爬虫程序就一定要对http协议有所了解，这篇博客只是大概地讲述了http协议，对于简单的爬虫程序已然够用，如果想深入的了解http协议，请移步下列博客 https://segmentfault.com/a/1190000015969377 https://blog.csdn.net/aliujiujiang/article/details/81088317 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/08/28/web-spider-1/","tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://zhumingcj.github.io/tags/爬虫/"}]},{"title":"Solution to VS2017 Installation Problem","date":"2019-08-17T00:13:48.000Z","text":"VS2017安装中注册表问题的解决今天在安装VS2017时碰到了一个棘手的问题导致所有的组件都无法使用，经过半天的捣鼓最终解决了以下的问题。 注册表权限问题 如果你的电脑里曾经安装过visual studio的产品，但是卸载的时候没有清除注册表，那么下一次安装的时候就可能出现下述情况： 在安装Vs2017时会显示安装完成，但存在警告，打开VS2017exe文件创建项目时只有空白解决方案，找不到其它的模板，并且当我们查看日志详情时会显示下面的内容： 详细信息MSI: C:\\ProgramData\\Microsoft\\VisualStudio\\Packages\\Microsoft.VisualStudio.MinShell.Msi.Resources,version=15.0.26621.2,language=zh-CN\\Microsoft.VisualStudio.MinShell.Msi.Resources.msi，属性: REBOOT=ReallySuppress ARPSYSTEMCOMPONENT=1 MSIFASTINSTALL=”7” VSEXTUI=”1”返回代码: 1603返回代码详细信息: 安装时发生严重错误消息 ID: 1402消息详细信息: 无法打开注册表项\\HKEY_LOCAL_MACHINE32\\SOFTWARE\\Microsoft\\Internet Explorer\\Main\\FeatureControl\\FEATURE_BLOCK_CROSS_PROTOCOL_FILE_NAVIGATION。请确认你是否有足够的权限访问该注册表项，或者与技术支持人员联系。 其中注册表项$\\times\\times\\times$的内容可能因计算机而异。 解决方法： 根据日志的提示可知是注册表的权限存在问题，导致安装程序无法访问。在这里我们可以使用快捷键win+R打开命令行，然后输入regedit进入注册表的管理。 在这里我遇到了一个大坑，按照日志的提示我们应该修改\\HKEY_LOCAL_MACHINE32\\SOFTWARE\\Microsoft\\Internet Explorer\\Main\\FeatureControl\\FEATURE_BLOCK_CROSS_PROTOCOL_FILE_NAVIGATION的权限，但是64位的电脑根本没有HKEY_LOCAL_MACHINE32这一项，如果忽略32，则在\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Internet Explorer\\Main\\FeatureControl下也无法找到FEATURE_BLOCK_CROSS_PROTOCOL_FILE_NAVIGATION，当然自己新建一个注册表也无济于事。 反复试了几次后我一度放弃，但是想到32可能是32位电脑的情况后跑去百度了一下，在翻阅了大量博客和论 坛之后终于在Microsoft TechNet的论坛上找到了答案，原来在64位的电脑上HKEY_LOCAL_MACHINE32\\Software会自动定向到HKEY_LOCAL_MACHINE\\Software\\Wow6432Node，所以我们要修改的权限应该是\\HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\Internet Explorer\\Main\\FeatureControl\\FEATURE_BLOCK_CROSS_PROTOCOL_FILE_NAVIGATION才对。 具体修改时，可能一开始显示没有访问权限，但是我们可以右键-&gt;权限-&gt;添加组或用户名,添加的时候把Administrator和system都添加进去，并且它们要有完全控制的权限。 然后在重新安装后重启电脑就没问题了（可能还会警告，那也是同样的问题，参照日志该注册表权限就行，直到不报错）。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/08/17/solution-to-vs2017-installation-problem/","tags":[{"name":"软件安装问题","slug":"软件安装问题","permalink":"http://zhumingcj.github.io/tags/软件安装问题/"}]},{"title":"QR_Decomposition_2","date":"2019-08-11T05:06:47.000Z","text":"QR分解（2）QR分解是线性代数中一种常用的矩阵分解，即把矩阵分解为一个正规正交矩阵和一个上梯形矩阵——QR分解是求一般矩阵全部特征值的最有效并广泛应用的方法，同时也是许多迭代算法的基础。（QR分解续篇） 豪斯霍尔的变换法 豪斯霍尔德变换定义 设u\\in R^{n}且||u||_{2}=1，矩阵H=I-2uu^{T}称为豪斯霍尔德矩阵 豪斯霍尔德矩阵的性质 H矩阵是一个正交矩阵 证：\\\\ HH^{T}=(I-2uu^{T})(I-2uu^{T})\\\\ =I-4uu^{T}+4uu^{T}uu^{T}\\\\ =I-4uu^{T}+4u(u^{T}u)u^{T}\\\\ =I-4uu^{T}+4uu^{T} =I 直观的来看，豪斯霍尔德变换是一个镜像变换，如图 豪斯霍尔德矩阵的作用是把向量x映射到以π为镜面的像，其中平面π的法向量为u 基于豪斯霍尔德变换的QR分解引理： 设\\ x\\in R^{n}是任意的给定非零向量，v\\in R^{n}是任意给定的单位向\\\\量，则存在初等反射矩阵H=I-2uu^{T},使得Hx=\\sigma v，其中\\sigma为常数证明： \\because v为单位向量\\\\ \\therefore x^{T}H^{T}Hx=\\sigma^{2}v^{T}v=\\sigma^{2}=||x||_{2}^{2}\\Rightarrow\\\\ \\sigma=\\pm\\sqrt{||x||_{2}}\\\\ 又\\because Hx=(I-2uu^{T})x=x-2uu^{T}x=x-2(u^{T}x)u=\\sigma v\\\\ \\therefore u的方向与x-\\sigma v方向相同\\\\ \\because u是单位向量\\\\ \\therefore u=\\frac{x-\\sigma x}{||x-\\sigma x||_{2}}\\\\ \\therefore u存在且唯一，从而H存在注：其中计算σ时，为避免舍入误差，应取$\\sigma=-sgn(x_{1})||x||_{2}$ 实际上根据豪斯霍尔德变换的几何意义，我们可以把x看做原向量，v 看成变换后镜像向量的一个单位向量，则u向量方向一定为原向量（x）减去原向量（想）模长倍的镜像向量（v）。单位化后即为所要求的u。 QR分解的过程： 设要分解的矩阵为：\\\\ \\quad\\\\ A= \\begin{pmatrix} a_{11}&a_{12}&\\dots&a_{1n}\\\\ a_{21}&a_{22}&\\dots&a_{2n}\\\\ \\vdots&\\vdots&&\\vdots\\\\ a_{m1}&a_{m2}&\\dots&a_{mn} \\end{pmatrix}= (a_{1},a_{2},\\dots,a_{n})\\\\ \\quad\\\\ 记为\\\\ A^{(0)}=(a_{1}^{(0)},a_{2}^{(0)},\\dots,a_{n}^{(0)})=A\\\\ \\quad\\\\ 第一步：\\\\ 为把矩阵A的第一列化为(\\sigma,0,\\dots,0)^{T},取x=a_{1}^{(0)},v=e_{1}=(1,0,\\dots,0)^{T}\\\\ 根据式（4），取\\\\ u_{1}=\\frac{a_{1}^{(0)}-\\sigma_{1} e_{1}}{||a_{1}^{(0)}-\\sigma _{1}e_{1}||_{2}}=\\frac{w_{1}}{||w_{1}||_{2}}\\\\ 其中\\sigma_{1}=-sgn(a_{1}^{(0)})||a_{1}^{(0)}||_{2},\\ w_{1}=a_{1}^{(0)}-\\sigma_{1}e_{1}\\\\ 而\\\\ ||w_{1}||_{2}=||a_{1}^{(0)}-\\sigma_{1}e_{1}||_{2}=\\sqrt{2(\\sigma_{1}^{2}-\\sigma_{1}a_{11}^{(0)}})\\\\ 2u_{1}u_{1}^{T}=\\frac{2w_{1}w_{1}^{T}}{||w_{1}||_{2}^{2}}=\\frac{w_{1}w_{1}^{T}}{\\sigma_{1}(\\sigma_{1}-a_{11}^{(0)})}=\\frac{w_{1}w_{1}^{T}}{\\alpha_{1}},\\alpha_{1}=\\sigma_{1}(\\sigma_{1}-a_{11}^{(0)})\\\\ 令H_{1}=I-2u_{1}u_{1}^{T}=I-\\alpha^{-1}w_{1}w_{1}^{T},用H_{1}左乘A^{(0)}得\\\\ A^{(1)}=H_{1}A^{(0)}=(H_{1}a_{1}^{(0)},H_{1}a_{2}^{(0)},\\dots,H_{1}a_{n}^{(0)})\\\\ =(\\sigma_{1} e_{1},a_{2}^{(1)},a_{3}^{(1)},\\dots,a_{n}^{(1)})\\\\ = \\begin{pmatrix} \\sigma_{1}&a_{12}^{(1)}&a_{13}^{(1)}&\\dots&a_{1n}^{(1)}\\\\ 0&a_{22}^{(1)}&a_{23}^{(1)}&\\dots&a_{2n}^{(1)}\\\\ \\vdots&\\vdots&\\vdots&&\\vdots\\\\ 0&a_{m2}^{(1)}&a_{m3}^{(1)}&\\dots&a_{mm}^{(1)} \\end{pmatrix}\\\\ \\quad\\\\ 其中\\\\ a_{j}^{(1)}=H_{1}a_{j}^{(0)}=a_{j}^{(0)}-\\beta_{1j}(a_{1}^{(0)}-\\sigma_{1}e_{1})\\\\ = \\begin{pmatrix} a_{1j}^{(0)}-\\beta_{1j}(a_{11}^{(0)}-\\sigma_{1})\\\\ a_{2j}^{(0)}-\\beta_{1j}a_{21}^{(0)}\\\\ \\vdots\\\\ a_{mj}^{(0)}-\\beta_{1j}a_{mj}^{(0)} \\end{pmatrix}\\\\ 由此可得\\\\ \\left\\{ \\begin{array}{} a_{1j}^{(1)}=a_{1j}^{(0)}-\\beta_{1j}(a_{11}^{(0)}-\\sigma_{1}),\\quad j=2,3,\\dots,n\\\\ a_{ij}^{(1)}=a_{ij}^{(0)}-\\beta_{1j}a_{i1}^{(0)},\\quad i=2,3,\\dots,m;j=2,3,\\dots,n \\end{array} \\right.\\\\ 其中\\\\ \\beta_{ij}=\\alpha_{1}^{-1}((a_{11}^{(0)}-\\sigma_{1})a_{1j}^{(0)}+\\sum_{i=2}^{m}a_{i1}^{(0)}a_{ij}^{(0)}),\\quad j=2,3,\\dots,n\\\\ \\quad\\\\ 第二步:\\\\ 记a_{2}^{(1)}=(a_{12}^{(1)},a_{22}^{(1)},\\dots,a_{m2}^{(1)})^{T}=(a_{12}^{(1)},\\widetilde a_{2}^{(1)T})^{T}\\\\ 重复第一步取\\\\ u_{2}=\\frac{\\widetilde a_{2}^{(1)}-\\sigma_{2}e_{1}^{(1)}}{||\\widetilde a_{2}^{(1)}-\\sigma_{2}e_{1}^{(1)}||_{2}}=\\frac{w_{2}}{||w_{2}||_{2}}\\\\ \\sigma_{2}=-sgn(a_{22}^{(1)})||\\widetilde a_{2}^{(1)}||_{2};w_{2}=\\widetilde a_{2}^{(1)}-\\sigma_{2}e_{1}^{(1)}\\\\ 构造\\\\ \\widetilde {H_{2}}=I-2u_{2}u_{2}^{T}=I-\\alpha^{-1}w_{2}w_{2}^{T} 令\\\\ H_{2}= \\begin{pmatrix} 1&0\\\\ 0&\\widetilde H_{2} \\end{pmatrix}\\\\ 用H_{2}左乘A_{(2)}得\\\\ A^{(2)}=H_{2}A^{(1)}=(\\sigma_{1}e_{1},a_{12}^{(1)}e_{1}+\\sigma_{2}e_{2},a_{3}^{(2)},\\dots,a_{n}^{(2)})\\\\ =\\begin{pmatrix} \\sigma_{1}&a_{12}^{(1)}&a_{13}^{(1)}&a_{14}^{(1)}&\\dots&a_{1n}^{(1)}\\\\ 0&\\sigma_{2}&a_{23}^{(2)}&a_{24}^{(2)}&\\dots&a_{2n}^{(2)}\\\\ 0&0&a_{33}^{(2)}&a_{34}^{(2)}&\\dots&a_{3n}^{(2)}\\\\ \\vdots&\\vdots&\\vdots&\\vdots&&\\vdots\\\\ 0&0&a_{m3}^{(2)}&a_{m4}^{(2)}&\\dots&a_{mn}^{(2)} \\end{pmatrix}\\\\ 继续重复这个过程直至s=min{m-1,n}步，最后得到\\\\ A^{(s)}=H_{s}H_{s-1}\\dots H_{1}A=R\\\\ 记\\\\ H=H_{s}H_{s-1}\\dots H_{1}A\\\\ 则\\\\ HA=R \\Rightarrow A=QR 当m=n时,R是n阶可逆上三角矩阵 当m&gt;n时，R是$m \\times n$阶上梯形矩阵 $\\bigstar$ 矩阵的QR分解具有唯一性 证明\\\\ 设存在两种分解 \\quad A=QR=\\widetilde Q \\widetilde R\\\\ \\because A^{T}A=R^{T}QQR=R^{T}R\\\\ A^{T}A=\\widetilde R^{T} \\widetilde Q \\widetilde Q \\widetilde R=\\widetilde R^{T} \\widetilde R\\\\ 又\\because A^{T}A是对称正定的，且矩阵的楚列斯基分解是唯一的\\\\ \\therefore R=\\widetilde R,\\quad Q=\\widetilde Q$\\bigstar$ QR分解常用于求解病态线性方程组Ax=b，即化为 y=Q^{T}b,\\quad Rx=y通过这种方法求解线性方程是非常稳定的，得到的结果往往比三角分解好很多。 豪斯霍尔德法QR分解的程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251class Program { static void Main(string[] args) { //验证程序正确性的demo Matrix m = new Matrix(3, 3); Matrix[] result_QR = m.QR_Decomposition(); result_QR[0].DisPlay(); Console.WriteLine(); result_QR[1].DisPlay(); Matrix n = result_QR[0] * result_QR[1]; Console.WriteLine(); n.DisPlay(); } //单位阶跃函数 public static int Sgn(float num) { if (num &lt; 0) { return -1; } else if (num == 0) { return 0; } else { return 1; } } \\\\类的封装 class Matrix { \\\\初始化及构造函数 public int row = 0; public int column = 0; private float[,] matrix; public Matrix(int row, int column, int option) { this.row = row; this.column = column; matrix = new float[row, column]; if (option == 1) { for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; column; j++) { if (i == j) { matrix[i, i] = 1; } else { matrix[i, j] = 0; } } } } } public Matrix(int row, int column) { this.row = row; this.column = column; Console.WriteLine($\"Please enter a matrix with {this.row}rows,{this.column}colums\"); matrix = new float[row, column]; try { for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; column; j++) { string mid = Console.ReadLine(); var rows = mid.Split(' '); foreach (var item in rows) { matrix[i, j++] = float.Parse(item); } } } Console.WriteLine(\"\\r\\n\"); } catch (Exception e) { Console.WriteLine($\"something wrong!\\n{e.Message}\"); } } \\\\矩阵运算的重载 public static Matrix operator -(Matrix p1, Matrix p2) { if (p1.row == p2.row &amp;&amp; p1.column == p2.column) { Matrix result = new Matrix(p1.row, p1.column, 0); for (int i = 0; i &lt; p1.row; i++) { for (int j = 0; j &lt; p1.column; j++) { result.matrix[i, j] = p1.matrix[i, j] - p2.matrix[i, j]; } } return result; } else { throw new Exception(); } } public static Matrix operator *(float multip, Matrix p1) { Matrix result = new Matrix(p1.row, p1.column, 0); for (int i = 0; i &lt; p1.row; i++) { for (int j = 0; j &lt; p1.column; j++) { result.matrix[i, j] = p1.matrix[i, j] * multip; } } return result; } public static Matrix operator *(Matrix p1, Matrix p2) { if (p1.column != p2.row) { //Matrix a = new Matrix(1, 2) { matrix = p1.matrix }; throw new Exception(); } else { Matrix result = new Matrix(p1.row, p2.column, 0); for (int i = 0; i &lt; p1.row; i++) { for (int j = 0; j &lt; p2.column; j++) { float temp = 0; for (int k = 0; k &lt; p1.column; k++) { temp += p1.matrix[i, k] * p2.matrix[k, j]; } result.matrix[i, j] = temp; } } return result; } } //矩阵转置 public void Transpose() { this.row = column + row; this.column = row - column; this.row = row - column; float[,] temp = new float[row, column]; for (int i = 0; i &lt; this.row; i++) { for (int j = 0; j &lt; this.column; j++) { temp[i, j] = matrix[j, i]; } } matrix = temp; } \\\\生成反射矩阵（豪斯霍尔德矩阵） public Matrix ReflectMatrix(int order, Matrix column_vec, int suborder) { Matrix Reflect_matrix = new Matrix(order, order, 1); \\\\生成单位向量 Matrix unit_vec = new Matrix(column_vec.row, column_vec.column, 1); \\\\生成单位矩阵 Matrix unit_matrix = new Matrix(suborder, suborder, 1); \\\\需要使用临时变量存储转置矩阵（临时变量初始化不能直接赋值column_vec）,原因是：matrix是引用类型，赋值的方式只是使变量指向同一个对象，进行转置操作时会丢失原来的矩阵，下同 Matrix temp_1 = new Matrix(column_vec.row, column_vec.column, 0); temp_1.matrix = column_vec.matrix; temp_1.Transpose(); \\\\根据算法，计算相应参数 float sigma = -Sgn(column_vec.matrix[0, 0]) * (float)Math.Sqrt((temp_1 * column_vec).matrix[0, 0]); float alpha = sigma * (sigma - column_vec.matrix[0, 0]); Matrix omega = column_vec - sigma * unit_vec; Matrix temp_2 = new Matrix(omega.row, omega.column, 0); temp_2.matrix = omega.matrix; temp_2.Transpose(); if (order == suborder) { Reflect_matrix = unit_matrix - (1 / alpha) * omega * temp_2; } else { Matrix temp_matrix = unit_matrix - (1 / alpha) * omega * temp_2; for (int i = order - suborder; i &lt; order; i++) { int start_value = order - suborder; for (int j = start_value; j &lt; order; j++) { Reflect_matrix.matrix[i, j] = temp_matrix.matrix[i - start_value, j - start_value]; } } } return Reflect_matrix; } //QR分解主程序 public Matrix[] QR_Decomposition() { //准备储存结果的容器 Matrix result_Q = new Matrix(this.column, this.column, 1); Matrix result_R = new Matrix(this.row, this.column, 0); result_R.matrix = this.matrix; //按列把待分解的矩阵化为上三角矩阵或上梯形矩阵 for (int i = 0; i &lt; column; i++) { Matrix column_vec = new Matrix(row - i, 1, 0); for (int j = 0; j &lt; row - i; j++) { column_vec.matrix[j, 0] = result_R.matrix[j + i, i]; } Matrix reflect_matrix = ReflectMatrix(row, column_vec, row - i); result_Q = reflect_matrix * result_Q; result_R = reflect_matrix * result_R; } result_Q.Transpose(); Matrix[] result = { result_Q, result_R }; return result; } //仅用于矩阵的打印 public void DisPlay() { for (int i = 0; i &lt; this.row; i++) { for (int j = 0; j &lt; this.column; j++) { Console.Write(string.Format(\"{0:F3}\", matrix[i, j]) + \" \"); } Console.WriteLine(\"\\r\"); } } } } 同样使用两个例子验证算法的正确性： 输入矩阵 A= \\begin{pmatrix} 3&5&5\\\\ 0&3&4\\\\ 4&0&5 \\end{pmatrix}得到输出如下图 输入矩阵 B= \\begin{pmatrix} 3 &14 &9\\\\ 6 &43 &3\\\\ 6 &22 &15\\\\ \\end{pmatrix}得到结果如下图： 经过检验，基本可以确定程序是正确的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/08/11/qr-decomposition-2/","tags":[{"name":"Matrix","slug":"matrix","permalink":"http://zhumingcj.github.io/tags/matrix/"}]},{"title":"QR decomposition","date":"2019-08-08T08:22:38.000Z","text":"QR分解(1)QR分解是线性代数中一种常用的矩阵分解，即把矩阵分解为一个正规正交矩阵和一个上梯形矩阵——QR分解是求一般矩阵全部特征值的最有效并广泛应用的方法，同时也是许多迭代算法的基础。 QR分解的导出QR分解可以通过两种基本的正交变换来导出——吉文斯变换和豪斯霍尔德变换，下面将详细地给出两种正交变换推导QR分解的过程。 吉文斯变换法 吉文斯变换的定义 对某个\\theta，记s=sin\\theta,c=cos\\theta,设1\\leq i \\lt j \\leq n\\\\ P(i,j,\\theta)= \\begin{pmatrix} 1&\\\\ &\\ddots\\\\ &&1\\\\ &&&c&&&&s\\\\ &&&&1\\\\ &&&&&\\ddots\\\\ &&&&&&1\\\\ &&&-s&&&&c\\\\ &&&&&&&&1\\\\ &&&&&&&&&\\ddots\\\\ &&&&&&&&&&1 \\end{pmatrix}_{n\\times n} 吉文斯变换的特性 通过计算我们可以得到$P(i,j,\\theta)\\times P(i,j,\\theta)^{T}=I$，因此吉文斯变换矩阵是一个正交矩阵。 当吉文斯矩阵左乘一个方阵x时（$P(i,j,\\theta)x$），只会改变x的第i个和第j个分量。 事实上，设x=(x_{1},x_{2},\\dots,x_{n})^{T},y=(y_{1},y_{2},\\dots,y_{n})^{T}\\\\ 则根据y=P_{i,j}x可得\\\\ y_{i}=cx_{i}+sx_{j},\\quad y_{j}=-sx_{i}+cx_{j} 直观的看，吉文斯变换是一个平面旋转矩阵。由上一条性质，我们知道吉文斯矩阵只改变x的i,j分量，这种改变的几何意义是：它会把x在i,j平面的投影顺时针旋转$\\theta$度，以二维的吉文斯矩阵为例： P_{(1,2)}= \\begin{pmatrix} cos\\theta&sin\\theta\\\\ -sin\\theta&cos\\theta \\end{pmatrix}_{2\\times2} \\quad\\\\ 当我们取\\theta为\\frac{\\pi}{2}时，我们得到\\\\ P= \\begin{pmatrix} 0&1\\\\ -1&0 \\end{pmatrix} 用P左乘于x=(1,2)^{T}得到x'=(2,-1)\\\\我们可以看到x在P的作用下顺时针旋转了90^{\\circ} 吉文斯矩阵可以将给定向量的某个分量化为零，由第二个特性，我们可以得到以下结论： 当x_{i}^{2}+x_{j}^{2}\\neq0时，欲使x_{j}'=0,只需要选取\\\\ c=\\frac{x_{i}}{\\sqrt{x_{i}^{2}+x_{j}^{2}}},s=\\frac{x_{j}}{\\sqrt{x_{i}^{2}+x_{j}^{2}}} 也可以直观的理解为将给定向量在i,j平面的分量旋转至与i坐标轴重合，显然这种旋转存在且旋转角度就是上式所给出的。 基于吉文斯变换的QR分解 思路：由于QR分解的形式是分解为一个上梯形矩阵和一个正交矩阵，因此可以考虑用若干个吉文斯矩阵的乘积将给定矩阵化为上三角矩阵。 引理：设x是任意给定的非零向量，则存在有限个吉文斯矩阵的乘积P，使得$Px=||x||_{2}\\vec e_{1}$，其中$\\vec e_{i}=(1,0,\\dots,0)$ 证明： 根据吉文斯矩阵的最后一条特性，依次构造 P_{12}:c=\\frac{x_{1}}{\\sqrt{x_{1}^{2}+x_{2}^{2}}},\\quad s=\\frac{x_{2}}{\\sqrt{x_{1}^{2}+x_{2}^{2}}}\\\\ \\quad\\\\ P_{12}x=(\\sqrt{x_{1}^{2}+x_{2}^{2}},0,x_{3},\\dots,x_{n})^{T};\\\\ \\quad\\\\ P_{13}:c=\\frac{\\sqrt{x_{1}^{2}+x_{2}^{2}}}{\\sqrt{x_{1}^{2}+x_{2}^{2}+x_{3}^{2}}},\\quad s=\\frac{x_{3}}{\\sqrt{x_{1}^{2}+x_{2}^{2}+x_{3}^{2}}}\\\\ \\quad\\\\ P_{12}x=(\\sqrt{x_{1}^{2}+x_{2}^{2}+x_{3}^{2}},0,0,x_{4},\\dots,x_{n})^{T};\\\\ \\quad\\\\ P_{1n}:c=\\frac{\\sqrt{x_{1}^{2}+x_{2}^{2}+\\dots+x_{n-1}^{2}}}{\\sqrt{x_{1}^{2}+x_{2}^{2}+\\dots+x_{n}^{2}}},\\quad s=\\frac{x_{n}}{\\sqrt{x_{1}^{2}+x_{2}^{2}+\\dots+x_{n}^{2}}}\\\\ \\quad\\\\ P_{12}x=(\\sqrt{x_{1}^{2}+x_{2}^{2}+\\dots+x_{n}^{2}},0,\\dots,0)^{T}=||x||\\vec e_{1};\\\\ 证毕 根据引理我们可进行基于吉文斯变换的QR分解： 设A是一个$m\\times n$的矩阵且它的列向量线性无关，则利用吉文斯变换可以把A逐步化为上梯形矩阵。 设\\\\ \\quad\\\\ A= \\begin{pmatrix} a_{11}&a_{12}&\\dots&a_{1n}\\\\ a_{21}&a_{22}&\\dots&a_{2n}\\\\ \\vdots&\\vdots&&\\vdots\\\\ a_{m1}&a_{m2}&\\dots&a_{mn} \\end{pmatrix}= (a_{1},a_{2},\\dots,a_{n})\\\\ \\quad\\\\ 并记\\\\ A^{(0)}=(a_{1}^{(0)},a_{2}^{(0)},\\dots,a_{n}^{(0)})=A\\\\ 变换过程如下：\\\\ 第一步：\\\\ 根据引理可以构造m-1个m阶吉文斯矩阵的乘积P_{1},使得\\\\ P_{1}a_{1}^{(0)}=||a_{1}^{(0)}||_{2}\\vec e_{1}\\\\ \\quad\\\\ 记a_{11}=||a_{1}^{(0)}||_{2},用P_{1}左乘A^{0}得\\Rightarrow\\\\ \\quad\\\\ A^{(1)}=P_{1}A^{(0)}= \\begin{pmatrix} a_{11}^{(1)}&a_{12}^{(1)}&\\dots&a_{1n}^{(1)}\\\\ 0&a_{22}^{(1)}&\\dots&a_{2n}^{(1)}\\\\ \\vdots&\\vdots&&\\vdots\\\\ 0&a_{m2}^{(1)}&\\dots&a_{mn}^{(1)} \\end{pmatrix}\\\\ 第二步：\\\\ 记a_{2}^{(1)}=(a_{12}^{(1)},a_{22}^{(1)},\\dots,a_{m2}^{(1)})^{T}=(a_{12}^{(1)},\\widetilde a_{2}^{(1)})\\\\ 同理可以构造m-2个m-1阶吉文斯矩阵的乘积\\widetilde P_{2}，使得\\\\ \\widetilde P_{2}\\widetilde a_{2}^{(1)}=||\\widetilde a_{2}^{(1)}||_{2}\\vec e_{1}\\\\ 令\\\\ P_{2}= \\begin{pmatrix} 1&0\\\\ 0&\\widetilde P_{2}\\\\ \\end{pmatrix},\\\\ 用P_{2}左乘A^{(1)}得\\\\ A^{(2)}=P_{2}A^{(1)}= \\begin{pmatrix} a_{11}^{(1)}&a_{12}^{(1)}&a_{13}^{(1)}&\\dots&a_{1n}^{(1)}\\\\ 0&a_{22}^{(2)}&a_{23}^{(2)}&\\dots&a_{2n}^{(2)}\\\\ 0&0&a_{33}^{(2)}&\\dots&a_{3n}^{(2)}\\\\ \\vdots&\\vdots&\\vdots&&\\vdots\\\\ 0&0&a_{m3}^{(2)}&\\dots&a_{mn}^{(2)} \\end{pmatrix}\\\\ 重复以上过程，构造P_{1},P_{2},\\dots,P_{k},则 A^{(k-1)}=P_{k-1}P_{k-2}\\dots P_{1}A^{(0)}\\\\ = \\begin{pmatrix} a_{11}^{(1)}&a_{12}^{(1)}&\\dots&a_{1,k-1}^{(1)}&a_{1k}^{(1)}&a_{1,k+1}^{(1)}&\\dots&a_{1n}^{(1)}\\\\ 0&a_{22}^{(2)}&\\dots&a_{2,k-1}^{(2)}&a_{2k}^{(2)}&a_{2,k+1}^{(2)}&\\dots&a_{2n}^{(2)}\\\\ &&\\ddots&\\vdots&\\vdots&\\vdots&&\\vdots\\\\ 0&0&0&a_{k-1,k-1}^{(k-1)}&a_{k-1,k}^{(k-1)}&a_{k-1,k+1}^{(k-1)}&\\dots&a_{k-1,n}^{(k-1)}\\\\ 0&0&0&0&a_{kk}^{(k-1)}&a_{k,k+1}^{(k-1)}&\\dots&a_{kn}^{(k-1)}\\\\ \\vdots&\\vdots&\\vdots&&\\vdots\\\\ 0&0&0&0&a_{mk}^{(k-1)}&a_{m,k+1}^{(k-1)}&\\dots&a_{mn}^{(k-1)} \\end{pmatrix}\\\\ 第k步：\\\\ 记a_{k}^{(k-1)}=(a_{1k}^{(1)},a_{2k}^{(2)},\\dots,a_{k-1,k}^{(k-1)},a_{kk}^{(k-1)},\\dots,a_{mk}^{(k-1)})^{T}=(a_{1k}^{(1)},a_{2k}^{(2)},\\dots,a_{k-1,k}^{(k-1)},\\widetilde a_{k}^{(k-1)})^{T}\\\\ 构造\\\\ \\widetilde p_{k}\\widetilde a_{k}^{(k-1)}=||\\widetilde a_{k}^{(k-1)}||_{2}\\vec e_{1}\\\\ 令\\\\ P_{k}= \\begin{pmatrix} I_{k-1}&0\\\\ 0&\\widetilde P_{k} \\end{pmatrix}\\\\ 用P-{k}左乘A^{(k-1)}得\\\\ A^{(k)}=P_{k}P_{k-1}\\dots P_{1}A^{(0)}\\\\ = \\begin{pmatrix} a_{11}^{(1)}&a_{12}^{(1)}&\\dots&a_{1,k-1}^{(1)}&a_{1k}^{(1)}&a_{1,k+1}^{(1)}&a_{1,k+2}^{(1)}&\\dots&a_{1n}^{(1)}\\\\ &a_{22}^{(2)}&\\dots&a_{2,k-1}^{(2)}&a_{2k}^{(2)}&a_{2,k+1}^{(2)}&a_{2,k+2}^{(2)}&\\dots&a_{2n}^{(2)}\\\\ &&\\ddots&\\vdots&\\vdots&\\vdots&\\vdots&&\\vdots\\\\ &&&a_{k-1,k-1}^{(k-1)}&a_{k-1,k}^{(k-1)}&a_{k-1,k+1}^{(k-1)}&a_{k-1,k+2}^{(k-1)}&\\dots&a_{k-1,n}^{(k-1)}&\\\\ &&&&a_{kk}^{(k)}&a_{k,k+1}^{(k)}&a_{k,k+2}^{(k)}&\\dots&a_{kn}^{(k)}\\\\ &&&&&a_{k+1,k+1}^{(k)}&a_{k+1,k+2}^{(k)}&\\dots&a_{k+1,n}^{(k)}\\\\ &&&&&\\vdots&\\vdots&&\\vdots\\\\ &&&&&a_{m,k+1}^{(k)}&a_{m,k+2}^{(k)}&\\dots&a_{m,n}^{(k)}\\\\ \\end{pmatrix}\\\\继续上述变换过程，直至$s=min\\{m-1,n\\}$步，最后得到 A^{s}=P_{s}P_{s-1}\\dots P_{1}A=R由于上述的过程中每个$P_{i}$都是正交矩阵，所以$P=P_{s}P_{s-1}\\dots P_{1}$也是正交矩阵，所以式（7）可以写为 PA=R 当m=n时，R是N阶上三角矩阵，这时式（8）可以写为 A=QR​ 其中$Q=P^{T}$为n阶正交矩阵，R为可逆的上三角矩阵 当m&gt;n时，R是$m\\times n$阶的上梯形矩阵，此时 PA=R= \\begin{pmatrix} R_{1}\\\\ 0 \\end{pmatrix} 其中$R_{1}$为可逆的上三角矩阵 至此，我们实现了矩阵A基于吉文斯变换的QR分解。 吉文斯变换法QR分解的程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166namespace QR_decomposition{ class Program { static void Main(string[] args) { //用于验证的demo，自行修改 Matrix m = new Matrix(3, 3); Matrix[] result_QR = m.QR_Decomposition(); result_QR[0].DisPlay(); Console.WriteLine(); result_QR[1].DisPlay(); Matrix n = result_QR[0] * result_QR[1]; Console.WriteLine(); n.DisPlay(); } //对象封装 class Matrix { //数据和矩阵形状的信息 public int row = 0; public int column = 0; private float[,] matrix; //不同的构造方法，输入初始化和自动初始化 public Matrix(int row, int column, int option) { this.row = row; this.column = column; matrix = new float[row, column]; if (option == 1 &amp;&amp; row == column) { for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; row; j++) { if (i == j) { matrix[i, i] = 1; } else { matrix[i, j] = 0; } } } } } public Matrix(int row, int column) { this.row = row; this.column = column; Console.WriteLine($\"Please enter a matrix with {this.row}rows,{this.column}colums\"); matrix = new float[row, column]; try { for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; column; j++) { string mid = Console.ReadLine(); var rows = mid.Split(' '); foreach (var item in rows) { matrix[i, j++] = float.Parse(item); } } } Console.WriteLine(\"\\r\\n\"); } catch (Exception e) { Console.WriteLine($\"something wrong!\\n{e.Message}\"); } } //打印矩阵 public void DisPlay() { for (int i = 0; i &lt; this.row; i++) { for (int j = 0; j &lt; this.column; j++) { Console.Write(string.Format(\"{0:F3}\", matrix[i, j]) + \" \"); } Console.WriteLine(\"\\r\"); } } //构造吉文斯矩阵的函数 public Matrix RotateMatrix(int order, float para1, float para2, int index1, int index2) { Matrix Rotate_matrix = new Matrix(order, order, 1); float cos = (float)(para1 / (Math.Sqrt(Math.Pow(para1, 2) + Math.Pow(para2, 2)))); float sin = (float)(para2 / (Math.Sqrt(Math.Pow(para1, 2) + Math.Pow(para2, 2)))); Rotate_matrix.matrix[index1, index1] = cos; Rotate_matrix.matrix[index2, index2] = cos; Rotate_matrix.matrix[index1, index2] = sin; Rotate_matrix.matrix[index2, index1] = -sin; return Rotate_matrix; } //矩阵转置 public void Transpose() { float[,] temp=new float[row,column]; for (int i = 0; i &lt;this. row; i++) { for (int j = 0; j &lt;this. column; j++) { temp[i, j] = matrix[j, i]; } } matrix = temp; } //矩阵乘法的复写 public static Matrix operator *(Matrix p1, Matrix p2) { Matrix result = new Matrix(p1.row, p2.column, 0); for (int i = 0; i &lt; p1.row; i++) { for (int j = 0; j &lt; p2.column; j++) { float temp = 0; for (int k = 0; k &lt; p1.column; k++) { temp += p1.matrix[i, k] * p2.matrix[k, j]; } result.matrix[i, j] = temp; } } return result; } //QR分解的主要过程 public Matrix[] QR_Decomposition() { //申明两个矩阵用于存放结果Q矩阵和R矩阵 Matrix result_Q = new Matrix(this.column, this.column, 1); Matrix result_R = new Matrix(this.row, this.column, 0); result_R.matrix = this.matrix; //按照算法先列后行进行扫描 for (int i = 0; i &lt; column; i++) { for (int j = i + 1; j &lt; row; j++) { //遇到元素是零的情况，跳过此次循环 if (result_R.matrix[j, i] == 0) continue; Matrix rotate_matrix = RotateMatrix(column, result_R.matrix[i, i], result_R.matrix[j, i], i, j); result_Q = rotate_matrix * result_Q; result_R = rotate_matrix * result_R; } } result_Q.Transpose(); Matrix[] result = { result_Q, result_R }; return result; } } }} 程序的验证对于上面的程序，我们用两个例子来进行验证： 输入矩阵 A= \\begin{pmatrix} 3&5&5\\\\ 0&3&4\\\\ 4&0&5 \\end{pmatrix}我们将得到输出如下 经过验证程序输出的QR分解是正确的，并且通过计算QR矩阵的乘积，我们得到了原来输入的矩阵，这足以证明程序的正确性 再次输入矩阵 B= \\begin{pmatrix} 3 &14 &9\\\\ 6 &43 &3\\\\ 6 &22 &15\\\\ \\end{pmatrix}输出结果如下 经过检验，结果依然是正确的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/08/08/qr-decomposition_1/","tags":[{"name":"Matrix","slug":"matrix","permalink":"http://zhumingcj.github.io/tags/matrix/"}]},{"title":"Simple Classification","date":"2019-07-23T12:42:11.000Z","text":"二分类与多分类问题分类是一种朴素而又深刻的思想，要是人工智能成为现实，解决分类问题是必须的。分类可以更好的挖掘数据中的信息，也便于对数据的捆绑加工。分类可以降低世界的复杂度，将世界中复杂的关系简化为类与类之间的联系，从而有可能通过机器来认知刻画这个世界。 线性判别分析线性判别分析（Linear Discriminant Analysis）是一种经典的线性学习方法，用于解决二分类问题。LDA的基本思想是将样例投影到一条直线上，并使同类样例的投影点尽可能接近，使异类样例的投影点尽可能远离。在对新的样本进行分类时根据其投影点在直线上的位置进行分类。如下图为一个二维示例： LDA模型详析当给定数据集$D=\\{(x_{i},y_{i})\\}_{i=1}^{m},\\ y_{i}\\in\\{0,1\\}$，令$X_{i}、\\mu_{_{i}}、\\sum_{i}$分别表示第i$\\in\\{0,1\\}$类样例的集合、均值向量、协方差矩阵。若将数据点投影到直线上，两类样例的中心分别在$w^{T}\\mu_{0}和w^{T}\\mu_{1}$，两类样本的协方差分别为$w^{T}\\sum_{0}w和w^{T}\\sum_{1}w$，由于直线是一维的，因此$w^{T}\\mu_{0}、w^{T}\\mu_{1}、w^{T}\\sum_{0}w\\ 和 \\ w^{T}\\sum_{1}w$ 均为实数。 想要使同类样例尽可能接近，可以让同类样例投影点的协方差尽可能小，即$w^{T}\\sum_{0}w-w^{T}\\sum_{1}w$尽可能小；想要使异类投影点之间的距离尽可能大，则要让$||w^{T}\\mu_{0}+w^{T}\\mu_{1}||_{2}^{2}$尽可能大，同时考虑上述两个因素，我们可以得到我们要最大化的目标： J=\\frac{||w^{T}\\mu_{0}-w^{T}\\mu_{1}||_{2}^{2}}{w^{T}\\sum_{0}w+w^{T}\\sum_{1}w}\\\\ =\\frac{w^{T}(\\mu_{0}-\\mu_{1})(\\mu_{0}-\\mu_{1})^{T}w}{w^{T}(\\sum_{0}+\\sum_{1})w}定义”类内散度矩阵”（within-class scatter matrix） S_{w}=\\sum_{0}+\\sum_{1}\\\\ =\\sum_{x\\in X_{0}}(x-\\mu_{0})(x-\\mu_{0})^{T}+\\sum_{x\\in X_{1}}(x-\\mu_{1})(x-\\mu_{1})^{T}同样的，定义类间散度矩阵（between-class scatter matrix） S_{b}=(\\mu_{0}-\\mu_{1})(\\mu_{0}-\\mu_{1})^{T}则式（1）可以重写为 J=\\frac{w^{T}S_{b}w}{w^{T}S_{w}w}这就是LDA的最大化目标，即$S_{b}与S_{w}$的广义瑞利商（generalized Rayleigh quotient)。 式（4）等价于 \\underset{w}min\\ -w^{T}S_{b}w\\\\ s.t.\\ w^{T}S_{w}w=1由拉格朗日乘子法可得 -w^{T}S_{b}w+\\lambda w^{T}S_{w}w=0 \\quad 求导\\Rightarrow\\\\ S_{b}w=\\lambda S_{w}w 通过观察我们可以发现$S_{b}w$的方向恒为$\\mu_{0}-\\mu_{1}$，因为 S_{b}w=(\\mu_{0}-\\mu_{1})\\underset{这是一个数}{\\underline{(\\mu_{0}-\\mu_{1})^{T}w}}\\\\ 不妨令\\\\ S_{b}w=\\lambda (\\mu_{0}-\\mu_{1})\\\\ 则由（6）可得\\\\ w=\\frac{1}{\\lambda}S_{w}^{-1}S_{b}w=S_{w}^{-1}(\\mu_{0}-\\mu_{1}) 考虑到数值解的稳定性，在实践中通常对$S_{w}$进行奇异值分解，即$S_{w}=U\\sum V^{T}$，其中$\\sum$是一个实对角矩阵它的对角线上的元素是$S_{w}$的奇异值，由此可以得到 S_{w}^{-1}=V{\\sum}^{-1}U^{T}LDA的多分类形式现在假设存在N个类，且第i类样例数为$m_{i}$。现在我们来定义全局散度矩阵 S_{t}=S_{b}+S_{w}\\\\ =\\sum_{i=1}^{m}(x_{i}-\\mu)(x_{i}-\\mu)^{T}其中$\\mu$是所有样例的均值向量。我们将类内散度矩阵$S_{w}$重新定义为每个类别的散度矩阵之和，即 S_{w}=\\sum_{i=1}^{N}S_{w_{i}}\\\\ 其中\\\\ S_{w_{i}}=\\sum_{x\\in X_{i}}(x-\\mu_{i})(x-\\mu_{i})^{T}由式（9）和（10）可得 S_{b}=S_{t}-S_{w}\\\\ =\\sum_{i=1}^{N}m_{i}(\\mu_{i}-\\mu)(\\mu_{i}-\\mu)^{T}多分类LDA采用优化目标如下： \\frac{tr(W^{T}S_{b}W)}{tr(W^{T}S_{W}W)}其中$W\\in R^{d*(N-1)}$，tr(.)表示矩阵的迹，式（12）可以通过如下广义特征值方程求解，得 S_bW=\\lambda S_{W}W若将W视为一个投影矩阵，则多分类LDA将样本投影到N-1维空间，N-1通常远小于数据原有的属性数。因此通过这个投影可以减少样本点的维数，可以起到降维的作用。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/07/23/simple-classification/","tags":[{"name":"Machine Learning","slug":"machine-learning","permalink":"http://zhumingcj.github.io/tags/machine-learning/"}]},{"title":"Changed Linear Regression","date":"2019-07-20T15:02:05.000Z","text":"线性回归的变形顾名思义，线性回归只能处理线性关系的情况，这样难免有很大的局限性，所以我们通常对线性回归模型进行改造来获得拟合曲线的能力。 对数线性回归当点集所表现出了的趋势大致为对数函数时，显然线性回归会有很大的偏差，此时在原有的基础上对y取对数即可转化为x到ln y的线性回归。我们得到下面的模型： ln y=w^{T}\\overrightarrow x+b在式中对数函数起到了将线性关系映射到曲线关系的作用，因此对于不同的映射函数，我们可以得到许多的非线性模型，即 y=g^{-1}(w^{T}\\overrightarrow x+b)这些非线性模型的核心还是线性回归，因此这些非线性回归都是广义上的线性回归，是它的一种变形。 对数几率回归如果我们想用线性回归来解决二分类问题，我们可以使用单位阶跃函数把y映射到（0,1），单位阶跃函数形式如下 y'= \\left\\{ \\begin{array}\\ 0,\\quad y0 \\end{array} \\right.当单位阶跃函数作用于y后，若y大于零则为正例，小于零则为反例，y为临界值则可任意判别。但是由单位阶跃函数的表达式我们可以知道它是不连续的。实际中，不连续的函数存在应用困难，我们希望能找到可以近似代替单位阶跃函数的连续函数，对数几率函数就是我们要找的函数： y'=\\frac{1}{1+e^{-y}}=\\frac{1}{1+e^{-(w^{T}x+b)}}\\Rightarrow\\\\ ln{\\frac{y}{1-y}}=w^{T}x+b 如果y表示x是正例的可能性，那么1-y就是其为反例的可能性，两者都比值$\\frac{y}{1-y}$称为几率，反应x为正例的相对可能性，对几率取对数则得到对数几率$ln{\\frac{y}{1-y}}$。 由此可以看出式（4）是在用线性回归的模型来预测对数几率 对数几率回归参数的求解要确定对数几率回归模型，就必须求解参数w和b，若将式（4）中的y’视为类后验概率估计p(y’=1|x)，则式（4）可重写为 ln \\frac{p(y'=1|x)}{p(y'=0|x)}= w^{T}x+b显然有 p(y'=1|x)=\\frac{e^{w^{T}x+b}}{1+e^{w^{T}x+b}}\\\\ p(y'=0|x)=\\frac{1}{1+e^{w^{T}x+b}}于是，我们可通过”极大似然法”来估计w和b。对给定的数集${(x_{i},y_{i})}_{i=1}^{m}$，对数概率回归模型最大”对数似然”为 l(w,b)=\\sum_{i=1}^{m}lnp(y_{i}|x_{i};w,b)即令每个样本属于其真实标记的概率越大越好。为方便讨论 令\\beta=(w;b),\\hat x=(x;1),则w^{T}x+b可简写为\\beta^{T}\\hat x\\\\ 再令p_{1}(\\hat x;\\beta)=p(y=1|\\hat x;\\beta)，p_{0}(\\hat x;\\beta)=p(y=0|\\hat x;\\beta)=1-p_{1}(\\hat x;\\beta)则式（7）可重写为 p(y_{i}|x_{i};w,b)=y_{i}p_{1}(\\hat x;\\beta)+(1-y_{i})p_{0}(\\hat x;\\beta)把式（9）代入（6）可得最大化式（7）等于最小化下式 l(\\beta)=\\sum_{i=1}^{m}(-y_{i}\\beta^{T}\\hat x+ln(1+e^{\\beta^{T}\\hat x}))式（10）是关于$\\beta$的告诫可导连续函数，根据凸优化理论，经典的数值优化算法如梯度下降法、牛顿法等都可以求得其最优解如下 \\beta^{*}=argmin\\quad{l(\\beta)} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/07/20/changed-linear-regression/","tags":[{"name":"Machine Learning","slug":"machine-learning","permalink":"http://zhumingcj.github.io/tags/machine-learning/"}]},{"title":"Linear Regression","date":"2019-07-19T08:05:12.000Z","text":"线性回归线性回归是机器学习中最基本但也十分重要的一个概念，线性回归可以解决简单的最优解和二分类问题，并且有些复杂的学习模型是在线性回归的基础上延伸出来的。 什么是线性回归在实验中，我们希望找到某个量与其他量之间的关系，在很多情况下这种函数关系是线性的。一般的，把实验所得到的数据点绘制在坐标图中，如果这些点大致在一条直线上，那么我们可以假设我们所要求的函数关系是线性的。 假设我们要找n个自变量(x1,x2,…，xn)和因变量y之间的线性关系，即$y=a_{1}x_{1}+a_{2}x_{2}+\\dots+a_{n}x_{n}+b$，在这个函数中有n+1个未知量，因此我们需要n+1组数据来求解这n+1个未知量。但是实际中我们得到的数据是不精确的并且往往多于n+1组数据，由线性代数我们可以知道超定方程是无解的。这种情况下如果我们选取其中的n+1组数据来求解未知数将产生很大的误差，而且我们希望充分的利用得到的数据。当我们把这些数据点绘制在坐标纸上，我们会发现我们面临的问题是找到一条直线尽可能地表现这些点所显示的趋势。确定这样一条直线的过程就叫做线性回归。 线性回归的公式为了精确的描述，我们用均方差来刻画直线的接近程度，均方差越小，所对应的直线越接近这些点所想表达的趋势。当函数是一元函数f(x)=wx+b时，均方误差（MSE）的计算式如下： MSE=E_{(w,b)}=\\sum_{i=1}^{m}(f(x_{i})-y_{i})^{2}当均方误差最小的时候所确定的函数关系就是我们要求的最接近数据点所展现的趋势，在这种情况下有下列关系式成立 \\frac{\\partial E_{(w,b)}}{\\partial w}=2(w\\sum_{i=1}^{m}x_{i}^{2}-\\sum_{i=1}^{m}(y_{i}-b)x_{i})=0\\\\ \\quad\\\\ \\frac{\\partial E_{(w,b)}}{\\partial b}=2(mb-\\sum_{i=1}^{m}(y_{i}-wx_{i}))=0\\\\ 整理后我们可以得到方程组：\\\\ \\left\\{ \\begin{array}\\ w\\sum_{i=1}^{m}x_{i}^{2}-\\sum_{i=1}^{m}x_{i}{y_{i}}+b\\sum_{i=1}^{m}x_{i}=0\\\\ mb-\\sum_{i=1}^{m}y_{i}+w\\sum_{i=1}^{m}x_{i}=0\\\\ 解得\\\\ w=\\frac{\\sum_{i=1}^{m}y_{i}(x_{i}-\\overline x)}{\\sum_{i=1}^{m}x_{i}^{2}-\\frac{1}{m}(\\sum_{i=1}^{m}x_{i})^{2}}\\\\ b=\\frac{1}{m}\\sum_{i=1}^{m}(y_{i}-wx_{i}) \\end{array} \\right.更一般的，当函数为多元线性函数$f(x)=w_{1}x_{1}+w_{2}x_{2}+\\dots+w_{m}x_{m}+b$时，函数关系为 f(x)=w^{T}x+b为方便讨论，我们把数据集D记为 D= \\begin{pmatrix} x_{11}&x_{12}&\\dots&x_{1n}&1\\\\ x_{21}&x_{22}&\\dots&x_{2n}&1\\\\ \\vdots&\\vdots&\\ddots&\\vdots&\\vdots\\\\ x_{n1}&x_{n2}&\\dots&x_{mn}&1 \\end{pmatrix}= \\begin{pmatrix} x_{1}^{T}&1\\\\ x_{2}^{T}&1\\\\ \\vdots&\\vdots\\\\ x_{m}^{T}&1\\\\ \\end{pmatrix}把$\\hat w$向量记为 \\hat w= \\begin{pmatrix} w\\\\ b \\end{pmatrix}把y记为$(y_{1},y_{2},\\dots,y_{m})^{T}$，则类似于一元函数有 MSE=E_{(\\hat w)}=(y-D\\hat w)^{T}(y-D\\hat w)\\\\ 对其求导可得\\\\ \\frac{\\partial E_{\\hat w}}{\\partial\\hat w}=2D^{T}(D\\hat w-y)=0下面进行分类讨论： 当$D^{T}D$为满秩矩阵或正定矩阵时，可得 \\hat w=(D^{T}D)^{-1}D^{T}y 当$D^{T}D$为非满秩矩阵时（实际中经常参数的数量多于数据量，此时$D^{T}D$一定是非满秩），我们会解得多个$\\hat w$，它们都能使均方误差最小化，这时选择哪个解作为输出取决于算法的偏好。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/07/19/linear-regression/","tags":[{"name":"Machine Learning","slug":"machine-learning","permalink":"http://zhumingcj.github.io/tags/machine-learning/"}]},{"title":"Important Concepts for Html","date":"2019-07-18T12:08:06.000Z","text":"盒子模型与定位技术盒子模型是HTML语言中一个重要的概念，如果说编程语言中一切皆对象，那么HTML中则是一切皆盒子。定位技术在HTML中也是非常重要的，虽然通过盒子模型可以解决所有的定位问题，但是这样的方法只适合于简单的网页。当网页结构异常复杂时，使用这种定位方法需要计算大量的参数，是不可行的。因此我们需要使用框架封装好的定位技术。 盒子模型所谓的盒子模型即HTML中的每个元素都有position、margin、border、padding这四个属性，在谷歌浏览器中我们可以看到盒子模型的直观图，如下 position——元素的位置 margin——元素的外边距 border——元素的边框（轮廓） padding——元素的内边距 content——元素实际包含的信息（盒子最里面） 要点 margin部分不算入盒子的大小，只是用来与其他元素隔开一定距离；在默认情况下HTML的body自带有margin为8px。 padding用来使内容和border隔出一定距离，可用来调整文本的格式 盒子模型的简单应用 margin和padding可以用来定位 被包裹的盒子相对于包裹它的盒子的坐标定位即为margin-top和margin-left的值。如想要把一个body标签中的div标签定位到（100px,100px）的位置，只需要把div的这两个属性都设为100px即可；同理可知padding也可以实现定位 padding可用于限定盒子中文本的行数 如果不就行恰当的设置，很有可能出现文本展示不全的情况出现，会极大地影响用户体验。当我们想限定容器中显示N行文本时，我们只需要让盒子高度扣除padding后是字体行高的N倍即可；特别的，当N等于1时所展现的效果就是垂直居中 定位技术需求在网页制作排版中，需要准确的定位元素，使用盒子模型进行定位一方面十分繁琐复杂另一方面无法层次化，即元素之间无法交叉（实际中我们有这种需要）。 实现方式在css中通过设置position的值来选择定位方式，通过top、left等设置坐标。其中position有三个参数可选——absolute、relative、fixed。设置position后元素变为层级元素，即每个元素处于不同层级，可以层叠。 三种定位方式详解 absolute模式 绝对定位（脱离原来位置进行定位），对于两个块级元素来说在没有设置absolute定位时，前一个元素会把后一个元素挤开，当设置absolute定位后，后一个元素会脱离原来位置定位到默认（0，0）的位置与前一个元素发生层叠。 absolute定位会选取最近的可定位元素作为定位的参照。在复杂的父子结构中，例如下图 我们想对content进行定位，如果两个父级元素都没有设置定位，则会根据父级body进行定位；如果box设置了定位，content就会以box为参照进行定位。 relative模式 相对定位（保留原来位置（出生的位置）进行定位），同样两个块级元素，如果后一个元素设置了相对定位，则元素会变成层级元素但是保留原来的位置。 由于relative保留原来位置的特性，它常被用来当做定位的参照——我们把定位元素设置成absolute，把参照物设成relative，这样既不会影响其他的元素，又可以进行定位。若将参照物设成absolute则其后面的元素可能会脱离原来的位置，这是我们不希望看到的。 fixed模式 固定定位（不管页面怎么变化，始终固定在一个位置）。这种定位方式也是十分常见的，基本上所有的广告、目录等都是fixed定位的。 盒子模型中的bug margin塌陷 现象：在父子结构中，子元素设置margin-top时出现异常——当设置的margin-top小于父元素的margin-top 时无法发挥作用，大于父元素时子元素会带动父元素，即父子元素的margin-top联动。此bug相当于父元素上方的border没有了，故此得名。 解决方法： 暴力法 手动在父元素上加一个border-top即可，但是此方法会破坏原有HTML的结构，因此不可取。 通过bfc（block format context）来解决。一般每个元素（盒子）都有一样的渲染规则，但是通过触发bfc可以改变盒子的渲染规则从而解决margin塌陷的问题。 触发bfc的三种方法： position：absolute/relative/fixed； display：inline-block； float：left/right; overflow：hidden; 通过bfc的方法解决margin塌陷问题也只能起到缓解作用，因为四种触发bfc的方法都会引起新的问题，比如设置position可能会对定位产生影响，所以我们可以选择一种不影响原有结构的方法来解决margin塌陷问题。 margin合并 现象：在并列结构中，A元素和B元素分别设置margin-bottom和margin-top时不会正常的叠加而会取二者的最大值最为两者的间距，就像是两者何用了一个margin。 解决方法：margin合并也可以通过触发bfc来解决。但是在实际中我们也可以选择不解决margin合并问题，因为我们只要对其中一个元素设置和间距等同的margin即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/07/18/important-concepts-for-html/","tags":[{"name":"HTML","slug":"html","permalink":"http://zhumingcj.github.io/tags/html/"}]},{"title":"Rotation、Grad and Divergence","date":"2019-07-09T08:54:32.000Z","text":"梯度、散度、旋度梯度、散度、旋度是研究向量场的几个重要的量，它们表征着向量场的性质，在理论研究中有着重要的地位。梯度表示标量函数增加或减少的方向；散度表示向量场远离源的程度；旋度则表示向量场围绕某个中心旋转的程度。 梯度、散度、旋度的计算公式 \\nabla A=(\\frac{\\partial A}{\\partial x},\\frac{\\partial A}{\\partial y},\\frac{\\partial A}{\\partial z})\\\\ \\nabla\\bullet A=(\\frac{\\partial A_{x}}{\\partial x}+\\frac{\\partial A_{y}}{\\partial y}+\\frac{\\partial A_{z}}{\\partial z})\\\\ \\nabla \\times A=(\\frac{\\partial A_{y}}{\\partial z}-\\frac{\\partial A_{z}}{\\partial y},\\frac{\\partial A_{z}}{\\partial x}-\\frac{\\partial A_{x}}{\\partial z},\\frac{\\partial A_{x}}{\\partial y}-\\frac{\\partial A_{y}}{\\partial x})梯度、散度、旋度的嵌套运算 证明旋度的散度=0（$\\nabla\\bullet (\\nabla\\times A)=0$） \\begin{align} \\nabla\\bullet (\\nabla\\times A)=\\nabla\\bullet(\\frac{\\partial A_{y}}{\\partial z}-\\frac{\\partial A_{z}}{\\partial y},\\frac{\\partial A_{z}}{\\partial x}-\\frac{\\partial A_{x}}{\\partial z},\\frac{\\partial A_{x}}{\\partial y}-\\frac{\\partial A_{y}}{\\partial x})\\\\ =\\frac{\\partial^{2} A_{y}}{\\partial z \\partial x}-\\frac{\\partial^{2} A_{z}}{\\partial y \\partial x}+\\frac{\\partial^{2} A_{z}}{\\partial x \\partial y}-\\frac{\\partial^{2} A_{x}}{\\partial z \\partial y}+\\frac{\\partial^{2} A_{}x}{\\partial y \\partial z}-\\frac{\\partial^{2} A_{y}}{\\partial x \\partial z}\\\\ =0 \\end{align} 旋度的梯度（$\\nabla (\\nabla\\times A)$） \\nabla (\\nabla\\times A)=\\nabla(\\frac{\\partial A_{y}}{\\partial z}-\\frac{\\partial A_{z}}{\\partial y},\\frac{\\partial A_{z}}{\\partial x}-\\frac{\\partial A_{x}}{\\partial z},\\frac{\\partial A_{x}}{\\partial y}-\\frac{\\partial A_{y}}{\\partial x}) \\\\=(\\frac{\\partial^{2} A_{y}}{\\partial z \\partial x}-\\frac{\\partial^{2} A_{z}}{\\partial y \\partial x},\\frac{\\partial^{2} A_{z}}{\\partial x \\partial y}-\\frac{\\partial^{2} A_{x}}{\\partial z \\partial y},\\frac{\\partial^{2} A_{}x}{\\partial y \\partial z}-\\frac{\\partial^{2} A_{y}}{\\partial x \\partial z})\\\\ 旋度的旋度（$\\nabla\\times (\\nabla\\times A)$） \\nabla\\times (\\nabla\\times A)=\\nabla\\times(\\frac{\\partial A_{y}}{\\partial z}-\\frac{\\partial A_{z}}{\\partial y},\\frac{\\partial A_{z}}{\\partial x}-\\frac{\\partial A_{x}}{\\partial z},\\frac{\\partial A_{x}}{\\partial y}-\\frac{\\partial A_{y}}{\\partial x})\\\\ =(\\frac{\\partial^{2} A_{z}}{\\partial x \\partial z}-\\frac{\\partial^{2} A_{x}}{\\partial z^{2}}-\\frac{\\partial^{2} A_{x}}{\\partial y^{2}}+\\frac{\\partial^{2} A_{y}}{\\partial x \\partial y},\\frac{\\partial^{2} A_{x}}{\\partial y \\partial z}-\\frac{\\partial^{2} A_{y}}{\\partial x^{2}}-\\frac{\\partial^{2} A_{y}}{\\partial z^{2}}+\\frac{\\partial^{2} A_{z}}{\\partial z \\partial x},\\frac{\\partial^{2} A_{y}}{\\partial z \\partial y}-\\frac{\\partial^{2} A_{z}}{\\partial y^{2}}-\\frac{\\partial^{2} A_{z}}{\\partial x^{2}}+\\frac{\\partial^{2} A_{x}}{\\partial z \\partial x}) 梯度的旋度=$\\overrightarrow{0}$（$\\nabla\\times(\\nabla A)=0$） \\nabla\\times(\\nabla A)=\\nabla\\times(\\frac{\\partial A}{\\partial x},\\frac{\\partial A}{\\partial y},\\frac{\\partial A}{\\partial z})\\\\ =(\\frac{\\partial^{2}A}{\\partial y \\partial x}-\\frac{\\partial^{2}A}{\\partial x \\partial y},\\frac{\\partial^{2}A}{\\partial x \\partial z}-\\frac{\\partial^{2}A}{\\partial z \\partial x},\\frac{\\partial^{2}A}{\\partial x \\partial y}-\\frac{\\partial^{2}A}{\\partial y \\partial x})\\\\ =(0,0,0)梯度的梯度（略） 梯度的梯度（略） 梯度的散度（$\\nabla\\times(\\nabla A)$） \\nabla\\times(\\nabla A)=\\frac{\\partial^{2}A}{\\partial x^{2}}+\\frac{\\partial^{2}A}{\\partial y^{2}}+\\frac{\\partial^{2}A}{\\partial z^{2}} 散度的梯度（$\\nabla(\\nabla\\bullet A)$） \\nabla(\\nabla\\bullet A)=\\nabla(\\frac{\\partial A_{x}}{\\partial x}+\\frac{\\partial A_{y}}{\\partial y}+\\frac{\\partial A_{z}}{\\partial z}) 有关场： 若一个向量场的散度=0，则这个场是无源场；若一个向量场的旋度=0，则这个向量场是无旋场又称保守场。 一个旋度场的散度=0，可知旋度场是一个无源场；一个梯度场的旋度=0，可知梯度场是一个无旋场(保守场)。综上可知，仅通过散度无法确定一个向量场，因为一个旋度场叠加上一个有源场不改变这个场的散度；同样仅通过旋度也无法确定一个向量场，因为一个有旋场叠加上一个梯度场不改变其旋度。 散度具有指向的意义，对于匀强的向量场，散度等于零意味着向量场的方向是一致的。 散度的梯度用于表示源的分布情况。在实际中物质的扩散可以用散度的梯度来刻画，表示物质扩散最快的方向。（即通量密度最大的地方）。 旋度的分量具有实际意义，对于旋度的x分量表示yoz平面的旋转程度，其它分量也是如此。 ​ 如图1为向量场$A=-x^{2}\\overrightarrow{j}$,若把一块小薄板放在图的右侧，则薄板会顺时针偏转；若放在左边则逆时针偏 转。根据右手定则，右边的旋度为z轴负向；左边的旋度为z轴正向。可以想象旋转程度与x变化一个微小的 量时A的变化程度的极限有关。因为A无x的分量所以，所以旋转程度取决于y分量的变化率，即 $(\\nabla\\times A)_{z}=\\frac{\\partial A_{y}}{\\partial x}$ ​ 如图2所示的向量场可分解$A_{x}$为和$A_{y}$两部分，每一部分分量型如图1。此时$(\\nabla\\times A)_{z}=\\frac{\\partial A_{y}}{\\partial x}-\\frac{\\partial A_{x}}{\\partial y}$，从推导 可知$\\nabla\\times A$的x、y、z分量分别表示yoz平面、xoz平面以及xoy平面的旋转程度。 亥姆霍兹定理 若矢量场在无限空间中处处单值，且其导数连续有界，而源分布在有限空间内，则矢量场由其旋度、散度和边界条件唯一确定；且可表示为一个标量场的梯度和一个矢量场的旋度之和。 \\overrightarrow{F}=-\\nabla\\varphi+\\nabla\\times\\overrightarrow{A}换言之，矢量场可以有一个有源场和一个有旋场以及边值条件唯一确定。其中标量场的梯度为无旋场（有源场），向量场的旋度为有旋场（无源场）。 有关旋度的旋度的恒等式 电磁场理论 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/07/09/rotation、grad-and-divergence/","tags":[{"name":"杂文","slug":"杂文","permalink":"http://zhumingcj.github.io/tags/杂文/"}]},{"title":"KMP Algorithm","date":"2019-07-09T06:23:32.000Z","text":"KMP 算法KMP算法是子串搜索算法中最有效、最有名的一个算法，它有效地减少了匹配子串时的比较次数，降低了时间复杂度，其中蕴含算法的思想更是值得学习的。 暴力子串搜索算法步入正题之前，让我们先来看看最简单的子串搜索算法，分析其问题的所在。 暴力子串搜索就是采用双循环，先比较主串和模式串的第一位，再比较第二位，以此类推，直至比较结果不匹配，则主串前移，继续重复上述过程，；若直至模式串末位都匹配，则找到目标。 程序组织如下 12345678910111213141516171819202122public static int Search(string main_str, string pattern_str) { int m = main_str.Length; int n = pattern_str.Length; int target = -1; for (int i = 0; i &lt; m-n; i++) { for (int j = 0; j &lt; n; j++) { if (main_str[i+j]!=pattern_str[j]) { break; } if (j == n - 1) { target = i; } } } return target; } 暴力子串搜索算法的分析可以看到，以这种方式进行搜索，在最坏的情况下要进行n(m-n)次运算，所以它的时间复杂度为O(n(m-n))，当数据量很大的时候，此种算法的效率很低。 KMP算法在前面我们看到暴力法搜索会耗费很多的时间，那么该如何改进呢？如果要减少运算次数，那么必须减少循环的次数，也就是不能一个一个的比较，我们希望第二次搜索可以在第一次的基础上，从最优的位置继续开始循环。也就是说，我们要充分利用前一次搜索失败的信息。下面我们来具体分析如何利用上一次搜索的信息： KMP算法的关键——next()函数初步分析 如图，在每次不匹配时，我们可以利用前面的信息来移动模式串（实际上我们可以知道匹配开始点到不匹配点之间主串的字符），图中第一次匹配在第五个位置匹配失败，则我们可以知道主串前四位是abda，那么我们可以知道模式串向右移动1、2位都是不匹配的，因此应该移动3位，即移动到第二个a的位置。由此我们可以猜测每次匹配失败时，模式串向右移动的最佳长度和模式串自身的结构和失败的位置有关，即是关于模式串序号的一个函数。我们把这个函数记为next（i），下面是一个示例。 通过上面的示例以及分析我们可以知道，如果记模式串匹配失败前的内容为P(i),则我们希望找一个k使得P(i)的前k项和后k项是一样的，并且这个k是满足上面的条件中最大的那个，也就是说我们想找到一个P(i)的前缀，它也是模式串的后缀，并且长度是最大的，这个长度就是k。 深入分析上面我们得到了next（i）的求解方法，下面我们来分析一下为什么是这样的。 假设这是一次匹配，它将在序号为9的地方匹配失败，那么下一次匹配的时候我们应该将模式串移动到什么位置呢？显然模式串的开头是a，那么模式串一定得移到主串中a的位置（3,4,6）。如果模式串移动到3的位置，那么如下图 我们可以看到这种情况是不匹配的，因为从上一次的匹配中我们可以知道主串4位置是a，与b不匹配，移动到位置4的情况相同。 我们把问题抽象出来就是这样的 第一次匹配后，我们所知道的主串是这样的 而模式串是这样的 现在需要移动模式串进行第二次匹配，由于这种情况不好看清本质问题，所以我们假设第一次匹配后情况如下 图中，匹配失败处i=11，并且P(i)实际上就是主串已知的内容。由上面的讨论，我们可以知道模式串移动到3,5的位置是不匹配的，在这里我们可以知道为什么next（i）要找P(i)最长的前缀（同时是后缀），因为如果模式串移动到一个以a（模式串的第一个字符，这里是a）开头但不是后缀的地方，如5的位置（参照下图），虽然前五个abcab是匹配的，但是第六个字符主串是c而模式串是a,换言之处于中间的以a开头的位置需要确保其后的每一个字符与模式串对应位置是匹配的,直到主串序号i之前，那么满足这样条件的一定是P(i)的一个后缀（因为上述条件保证了P(i)的一个后缀与模式串的一个前缀对应相等，而模式串的前缀一定也是P(i)的前缀，所以我们找的是P(i)中既是前缀又是后缀的字符串，理论上符合这样条件的都可以作为模式串移动的依据，但是为了尽可能的充分利用已知信息，我们应该找寻最长的那个前/后缀） 由此我们正式给出next(i)的定义 def：\\\\ next(i)=max(len(s))\\quad\\{s|s\\sqsubset P(i),s\\sqsupset P(i)\\}\\\\ 注：\\sqsubset表示...的前缀；\\sqsupset表示...的后缀next函数计算的递推法为了实现递推，我们把next(0)记为0，并记next(i)=$k_{i}$，那么递推关系如下： 当P(i)=p($k_{i}$)时，$k_{i+1}$=$k_{i}+1$ 当P(i)$\\not=p(k_{i}$)时, f(i+1)=k_{i+1}= \\left\\{ \\begin{array}\\ k_{k_{i}}+1 \\quad if \\quad p(k_{k_{i}})=p(i)\\\\ f(k_{k_{i}}+1) \\quad if \\quad p(k_{k_{i}})\\not=p(i) \\end{array} \\right. 递推法的详析下面先给出一个例子 毫无疑问，next(1)一定为零（只有一个字符），next(2)也为零，next(3)等于1。 next(4)等于1可以这么计算：由于p(4)只比p(3)多了一个a，并且已知p(3)最长前后缀长度为1，那么只要比较p(4)的第一位（序号从零开始）与新增的那位是否相等，若相等，则next(4)=next(3)+1应该是显然的，若不等，并不能说next(4)=0，实际上next(4)也不为零。 因为新增位与最长前缀的下一位不相等，只能说明next(4)的值不可能大于或等于next(3)，但是可能是小于next(3)的某个值。那么应该如何计算next(4)的值呢？请看下图 我们来观察next(10)的计算，p(10)新增的b与p(9)第六位的a，不同，所以next(10)&lt;6，现在我们任想找最长的前后缀，当然可以通过循环比较的方法来寻找，但是我们希望能充分利用已知的信息来简化计算。 刚才我们在已知最长前后缀abaaaba的基础上来比较下一位是否相等，结果不相等，自然而然，我们接下来应该找一个短一点的前后缀，再去比较这个短一点的前后缀的下一位是否相等，并且利用已知的条件可以很高效的找出这个短一点的前后缀，详析见下图 KMP算法的组织与暴力求解不同，在KMP算法中，我们希望仅用一个循环来解决问题。循环变量为主串的下标，第一次匹配时，模式串下标自增，当匹配失败时，模式串的下标由next(i)函数来确定，然后继续与主串进行匹配。这样就比避免了每次匹配失败时模式串下标的回溯。 模式串的下标与next(i)的关系：下标=next(i) KMP的程序实现 next函数的实现，程序如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Program { static void Main(string[] args) { //这是一个测试 int[] nextarray = Next(\"ababababca\"); foreach (var item in nextarray) { Console.Write(item + \" \"); } Console.Read(); } public static int[] Next(string pattern_str) { int len = pattern_str.Length; int[] next = new int[len]; //next数组的第0,1位一定是零 next[0] = 0; next[1] = 0; for (int i = 2; i &lt; len; i++) { //P(i)新增的字符与P(i-1)最长前缀的后一位匹配时的情况 if (pattern_str[i - 1] == pattern_str[next[i - 1]]) { next[i] = next[i - 1] + 1; } else { //P(i)新增的字符与P(i-1)最长前缀的后一位不匹配时，寻找更小的前后缀，并继续比较p(i)新增字符与新的前缀的后一个字符是否相等，相等，计算next(i)；不等，继续寻找更小的前后缀。 int j = next[i - 1]; while (j &gt;= 0) { j = next[j]; if (pattern_str[j] == pattern_str[i - 1]) { next[i] = j + 1; break; } else { //若最小的前后缀都无法使其后一位与P(i)新增的字符相等，则说明P(i)不存在前后缀，next(i)=0. if (j==0) { next[i] = 0; break; } } } } } return next; } } 运行上面的程序，我们将得到下面的结果 我们可以看到输出结果与前面计算的一样，为保证算法的准确性，使用字符串”abaabaababb”再次进行验证，得到如下输出 经验证，与计算结果一致，则程序基本无误。 KMP算法的整体实现 按照前面的算法分析，程序如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class Program { static void Main(string[] args) { Console.WriteLine(KMP(\"abdadabdabadabdabbb\", \"abdabb\")); Console.Read(); } public static int KMP(string main_str, string pattern_str) { //初始化工作，获取主串、模式串长度；计算next数组，循环变量初始化，结果初始化（无匹配的返回值） int main_len = main_str.Length; int pattern_len = pattern_str.Length; int j = 0; int target = -1; int[] next = Next(pattern_str); int i = 0; //主循环为主串下标的自增 while (i &lt; main_len) { //判断主串字符和模式串字符是否相等 if (main_str[i] == pattern_str[j]) { //若模式串下标已经达到最大，匹配成功，退出循环 if (j == pattern_len - 1) { //此时的i为匹配成功末位的值，需要减去模式串的长度再加一才是匹配成功首位的位置 target = i-pattern_len+1; break; } else { j++; } i++; } else { //如果j=0并且进入这个else说明模式串首位与主串i处不匹配，主串序号需要加一，否则下一次循环j还是0，会陷入循环比较 if (j == 0) { i++; } //由next数组求得下一次j的值 j = next[j]; } } return target; }//next数组的求解 public static int[] Next(string pattern_str) { int pattern_len = pattern_str.Length; int[] next = new int[pattern_len]; next[0] = 0; next[1] = 0; for (int i = 2; i &lt; pattern_len; i++) { if (pattern_str[i - 1] == pattern_str[next[i - 1]]) { next[i] = next[i - 1] + 1; } else { int j = next[i - 1]; while (j &gt;= 0) { j = next[j]; if (pattern_str[j] == pattern_str[i - 1]) { next[i] = j + 1; break; } else { if (j == 0) { next[i] = 0; break; } } } } } return next; } } 我们用给出的第一个例子来验证这个算法，得到结果为 经过验证，匹配成功的首位确为12处，程序无误。 KMP算法分析从程序的实现可以看出，算法可以分为两部分：next函数计算和匹配过程。其中，next函数的计算的时间复杂度为O(m1)，并且可以证明next函数计算耗费不会超过2m；而匹配的过程显然时间复杂度为O(n2)，并且可以证明匹配计算耗费不会超过2n。（具体证明限于篇幅，此处仅给出结论） 综上，KMP算法的时间复杂度为O(m+n)，是线性的，远小于暴力法的O((m-n)*n) 1. m为模式串的长度 ↩ 2. n为主串的长度 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/07/09/kmp-algorithm/","tags":[{"name":"Algorithm","slug":"algorithm","permalink":"http://zhumingcj.github.io/tags/algorithm/"}]},{"title":"Improved Square Method","date":"2019-07-08T13:56:00.000Z","text":"改进平方根法和追赶法虽然平方根法的时间复杂度远远低于高斯消元法和lU分解，但是n个开方运算会耗费很多的时间，所以为了避免开放运算，需要对平方根法进行改进。 追赶法则是求解严格对角占优矩阵效率最高的算法之一。 改进平方根法公式推导为了避免开方运算，我们使用$A=LDL^{T}$导出分解公式 由\\\\ A=LU=LDD^{-1}U=LDL^{T}\\\\ 可知L^{T}=D^{-1}U,因此\\\\ l_{i,j}=\\frac{u_{ij}}{d_{i}}=\\frac{u_{ij}}{u_{ii}},\\quad i=1,2,\\dots,n-1;j=i+1,i+2,\\dots,n\\\\ 由杜立特尔分解可知\\\\ u_{ij}=a_{ij}-\\sum_{k=1}^{i-1}l_{ik}u_{kj},\\quad i=1,2,\\dots,n;j=i,i+1,\\dots,n\\\\ \\Rightarrow l_{ij}=\\frac{a_{ij}-\\sum_{k=1}^{i-1}l_{ik}u_{kj}}{u_{ii}},\\quad i=1,2,\\dots,n-1;j=i+1,i+2,\\dots,n用$A=LDL^{T}$分解求解方程组Ax=b就是改进平方根法，下面导出计算公式 Ax=b \\Rightarrow LDL^{T}\\Rightarrow \\left\\{ \\begin{array}\\ Ly=b\\\\ Dz=y\\\\ L^{T}x=z \\end{array} \\right.\\\\ 由Ly=b可得\\\\ y_{1}=b_{1}\\\\ y_{i}=b_{i}-\\sum_{k=1}^{i-1}l_{ik}y_{k},\\quad i=2,3,\\dots,n\\\\ 由Dz=y可得\\\\ z_{i}=\\frac{y_{i}}{u_{ii}},\\quad i=1,2,\\dots,n\\\\ 由L^{T}x=z可得\\\\ \\left\\{ \\begin{array}\\ x_{n}=z_{n}\\\\ x_{i}=z_{i}-\\sum_{i+1}^{n}l_{ki}x_{k},\\quad i=n-1,n-2,\\dots,1 \\end{array} \\right.\\\\ 将z_{i}和l_{ki}=\\frac{u_{ik}}{u_{ii}}代入x_{i}的表达式，可得\\\\ \\left\\{ \\begin{array}\\ x_{n}=\\frac{y_{n}}{u_{nn}}\\\\ x_{i}=\\frac{y_{i}-\\sum_{k=i+1}^{n}u_{ik}x_{k}}{u_{ii}},\\quad i=n-1,n-2,\\dots,2,1 \\end{array} \\right.改进平方根法的算法分析采用改进平方根法求解Ax=b共用了乘除法$\\frac{1}{6}n^{3}+\\frac{3}{2}n^{2}-\\frac{2}{3}n$个，它比平方根法多了$\\frac{1}{2}n^{2}-\\frac{1}{2}n$个乘除法，但是少了n个开方运算，而相比于高斯消元法和杜立特尔分解几乎少了一半的乘除法，因此改进平方根法为求解对称正定方程组最有效的方法之一。实际上改进平方根法的分解公式和lU分解的分解公式是相同的，但是LU分解还要计算U矩阵，因此效率比较低，而改进平方根法则利用正定对称矩阵的特点，使得只需要计算L矩阵，大大减少了计算量，提高了效率。 追赶法的分解公式在样条插值、常微分方程边值问题和热传导方程的有限差分法等问题中，常遇到求解三对角方程组Ax=b,即 \\begin{pmatrix} b_{1}&c_{1}&\\\\ a_{2}&b_{2}&c_{2}\\\\ &\\ddots&\\ddots&\\ddots\\\\ &&a_{n-1}&b_{n-1}&c_{n-1}\\\\ &&&a_{n}&b_{n} \\end{pmatrix} \\begin{pmatrix} x_{1}\\\\ x_{2}\\\\ \\vdots\\\\ x_{n-1}\\\\ x_{n} \\end{pmatrix} = \\begin{pmatrix} d_{1}\\\\ d_{2}\\\\ \\vdots\\\\ d_{n-1}\\\\ d_{n} \\end{pmatrix}通常A是严格对角占优矩阵，严格对角占优矩阵存在唯一 的杜立特分解，形式如下 A=LU= \\begin{pmatrix} 1\\\\ l_{2}&1\\\\ &\\ddots&\\ddots\\\\ &&l_{n-1}&1\\\\ &&&l_{n}&1 \\end{pmatrix} \\begin{pmatrix} u_{1}&c_{1}\\\\ &u_{2}&c_{2}\\\\ &&\\ddots&\\ddots\\\\ &&&u_{n-1}&c_{n-1}\\\\ &&&&u_{n} \\end{pmatrix}根据矩阵乘法，我们可以导出分解公式如下 \\left\\{ \\begin{array}\\ u_{1}=b_{1}\\\\ l_{i}=\\frac{a_{i}}{u_{i-1}},\\quad i=2,3,\\dots,n\\\\ u_{i}=b_{i}-l_{i}c_{i-1},\\quad i=2,3,\\dots,n \\end{array} \\right.追赶法求解Ax=d的计算公式 Ax=d \\Rightarrow LUx=d\\Rightarrow \\\\ \\left\\{ \\begin{array}\\ Ly=d\\\\ Ux=y \\end{array} \\right. \\quad\\\\ 由Ly=d可得\\\\ \\left\\{ \\begin{array}\\ y_{1}=d_{1}\\\\ y_{i}=d_{i}-l_{i}y_{i-1},\\quad i=2,3,\\dots,n \\end{array} \\right. \\quad\\\\ 由Ux=y可得\\\\ \\left\\{ \\begin{array}\\ x_{n}=\\frac{y_{n}}{u_{n}}\\\\ x_{i}=\\frac{y_{i}-c_{i}x_{i+1}}{u_{i}},\\quad i=n-1,n-2,\\dots,1 \\end{array} \\right.追赶法的一个分解示例 A= \\begin{pmatrix} 1&2&0&0&0\\\\ 2&3&1&0&0\\\\ 0&-3&4&2&0\\\\ 0&0&4&7&1\\\\ 0&0&0&-5&6 \\end{pmatrix}\\\\ \\quad\\\\分解结果如下 追赶法的算法分析用追赶法来解线性方程的乘除法运算次数仅为5n-4,比高斯消元法的运算次数少得多。并且由于方程组的系数矩阵是严格对角占优的，因此能保证追赶法顺利进行，并且计算过程稳定。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/07/08/improved-square-method/","tags":[{"name":"Numerical Analysis","slug":"numerical-analysis","permalink":"http://zhumingcj.github.io/tags/numerical-analysis/"}]},{"title":"Square Root Method","date":"2019-07-06T07:36:28.000Z","text":"平方根法在有限元法求解结构力学和最优化方法等诸多问题中，都需要求解一个系数矩阵是正定的线性方程组Ax=b。针对这种方程组的特点，采用平方根法更加有效。所谓平方根法是将系数矩阵分解为一个下三角形矩阵和该矩阵的转置的乘积，然后在此基础上求解方程。 引理 若矩阵的各阶顺序主子式都不为零，则矩阵可以进行LU分解（1），且矩阵的LU分解唯一。现对（2）进行证明 设 \\quad\\quad\\quad\\quad A=LU \\quad\\\\ 且\\quad\\quad\\quad\\quad A=L_{1}U_{1}\\\\ 则 \\quad\\quad\\quad\\quad L_{1}^{-1}AU^{-1}=L_{1}^{-1}L \\quad\\quad\\\\ \\quad\\quad\\quad L_{1}^{-1}AU^{-1}=U_{1}U^{-1}\\\\ 即 \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad L_{1}^{-1}L=U_{1}U^{-1}\\\\ \\quad\\\\ 因为 L_{1}^{-1}L为下单位三角矩阵，而U_{1}U^{-1}为上单位三角矩阵\\\\所以L_{1}^{-1}L=U_{1}U^{-1}=I A为对称矩阵，当A的各阶顺序主子式都不等于零时，A可以唯一的分解为 ​ $A=LDL^{T}$ 现证明之 根据引理（1），A=LU，记D=diag(d_{1},d_{2},d_{3},\\dots,d_{n})=diag(u_{11},u_{22},\\dots,u_{nn})\\\\ 则 \\quad A=LU=LDD^{-1}U=LDM^{T},其中M^{T}=D^{-1}U\\\\ 又 \\quad A=A^{T}=MDL^{T}\\\\ 因为M为下三角矩阵，而DL^{T}为上三角矩阵，所以MDL^{T}也是A的一个LU分解\\\\ 由LU分解的唯一性可得=>L=M\\\\ 所以 \\quad A=MDL^{T}=LDL^{T} 平方根法重要定理 (对称正定矩阵的楚列斯基分解)设A是n阶对称正定矩阵，则存在一个可逆下三角矩阵G，使得 ​ $A=GG^{T}$ 且当限定G的对角元为正时，这种分解是唯一的。 证明： 由线性代数可知，正定矩阵的各阶顺序主子式都大于零，由上面的引理2可得\\\\ A=LDL^{T},且可证明D的对角元都大于零\\\\ \\forall x\\not=0 ,\\quad 0 { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/07/06/square-root-method-and-improved-square-root-method/","tags":[{"name":"Matrix","slug":"matrix","permalink":"http://zhumingcj.github.io/tags/matrix/"}]},{"title":"Web Basic Skills","date":"2019-07-05T08:15:57.000Z","text":"HTML(HyperText Markup Language)、CSS和Javascript​ 对于一个网页而言，主要由 HTML、CSS和Javascript组成。其中HTML主要负责网页框架的搭建，CSS主要负责网页的样式而JavaScript主要负责网页的行为。 常用的HTML标签 &lt;html&gt;&lt;/html&gt; 这个标签没什么用，但是所有HTML标签都需要写在这个标签内部 &lt;head&gt;&lt;/head&gt; head标签是用来写一些给浏览器看的内容，包括网站名，网站描述等 head内部常用的标签 meta标签 1234&lt;meta charset=\"utf-8\"&gt; &nbsp;&lt;!--申明网页的编码格式--&gt;&lt;!--utf-8为编码字符集--&gt;&lt;meta name=\"keywords\" content=\"xx\"&gt;&lt;!--描述网页的类别，给网络爬虫看的信息--&gt;&lt;meta name=\"description\" content=\"xx\"&gt;&lt;!--对网页的描述，也是给爬虫看的信息--&gt; 常用的字符编码有： - gb2312(包括亚裔字符集) - gbk(在gb2312基础上增加了繁体中文) - unicode(万国码)title标签 title标签 1&lt;title&gt; 这里可以写标题（浏览器上方显示的）&lt;/title&gt; body标签 123&lt;body&gt; 这里是网页的主体&lt;/body&gt; body内常用的标签 p标签 123&lt;p&gt;这是一个段落，常用来换行&lt;/p&gt; h标签 123&lt;h1&gt;这是一个标题&lt;/h1&gt;&lt;h2&gt;这也是一个标题&lt;/h2&gt;&lt;!--最多到h5--&gt; strong标签 1&lt;strong&gt;加粗&lt;/strong&gt; em标签 1&lt;em&gt;斜体&lt;/em&gt; del标签 1&lt;del&gt;中划线，效果参考打折的价格&lt;/del&gt; div标签 1&lt;div&gt;只是一个容器，无具体功能，有利于模块化和绑定操作&lt;/div&gt; sapn标签 1&lt;span&gt;这也是一个容器&lt;/span&gt; a标签 123&lt;a herf=\"www.baidu.com\" target=\"_blank\"&gt;这是超链接锚点，最初的作用为&lt;/a&gt;&lt;!--target的值决定是在当前页面打开链接还是在新的页面中打开页面--&gt;&lt;!--herf的值除了URL还可以是tel(打电话)和mailto(发邮件),还可以是JavaScript（协议限定符，此标识后可写java代码，用户点击时会强行运行）--&gt; br标签 1&lt;br&gt;换行&lt;/br&gt; hr标签 1&lt;hr&gt;这是水平线&lt;/hr&gt; ol和li标签 12345678&lt;ol type=\"a\" start=\"value\"&gt;&lt;1--value的值决定最开始的序号值--&gt;&lt;!--type的值不同，列表的样式不同,1&gt;=序号为阿拉伯数字;I/i&gt;=序号为小写/大写罗马数字;A/a=&gt;序号为大小写英文字母--&gt; &lt;li&gt;这是一个有序列表，ol和li是一起使用的&lt;/li&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;橘子&lt;/li&gt; &lt;li&gt;樱桃&lt;/li&gt;&lt;/ol&gt; ul和li标签 12345678&lt;ul type=\"disc\"&gt;&lt;!--type的值决定无序列表的样式，具体不做叙述--&gt; &lt;li&gt;这是无序列表&lt;/li&gt; &lt;li&gt;圆&lt;/li&gt; &lt;li&gt;正方形&lt;/li&gt; &lt;li&gt;三角形&lt;/li&gt; &lt;li&gt;矩形&lt;/li&gt;&lt;/ul&gt; 注：ui和li常用来做导航栏，菜单栏等功能和形式差不多，天生具有父子结构的对象 img标签 1234&lt;img src=\"图片的相对地址或绝对地址\" alt=\"图片的摘要\" title=\"图片的描述\"&gt;&lt;!--当网页文件和图片处于同一个文件夹下时，可以使用相对地址，更加简单；否则使用绝对地址才能正常加载图片--&gt;&lt;!--Alt的值是当图片无法正常加载时显示 在图片上的信息，用来改善用户体验--&gt;&lt;!--title的值是用户的鼠标放在图片上时会显示的信息--&gt; form标签 123456789101112131415161718&lt;form method=\"get/post\" action=\"发送信息的地址\"&gt; &lt;input type=\"text\" name=\"username\"&gt;&lt;!--这文本输入框--&gt; &lt;input type=\"password\" name=\"password\"&gt;&lt;!--这密码框--&gt; &lt;input type=\"submit\"&gt;&lt;!--这是提交按钮--&gt; &lt;input type=\"radio\" name=\"xx\"&gt;&lt;!--这是当选框,只有当数个单选框的name值相同时，才会发挥单选的功能--&gt; &lt;input type=\"radio\" name=\"xx\"&gt; &lt;input type=\"radio\" name=\"xx\"&gt; &lt;input type=\"checkbox\" name=\"xxx\"&gt;&lt;!--这是复选框,只有当数个复选框的name值相同时，才会正常发挥复选的功能--&gt; &lt;input type=\"checkbox\" name=\"xxx\"&gt; &lt;input type=\"checkbox\" name=\"xxx\"&gt; &lt;select&gt; &lt;option&gt;北京&lt;/option&gt;&lt;!--这是一个下拉框--&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option&gt;天津&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;!--想要正确提交信息，必须要有name和value--&gt;&lt;/form&gt;复 标签的归类 行级元素 feature： 内容决定元素所占位置 不可以通过css改变宽高 常见的有： span strong em a del 块级元素 feature： 独占一行 可以通过css代码改变宽高 常见的有： div p ul li ol form address 行级块元素 feature: 内容决定大小 可以通过css改宽高 标签类型的实质： 都是css特性的表现——对象都有一个display的css属性，display有三个属性值=&gt; inline (行级) 2.block (块级) 3.inline-block (行级块元素) 所以标签的类型不是固定的，可以通过css代码来更改；此外，所有属性为inline的对象都具有文字特性，即空格会被视为文本分隔符即如果inline对象之间有空格/空行就会间隔一定距离。 HTML补充 HTML语言中没有空格标签，所有空格都是文本分隔符，如果想要输入空格需输入&amp;nbsp，此外，其它特殊字符还有 &lt; &amp;lt &gt; &amp;gt HTML标签是可以嵌套的，通过嵌套可以实现各种不同的功能。 html还有很多复杂的标签，但是基本上很少用，因为网络编程要求结构和样式和行为相分离，那些复杂的标签多为带有样式的标签。 CSS代码CSS代码引入的方式 行间样式（内联），如 12345&lt;div style=\"width: 100px;height: 100px;background-color: #f40\"&gt;&lt;/div&gt; 页面级CSS，如 1234567&lt;style type=\"text/css\"&gt; div{ width: 100px; height: 100px; background-color: #f40; } &lt;/style&gt; 外部CSS文件（最常用），如 12345678div{ border:1px solid black;text-align: right; text-indent: 2em; cursor: ; text-decoration: line-through;} 但是，外部CSS文件要能作用到HTML文件上，需要在HTML文件的head中加入如下代码 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"CSS文件地址\"&gt; 浏览器的策略 浏览器从服务器下载HTML文件时，采取下载一行执行一行的形式 当执行到link CSS的代码时，浏览器会开启一个新的线程来同时下载CSS和HTML文件 在执行复杂选择器时，浏览器采用从右向左的方式，可以提高搜索的效率 CSS选择器 Id选择器 1234#only{ background-color: #ff3058}/*首先要求对象具有ID，ID是一对一唯一的标识，其中only为ID值*/ class选择器 1234.typeone{ background-color: #345564}/*对象应具有class，且class不唯一，其中typeone为class值*/ 标签选择器 1234div{ background-color: #634432}/*标签选择器会选中所有该类标签*/ 通配符选择器 1234*{ background-color: #243543;}/*此选择器会作用到全局*/ 属性选择器，如 1234567[id]{ background-color: #f84;}/*也可以指定属性值*/[id=\"only\"]{ background-color: #f84;} ！important 1234#only{ background-color: #ff3058!important}/*加上！important后，此选择器优先级最高*/ 父子选择器 1234567div span{ background-color: #567889;}#demo1 .typeone span{ background-color: #678980;}/*可以用来限定目标，可以套很多层，且形式不一定要一样*/ 直接子元素选择器 1234div &gt; span{ background-color: #779}/*只会作用于字节的子类*/ 并列选择器 1234div.demo1{ background-color: #655;}/*可以用多个选择器不加空格的组合到一起，可涮选出符合所有条件的对象*/ 分组选择器 1234567em.demo1,strong #only,div{ background-color: #658;}/*可以实现代码的复用，把具有同样样式的选择器用逗号隔开，则可作用于所有对象*/ 伪类选择器 1234a:hover{ background-color: orange;}/*当鼠标移动到对象的领域之内时，为对象加上相应的样式，当鼠标移开后，则会移除相应的样式*/ CSS选择器的优先级和权值 优先级 ！important&gt;行间样式&gt;ID&gt;class|属性&gt;标签选择器&gt;* CSS选择器的权值 ！important infinity 行间样式 1000 ID 100 class|属性|伪类 10 标签|伪元素 1 通配符 0 CSS权重用于选择器优先级的比较，多重选择器嵌套可以将权重相加，且权重的值不为十进制而是256进制！！！ CSS代码常用属性 font-size: 50px; 设置字体的大小（实际设置字体的高） font-weight: bold; 设置字体的粗细 font-style: italic; 斜体 font-family: arial; 设置字体样式 color: #424; 设置字体颜色 border: 1px solid black; 设置外边框的粗细、样式（直线，虚线等）和颜色 width: 100px; 设置宽 height: 100px; 设置高 text-align: right; 设置文本对齐方式（左对齐，右对齐，居中） line-height: 20px; 单行字体行高，用以控制行间距 text-indent: 2em; 设置缩进，单位是em（当前每个字体的像素大小） text-decoration: line-through; 对字体进行装饰，值不同样式不同（下划线，中划线，上划线等） cursor: pointer; 设置鼠标聚焦时鼠标样式的变化 字体颜色的三种形式 纯英文单词 12color: green;color: blue; 颜色代码 123color: #ff4400;color: #768798;color: #ff3; 颜色函数 12color: rgb(3,35,234);color: rgb(32,43,255); 注：颜色代码是由光学三原色混合而成的（r[00-ff];g[00-ff];b[]00-ff）,所以需要六位的值来确定颜色，但是如果每两位都是一样的，则可以进行简写，即每两位并成一位；而颜色函数也是由光学三颜色合成的，但是只需要三个参数，每一位的范围是0-255.实际上颜色代码和颜色函数是等价的，只是颜色函数只是把两位十六进制数组成256进制位。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/07/05/HTML Basic Skills/","tags":[{"name":"HTML","slug":"html","permalink":"http://zhumingcj.github.io/tags/html/"}]},{"title":"https protocol","date":"2019-07-04T12:35:04.000Z","text":"https协议详析当我们使用浏览器时可能会发现我们输入的网站有以http和以https开头的，它们的区别在于哪里呢？实际上，可以说https是http的升级版，是对其安全性的加强。 浏览器的一般工作流程 当用户输入要访问的URL后，浏览器会根据URL解析出其域名 通过DNS服务器查询出域名映射的IP地址 根据查询到的IP地址与web服务器建立通讯 上述过程可以抽象为下图 TCP/IP协议http协议是构建在TCP/IP协议的基础上的，所以我们有必要了解Tcp/Ip相关的知识。 TCP/IP协议的分层模型TCP/IP协议是由四层协议组成的系统，这四层分别为：应用层、传输层、网络层、链路层，如下图所示 应用层 应用层是我们编写的应用程序，它决定了向用户提供的应用服务。应用层可通过系统调用与传输层通讯。 处于应用层的协议非常多，比如：FTP(File Transfer Protocol，文件传输协议)、DNS(Domain Name System,域名系统)以及HTTP(HyperText Transfer Protocol,超文本传输协议)等。 传输层 传输层通过系统调用向应用层提供两台计算机之间的数据传输功能。 在传输层有两个性质不同的协议：TCP(Transmission Control Protocol,传输控制协议)和UDP(User Data Protocol,用户数据协议)。其中TCP在数据传输的安全性上高于UDP，但是其传输速度比较慢，所以一般快速下载软件都是用UDP,比如迅雷。 网络层 网络层用来处理网络上流动的数据包，归顶数据包的传输路径。 链路层 链路层是用来处理连接网络的硬件部分，包括操作系统、硬件设备驱动、NIC(Network Interface Card,网络适配器)以及光纤等硬件。 TCP协议TCP协议是全双工的字节流传输，具有可靠性高的特点，为了确保其可靠性，TCP协议采用了”三次握手“的策略，如下图 在图中，我们可以看到： 首先客户端会向服务器发送一个带有SYN标志的连接请求 服务器接收到请求会作出应答，如果能接受连接，这服务器发送ACK进行确认，并且还会发送自己的SYN请求 客户端接受到SYN和ACK后，在向服务器发送ACK确认接受连接 三次握手完毕后会在客户端和服务器之间建立双向通信 为了维持TCP协议，在数据传输的过程中，接收端在接收端数据后都要给发送端发送ACK进行确认。若发送端在一定时间内没有接受到ACK确认，则会重发丢失的数据包 HTTP协议简介HTTP协议（Hyper Text Transfer Protocol，超文本传输协议）,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP基于TCP/IP通信协议来传递数据。 HTTP基于客户端/服务端（C/S）架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。 特点（1）HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 （2）HTTP是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 （3）HTTP是无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP协议的不足 HTTP协议采用明文通讯，内容很有可能被窃听 无法验证对方身份，任何第三方可以通过伪装与服务器通讯 无法确定数据的可靠性，在传输中可能会被篡改 HTTPs协议为了解决HTTP存在的问题，HTTPs应运而生，HTTPs采用SSL/TLS协议对传输的数据进行加密，保证了传输不被窃听；同时通过CA(由第三方权威机构颁发)证书验证通信双方的身份。 有关CA证书CA证书是公司向权威机构申请，由权威机构颁发的。CA证书会被安装到服务器上，其中内容包括： 持有者姓名 发证机关 有效日期 证件持有人的公钥 扩展信息 发证机关对该证书的数字签名（=前5点信息的MD5摘要，然后用CA的私钥加密） HTTPs的通信原理 客户端信任发证机关的证书，一般用户不需要操作。因为CA（权威）[下面简称为CAA]证书存储在浏览器中，而浏览器一般自动信任了大多数的权威机构证书。 在请求建立的过程中，首先客户端会向服务器发送一次请求，服务器向客户端返回一个CA（公司服务器）证书[后简称CAS] 客户端根据得到的CAS证书读得发证机关的信息，找到内置的对于机关的CAA证书，从证书中找到机关的加密公钥，用公钥（解密钥）对得到的CAS证书的第六点信息进行解密，如果解得的信息与CAS证书前五点摘要的MD5相同，则说明服务器的CAS证书确为该机构颁布的，进而证明了服务器的身份 客户端再用CAS中得到的服务器的公钥（加密钥）加密一个信息比如“123”发送给服务器，服务器则根据其持有的私钥（解密钥）对信息进行解密，然后服务器把解密结果返回给客户端，若解密得到的信息与发送信息一致，则可证明该服务器就是客户端要访问的服务器。这样可防止因域名写错而造成的错误访问。 然后客户端会向服务器发送一条信息用以约定通信过程中的对称加密钥，然后即可在双方之间建立通信，以后的通信中发送端会用该对称加密钥对传输数据进行加密，而接收端也用该对称秘钥进行解密。这样就可以防止信息被窃听。 通信流程图如下 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/07/04/https-protocol/","tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://zhumingcj.github.io/tags/网络协议/"}]},{"title":"Usage of Trigonometric Decomposition","date":"2019-07-03T00:38:07.000Z","text":"三角分解解线性方程组相比于高斯消元法，应用三角分解来解线性方程组在某些情况下能提高计算的效率。 三角分解解线性方程的公式推导即，我们要解 LUx=b, 我们把这个方程拆为两个方程来解 \\left\\{ \\begin{array}\\ Ly=b\\\\ Ux=y \\end{array} \\right.解方程组Ly=b的第一个方程为$y_{1}=b_{1}$，而第i个方程为 \\sum_{j=1}^{i-1}(l_{ij}y_{ij}+y_{i}=b_{i})\\Longrightarrow\\\\ \\left\\{ \\begin{array}\\ y_{1}=b_{1},\\\\ y_{i}=b_{i}-\\sum_{j=1}^{i-1}l_{ij}y_{j},\\quad i=1,2,3,\\dots,n \\end{array} \\right.将解得的y代入Ux=y，由高斯消元法回代公式可得 \\left\\{ \\begin{array}\\ x_{n}=\\frac{y_{n}}{u_{nn}},\\\\ x_{i}=\\frac{y_{i}-\\sum_{j=i+1}^{n}u_{ij}x_{j}}{u_{ii}},\\quad i=n-1,n-2,\\dots,2,1 \\end{array} \\right. 一个LU分解的例子 A= \\begin{pmatrix} 9&18&9&-27\\\\ 18&45&0&-45\\\\ 9&0&126&9\\\\ -27&-45&9&135 \\end{pmatrix} \\quad\\quad\\quad\\quad\\quad\\quad b= \\begin{pmatrix} 1\\\\ 2\\\\ 16\\\\ 8 \\end{pmatrix}现在对A进行分解 即可得 L= \\begin{pmatrix} 1&\\\\ 2&1&\\\\ 1&-2&1\\\\ -3&1&\\frac{2}{3}&1 \\end{pmatrix} \\quad\\quad U= \\begin{pmatrix} 9&18&9&-27\\\\ 0&9&-18&9\\\\ 0&0&81&54\\\\ 0&0&0&9 \\end{pmatrix}\\\\ \\quad\\\\ \\quad\\\\ y= \\begin{pmatrix} 1\\\\0\\\\15\\\\1 \\end{pmatrix}LU分解解线性方程组的算法分析由矩阵LU分解公式可知，计算$u_{ij}$和$l_{ij}$各有 ​ $\\sum_{j=2}^{n-1}(j(n-j)+n-1=\\sum_{1}^{n-1}j(n-j)=1/6n^{3}-1/6n$ 个乘除法，所以矩阵分解共有$1/3n^3-1/3n$个乘除法，而求解下三角方程Ly=b有$1/2n(n-1)$个乘除法，求解上三角方程Ux=y有$1/2n(n-1)+n$个乘除法，综上，用LU分解来解线性方程组共有$\\frac{1}{3}n^{2}+n^{2}-\\frac{1}{3}n$个乘除法，与高斯消元法的运算次数一样。 但是从LU分解的形式上看，不难发现如果我们要解一系列系数矩阵相同但右端不同的方程组时，LU分解可以大大减少计算量。 编程实现LU分解 程序如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Trigonometric_Decomposition{ class Program { static void Main(string[] args) { Matrix m= new Matrix(6, 6); m.LuDecomposition(); m.DisPlay(); Console.Read(); } class Matrix { public int row = 0; public int column = 0; private float[,] matrix; \\\\矩阵的输入 public Matrix(int row, int column) { this.row = row; this.column = column; Console.WriteLine($\"Please enter a matrix with {this.row}rows,{this.column}colums\"); matrix = new float[row, column]; try { for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; column; j++) { string mid = Console.ReadLine(); var rows = mid.Split(' '); foreach (var item in rows) { matrix[i, j++] = float.Parse(item); } } } Console.WriteLine(\"\\r\\n\"); } catch (Exception e) { Console.WriteLine($\"something wrong!\\n{e.Message}\"); } } \\\\输出矩阵 public void DisPlay() { for (int i = 0; i &lt; this.row; i++) { for (int j = 0; j &lt; this.column; j++) { Console.Write(matrix[i, j] + \" \"); } Console.WriteLine(\"\\r\"); } } \\\\矩阵的LU分解 public void LuDecomposition() { //初始化第一行、第一列 for (int i = 1; i &lt; this.column; i++) { matrix[i, 0] = matrix[i,0] / matrix[0, 0]; } for (int i = 1; i &lt; this.row; i++) { //先计算对角元，避免重复计算（放在第二个循环内会计算两次） matrix[i, i] = matrix[i, i] - FigureTemp(i, i, i ); for (int j = i+1; j &lt; this.column; j++) { //第i行i列的更新 matrix[i, j] = matrix[i, j] - FigureTemp(i, j, i); matrix[j, i] = (matrix[j, i] - FigureTemp(i, j, i))/matrix[i,i]; } } } private float FigureTemp(int i,int j,int k) { //用于计算求和中间量 float result = 0; for (int s = 0; s &lt; k; s++) { result += matrix[i, s] * matrix[s, j]; } return result; } } }} 程序的验证 当我们输入矩阵 A= \\begin{pmatrix} 9&18&9&-27\\\\ 18&45&0&-45\\\\ 9&0&126&9\\\\ -27&-45&9&135 \\end{pmatrix}将得到输出如下 经对比，与上面计算的一致，程序无误。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/07/03/usage-of-trigonometric-decomposition/","tags":[{"name":"Matrix","slug":"matrix","permalink":"http://zhumingcj.github.io/tags/matrix/"}]},{"title":"Triangular Decomposition","date":"2019-07-02T12:26:18.000Z","text":"矩阵的LU分解矩阵的分解在矩阵的研究中有着极其重要的地位，而LU分解则是矩阵分析中一种常见而又重要的分解. LU分解——从高斯消元法说起LU分解的来龙去脉在高斯消元法中，我们使用了多次倍加把主对角元以外的元素变为零，这个过程可以看成是用一系列的初等矩阵来左乘系数矩阵。 A^{(0)}=A \\quad\\quad\\quad A^{(1)}\\triangleq \\begin{pmatrix} a_{11}^{(0)}&a_{12}^{(0)}&\\dots&a_{1n}^{(0)}\\\\ 0&a_{22}^{(1)}&\\dots&a_{2n}^{(1)}\\\\ \\vdots&\\vdots&&\\vdots\\\\ 0&a_{n2}^{(1)}&\\dots&a_{nn}^{(1)} \\end{pmatrix}\\quad\\quad\\quad\\\\ \\quad\\\\ L_{1}\\triangleq \\begin{pmatrix} 1&&&&\\\\ -l_{12}&1\\\\ -l_{13}&&1&&\\\\ \\vdots&&&\\ddots\\\\ -l_{1n}&&&&1 \\end{pmatrix}则有$A^{(1)}=L_{1}A^{(0)}$,同理有 A^{(2)}\\triangleq \\begin{pmatrix} a_{11}^{(0)}&a_{12}^{(0)}&a_{}13^{(0)}&\\dots&a_{1n}^{(0)}\\\\ 0&a_{22}^{(1)}&a_{23}^{(1)}&\\dots&a_{2n}^{(1)}\\\\ 0&0&a_{33}^{(2)}&\\cdots&a_{3n}^{(2)}\\\\ \\vdots&\\vdots&\\vdots&&\\vdots\\\\ 0&0&a_{n3}^{(2)}&\\dots&a_{nn}^{(1)} \\end{pmatrix}\\quad\\quad\\quad\\\\ \\quad\\\\ \\quad\\\\ L_{2}\\triangleq \\begin{pmatrix} 1&&&&\\\\ &1\\\\ &-l_{32}&1\\\\ &-l_{42}&&1&&\\\\ &\\vdots&&&\\ddots\\\\ &-l_{n2}&&&&1 \\end{pmatrix} \\\\A^{(2)}=L_{2}A^{(1)}一般的，有 A^{(k-1)}\\triangleq \\begin{pmatrix} a_{11}^{(0)}&a_{12}^{(0)}&&\\dots &\\dots&a_{1n}^{(0)}\\\\ &a_{22}^{(1)}&&\\dots&\\dots&a_{2n}^{(1)}\\\\ &&\\ddots&&&\\vdots\\\\ &&&a_{kk}^{(k-1)}&\\dots&a_{kn}^{(k-1)}\\\\ &&&\\vdots&\\dots&\\vdots\\\\ &&&a_{nk}^{(k-1)}&\\dots&a_{nn}^{(k-1)} \\end{pmatrix}\\quad\\quad\\quad\\\\ \\quad\\\\ \\quad\\\\ L_{2}\\triangleq \\begin{pmatrix} 1&&&&\\\\ &\\ddots\\\\ &&1\\\\ &&-a_{k+1,k}&1\\\\ &&-l_{k+2,k}&&1&&\\\\ &&\\vdots&&&\\ddots\\\\ &&-l_{nk}&&&&1 \\end{pmatrix}\\\\ \\quad\\\\ \\quad\\\\ \\quad\\\\ A^{(k)}\\triangleq A^{(k-1)}\\triangleq \\begin{pmatrix} a_{11}^{(0)}&a_{12}^{(0)}&&\\dots&a_{1,k+1}^{(0)} &\\dots&a_{1n}^{(0)}\\\\ &a_{22}^{(1)}&&\\dots&a_{2,k+1}^{(1)} &\\dots&a_{2n}^{(1)}\\\\ &&\\ddots&&\\vdots&&\\vdots\\\\ &&&a_{kk}^{(k-1)}&a_{k,k+1}^{(k-1)} &\\dots&a_{kn}^{(k-1)}\\\\ &&&&a_{k+1,k+1}^{k}&\\dots&a_{k+1,n}^{(k)}\\\\ &&&&\\vdots&&\\vdots\\\\ &&&&a_{n,k+1}^{(k)}&\\dots&a_{nn}^{(k)} \\end{pmatrix}\\quad\\quad\\quad A^{(k)}=L_{k}A^{(k-1)}=\\dots=L_{k}L_{k-1}\\dots L_{1}A^{(0)}.因为一共有n-1步消元，所以$A^{(n-1)}=L_{n}L{n-1}\\dots L_{k}\\dots L_{2}L_{1}A^{(0)}$ A^{(n-1)}= \\begin{pmatrix} a_{11}^{(0)}&a_{12}^{(0)}&\\dots&a_{1n}^{(0)}\\\\ &a_{22}^{(1)}&\\dots&a{2n}^{(1)}\\\\ &&\\ddots&\\vdots\\\\ &&&a_{nn}^{n-1} \\end{pmatrix}我们注意到$L_{k}$的逆矩阵为 L_{k}^{-1}= \\begin{pmatrix} 1&&&\\\\ &\\ddots&&\\\\ &&1&&\\\\ &&-l_{k+1,k}&1\\\\ &&\\vdots&&\\ddots\\\\ &&l_{n,k}&&&1 \\end{pmatrix}则$A=A^{(0)}=L_{1}^{-1}L{2}^{-1}\\dots L_{n-1}^{-1}A^{(n-1)}=LU$ 其中 L\\triangleq L_{1}^{-1}L_{2}^{-1}\\dots L_{n-1}^{-1}= \\begin{pmatrix} 1&&&&\\\\ l_{21}&1\\\\ l_{31}&l_{32}&1\\\\ \\vdots&\\vdots&&\\ddots\\\\ l_{n1}&l_{n2}&\\dots&l_{n,n-1}&l_{n,n} \\end{pmatrix}\\\\ \\quad\\\\ \\quad\\\\ U\\triangleq A^{(n-1)} \\begin{pmatrix} u_{11}&u_{12}&\\dots&u_{1n}\\\\ &u_{22}&\\dots&u_{2n}\\\\ &&\\ddots&\\vdots\\\\ &&&u_{nn} \\end{pmatrix}显然可知L为下三角矩阵而U为上三角矩阵 LU分解的公式推导根据$A=LU$,由矩阵乘法可得 a_{ij}=\\sum_{k=1}^{n}l_{ik}u_{kj},\\quad i,j=1,2,\\dots,n \\quad(1)注：由L为下三角矩阵可知$l_{ij}=0, when j&gt;i$ 同样的因为U是上三角矩阵，所以$u_{ij}=0, when i&gt;j$ 由（1）可先计算U的元 a_{ij}=\\sum_{k=1}^{i}l_{ik}u_{kj}=\\sum_{k=1}^{i-1}l_{ik}u_{kj}+u_{ij}\\quad\\quad 故\\\\ u_{ij}=a_{ij}-\\sum_{k=1}^{i-1}l_{ik}u_{kj}\\quad i=1,2,\\dots,n;j=i,i+1,\\dots,n \\\\ 特别的,当i=1时，u_{1j}=a_{1j}(j=1,2,\\dots,n)然后再计算L的元 a_{ij}=\\sum_{k=1}^{j}l_{ik}u_{kj}=\\sum_{k=1}^{j-1}l_{ik}u_{kj}+l_{ij}u_{jj}\\\\ \\quad\\\\ l_{ij}=\\frac{a_{ij}-\\sum_{k=1}^{j-1}l_{ik}u_{kj}}{u_{jj}}\\\\ 特别的，当j=1时，l_{i1}=\\frac{a_{i1}}{u_{11}}综上所述，我们可以得到如下公式 \\left\\{ \\begin{array}\\ u_{1j}=a_{1j},\\quad\\quad\\quad\\quad\\quad j=1,2,\\dots,n\\\\ l_{i1}=\\frac{a_{i1}}{u_{11}},\\quad\\quad\\quad\\quad\\quad i=2,3,\\dots,n\\\\ u_{ij}=a_{ij}-\\sum_{k=1}^{i-1}l_{ik}u_{kj},\\quad\\quad\\quad\\quad\\quad i=2,3,\\dots,n;j=i,i+1,\\dots,n\\quad\\quad\\quad（2）\\\\ l_{ij}=\\frac{a_{ij}-\\sum_{k=1}^{j-1}l_{ik}u_{kj}}{u_{jj}},\\quad\\quad j=2,3,\\dots,n-1;i=j+1,j+2,\\dots,n \\end{array} \\right. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/07/02/triangular-decomposition/","tags":[{"name":"Matrix","slug":"matrix","permalink":"http://zhumingcj.github.io/tags/matrix/"}]},{"title":"Singleton Pattern","date":"2019-07-01T10:52:18.000Z","text":"单例模式——单例模式是六中23种设计模式中最简单的一种，虽然如此单例模式还是有值得探讨的地方。 单例模式的用处顾名思义，单例模式就是想产生一个唯一的实例，而这样做的目的在于： 对于某些频繁使用的全局对象，如果频繁地创建和销毁会占用很多的系统资源 在一些场景中，需要唯一的实例，比如序列号、资源管理器等，其本身要就具有唯一性。 单例模式的简介单例模式一般分为两类，俗称懒汉式和饿汉式——懒汉式是指当真正要使用到这个对象时才去创建这个对象；而饿汉式则是在程序运行之初就完成对象的创建。 要想实现单例模式，首先就要把构造函数私有化，这样外部就无法通过调用构造函数来生成更多的实例了。但是这时就要对外提供产生实例的接口，并在内部完成单例的创建。 单例模式的几种实现方式 最简单的单例模式可以采用一个静态字段来保存单例，外界调用创建单例的方法时就把这个对象返回。静态字段会在程序一开始就初始化（由CLR实现），因此这是饿汉式的单例模式。 12345678910111213141516/// &lt;summary&gt; /// 最简单的单例模式，使用静态字段保存唯一单例，对外提供一个方法访问来获取单例 /// &lt;/summary&gt; public class Singleton { private static Singleton _singelton = new Singleton(); private Singleton() { } public static Singleton CreatInstance() { return _singelton; } } 上面这种单例模式的实现方式存在一定的问题，试想如果这个单例在程序运行一开始并没有被使用，它就会占据系统的资源，会影响程序的效率（一个典型的例子是数据库链接，会占用大量资源）。所以改进的单例模式使用Lazy Loading，也就是懒汉模式。 /// &lt;summary&gt;123456789101112131415161718192021222324252627282930/// &lt;summary&gt; /// 实现了Lazy Loading的单例模式，没有使用不会占用资源，但是它不是线程安全的 /// &lt;/summary&gt; public class Singleton2 { private long sum = 0; private static Singleton2 _singelton = null; private Singleton2() { Console.WriteLine($\"{this.GetType().Name} 被构造了\"); } public void Change() { sum++; } public static Singleton2 CreatInstance() { if (_singelton == null) { _singelton = new Singleton2(); } return _singelton; } public static void Show() { Console.WriteLine(_singelton.sum); } } 上一种单例模式可以满足一般的需求，但当涉及到多线程并发时，上一种方法会尝试问题，因为它不是线程安全的，所以需要枷锁同步 123456789101112131415161718192021222324252627282930313233343536/// &lt;summary&gt; /// 实现了Lazy Loading并且是线程安全的,但是在高并发的情况下会产生等待 /// &lt;/summary&gt; public class Singleton3 { private long sum = 0; private static Singleton3 _singleton = null; private static readonly object locker = new object(); private Singleton3() { Console.WriteLine($\"{this.GetType().Name} 被构造了\"); } public void Change() { lock (locker) sum++; } public static Singleton3 CreatInstance() { lock (locker) { if (_singleton == null) { _singleton = new Singleton3(); } } return _singleton; } public static void Show() { Console.WriteLine(_singleton.sum); } } 现在已经接近完美了，但是任存在一个问题——性能的消耗，因为每次调用CreateInstance方法时，都要争取锁而排队，会造成阻塞。所以我们希望当单例完成创建后不要再排队，这就有名为了Double-Checked的单例模式 1234567891011121314151617181920212223242526272829/// &lt;summary&gt; /// 使用Double-check,与前一种方法一样，但是性能有提高，单例已生成的情况下不用等待 /// &lt;/summary&gt; public class Singleton4 { private static Singleton4 _singelton = null; private static readonly object locker = new object(); private Singleton4() { Console.WriteLine($\"{this.GetType().Name} 被构造了\"); } public static Singleton4 CreatInstance() { if (_singelton == null) { lock (locker) { if (_singelton == null) { _singelton = new Singleton4(); } } } return _singelton; } } 现在事情似乎已经很完美了，但是如果细究一下我们会发现这样一个问题：当多个线程访问CreateInstance时，（单例还没有创建的情况下）它们都会进入第一个if语句开始排队，会有一个线程争得锁进入第二个if，然后调用构造函数创建单例，创建完后释放锁，第二个线程进入，第二个线程首先会检查_singleton的状态是否为空，现在问题就出现了，如果这个描述对象是否为空的属性如果没有及时更新，那么就会导致多个实例的产生。这种情况是可能存在的，这是编译器所决定的，由于读写无序则会导致前面的情况出现（先访问了实例是否存在的属性，之后才进行了这个属性的写操作）。改进的方法是在存储单例的静态字段前加上valotile关键词。 1234567891011121314151617181920212223/// &lt;summary&gt; /// 也可以使用volatile关键字保证线程安全 /// &lt;/summary&gt; public class Singleton5 { private static readonly object locker = new object(); private static volatile Singleton5 _singelton = null; public static Singleton5 CreatInstance() { if (_singelton == null) { lock (locker) { if (_singelton == null) { _singelton = new Singleton5(); Console.WriteLine(\"Singleton 被构造了\"); } } } return _singelton; } } 注：volatile关键字的作用是保证被它修饰的对象（包括引用类型、指针类型、整型、具有整数基类型的枚举类型、泛型等）是和改变同步的，即永远是最新的（可以理解为volatile修饰的对象写操作先于读操作），具体原理涉及内存的操作，此处不做叙述。 关于单例线程安全问题的直观验证 根据上面封装的类，当我们运行如下代码时 123456789101112131415161718192021static void Main(string[] args) { List&lt;Task&gt; tasks1 = new List&lt;Task&gt;(); for (int i = 0; i &lt; 10000; i++) { Singleton2 singleton = Singleton2.CreatInstance(); tasks1.Add(Task.Run(() =&gt; singleton.Change())); } Task.WaitAll(tasks1.ToArray()); Singleton2.Show(); Console.WriteLine(\"***************************************************************\"); List&lt;Task&gt; tasks2 = new List&lt;Task&gt;(); for (int i = 0; i &lt; 10000; i++) { Singleton3 singleton = Singleton3.CreatInstance(); tasks2.Add(Task.Run(() =&gt; singleton.Change())); } Task.WaitAll(tasks2.ToArray()); Singleton3.Show(); Console.Read(); } 会得到如下的结果 这样我们可以直观地看到线程安全问题确实存在。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/07/01/singleton-pattern/","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://zhumingcj.github.io/tags/设计模式/"}]},{"title":"Gaussian elimination method","date":"2019-06-27T12:06:11.000Z","text":"求解矩阵的高斯消元法高斯消元法是求解矩阵最基础的一种算法，具有泛化性强的优点。 消元过程对于方程组$Ax=b$（其中A为n阶方阵）可由n-1个消元过程和n-1个回代过程完成求解 \\begin{cases} a_{11}x_1+a_{12}x_2+a_{13}x_3+\\cdots+a_{1n}x_n=&b_1 \\\\\\vdots\\\\ a_{n1}x_1+a_{n2}x_2+a_{n3}x_3+\\cdots+a_{nn}x_n=&b_n& \\end{cases} \\\\ \\begin{pmatrix} a_{11}&a_{12}&a_{13}&\\dots&a_{1n}\\\\ a_{21}&a_{22}&a_{23}&\\dots&a_{2n}\\\\ \\vdots&&&&\\vdots\\\\ a_{n1}&a_{n2}&a_{n3}&\\dots&a_{nn} \\end{pmatrix} \\begin{pmatrix} x_1\\\\ x_2\\\\ \\vdots\\\\ x_n \\end{pmatrix}= \\begin{pmatrix} b_1\\\\ b_2\\\\ \\vdots\\\\ b_n \\end{pmatrix} 矩阵的消元过程(在矩阵有解的情况下) 第一步消元 $a_{ij}^{(1)}=a_{ij}^{(0)}-\\frac{a_{i1}^{(0)}} {a_{11}^{(0)}}a_{1j}^{(0)}=a_{ij}^{(0)}-l_{i1}^{(0)}a_{1j}^{(0)} ,\\quad i=2,3,\\dots,n;j=2,3,\\dots,n$ $b_{i}^{(1)}=b_{i}^{(0)}-\\frac{a_{i1}^{(0)}} {a_{11}^{(0)}}b_{1}^{(0)}=b_{i}^{(0)}-l_{i1}^{(0)}b_{1}^{(0)} ,\\quad i=2,3,\\dots,n$ $l_{i1}\\triangleq \\frac {a_{i1}^{(0)}} {a_{11}^{(0)}},\\quad i=2,3,\\dots,n$ 第k步消元 $a_{ij}^{(k)}=a_{ij}^{(k-1)}-\\frac{a_{ik}^{(k-1)}} {a_{kk}^{(k-1)}}a_{kj}^{(k-1)}=a_{ij}^{(k-1)}-l_{ik}^{(k-1)}a_{kj}^{(k-1)} ,\\quad i=k+1,k+2,\\dots,n;j=k=1,k+2,\\dots,n$ $b_{i}^{(k)}=b_{i}^{(k-1)}-\\frac{a_{ik}^{(k-1)}} {a_{kk}^{(k-1)}}b_{k}^{(k-1)}=b_{i}^{(k-1)}-l_{ik}^{(k-1)}b_{k}^{(k-1)} ,\\quad i=k+1,k+2,\\dots,n$ $l_{ik}\\triangleq \\frac {a_{ik}^{(k-1)}} {a_{kk}^{(k-1)}},\\quad i=k+1,k+2,\\dots,n$ 消元完成后 A^{(n-1)}= \\begin{pmatrix} a_{11}^{(0)}&a_{12}^{(0)}&a_{13}^{(0)}&\\cdots&\\cdots&a_{1n}^{(0)}\\\\ &a_{22}^{(1)}&a_{23}^{(1)}&\\cdots&\\cdots&a_{2n}^{(1)}\\\\ &&\\ddots\\\\ &&&a_{kk}^{(k-1)}&\\cdots&a_{kn}^{(k-1)}\\\\ &&&&\\ddots&\\vdots\\\\ &&&&&a_{nn}^{(n-1)} \\end{pmatrix},\\quad b^{(n-1)}= \\begin{pmatrix} b_{1}^{(0)}\\\\ b_{2}^{(1)}\\\\ \\vdots\\\\ b_{k}^{(k-1)}\\\\ \\vdots\\\\ b_{n}^{(n-1)} \\end{pmatrix} 回代的过程 \\left\\{ \\begin{array} x_n=\\frac{b_n^{n-1}}{a_{nn}^{(n-1)}}\\\\ x_k=\\frac{ {b_k}^{(k-1)-\\sum_{j=k+1}^n(a_{kj}^{(k-1)}x_j)} } {a_{kk}^{(k-1)} },\\quad k=n-1,n-2,\\dots,2,1. \\end{array} \\right. 算法的分析 [ ] 在消元的过程中，计算$l_{ik}\\triangleq \\frac {a_{ik}^{(k-1)}} {a_{kk}^{(k-1)}},\\quad i=k+1,k+2,\\dots,n$时共有n-k个除法，而计算$a_{ij}^{(k)}=a_{ij}^{(k-1)}-l_{ik}^{(k-1)}a_{kj}^{(k-1)} ,\\quad i=k+1,k+2,\\dots,n;j=k=1,k+2,\\dots,n$时有$(n-k)^2$个乘法，计算$b_{i}^{(k)}=b_{i}^{(k-1)}-l_{ik}^{(k-1)}b_{k}^{(k-1)} ,\\quad i=k+1,k+2,\\dots,n$时也有n-k个乘法，消元共进行了n-1步，即$k=1,2,\\dots,n-1$. [ ] ==所以在消元过程中乘除法的运算量为== N_1=\\sum_{k=1}^{n-1}((n-k)^2+2(n-k))=n^3/3+n^2/2-5n/6. [ ] ==回代过程中乘除法的运算量为== N_2=\\sum_{k=1}^{n-1}(n-k)+n=n^2/2+n/2. [ ] ==所以高斯消元法解n阶矩阵的总乘除法运算量为== $N=N_1+N_2=n^3/3+n^2-n/3$ 高斯消元法的程序实现我们可以封装一个Matrix类如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Matrix{ public int row = 0; public int column = 0; private float[,] matrix; public Matrix(int row, int column) { this.row = row; this.column = column; matrix = new float[row, column]; for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; column; j++) { string mid = Console.ReadLine(); var rows = mid.Split(' '); foreach (var item in rows) { matrix[i, j++] = float.Parse(item); } } } } public void DisPlay() { for (int i = 0; i &lt; this.row; i++) { for (int j = 0; j &lt; this.column; j++) { Console.Write(matrix[i, j] + \" \"); } Console.WriteLine(\"\\r\"); } } public void Simplize() { for (int i = 0; i &lt; this.row ; i++) { if (matrix[i, i] != 0) { for (int k = i + 1; k &lt; row ; k++) { matrix[k, i] = matrix[k, i] / matrix[i, i]; } }//这里将消元的中间量存在被消元的位置，因为运算后，这些位置的值为零 for (int j = i + 1; j &lt; row; j++) { for (int k = i + 1; k &lt; column; k++) { matrix[j, k] = matrix[j, k] - matrix[j, i] * matrix[i, k]; } } } }} 当我们输入 \\begin{pmatrix} 1&2&1&0\\\\ 2&2&3&3\\\\ -1&-3&0&2 \\end{pmatrix}时，并调用Simplize和DisPlay方法，将得到结果如下 事实上，这是一个矩阵的LU分解，LU分解在矩阵的研究中有着重要的地位，是十分常用的一个分解方法。 高斯消元法的缺点 高斯消元法的运算量较大 高斯消元法的顺利进行要求矩阵满足某些要求 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/06/27/Gaussian elimination method/","tags":[{"name":"Matrix","slug":"matrix","permalink":"http://zhumingcj.github.io/tags/matrix/"}]},{"title":"Decoractor Pattern","date":"2019-06-27T02:57:06.000Z","text":"装饰器模式是一个很著名的设计模式，经常被用于有切面需求的场景，比如插入日志、统计等的逻辑。装饰器模式的作用是能为已经存在的对象添加额外的功能。 设计模式之装饰器模式装饰器模式的作用 在不改变现有对象结构的基础上为其添加新的功能，且并不通过继承而是通过对象之间的关联来实现，使其更加灵活。 相比于继承来增加新功能（固定的），装饰器模式可以动态的增加新功能，并且功能之间可以进行组合来产生更多的功能，避免了增加功能时对对象的修改 这是一种实现AOP（面向切面编程）的方法，即将主业务逻辑之外的aspect抽离出来，降低代码的耦合度。 实现装饰器模式的关键装饰器模式无非是要调用一堆方法，但是又不能直接在类中增加逻辑（开闭原则），也不通过继承来实现，而是交给装饰器来实现。那么问题的关键就在于保存这一堆方法，并且使他们之间的顺序可以动态的调整。装饰器模式是通过字段对方法进行缓存（实际上是缓存一个对象，然后调用对象的方法），再通过迭代调用将各个方法以一定的顺序连接起来 装饰器实现步骤 建立一个继承自对象抽象类的装饰器基类，其中包括缓存字段，构造函数和方法调用 123456789101112class BaseStudentDecorator : AbstractStudent { private AbstractStudent _student = null;//用于缓存一个对象 public BaseStudentDecorator(AbstractStudent student) { this._student = student; } public override void Finish() { this._student.Finish(); } } 依照单一职责原则创建实现具体功能的装饰器，在其中调用父类的构造函数并复写父类的方法 12345678910111213public StudentLearningDecoractor(AbstractStudent student) : base(student) { } public override void Finish() { { //你要实现的逻辑 } base.Finish(); }//创建多个，根据要实现的逻辑 对装饰器要实现的功能进行注册并调用 123456student = new StudentPreviewDecoractor(student); student = new StudentLearningDecoractor(student);//添加了一个功能 student = new StudentReviewDecorator(student);//添加了一个功能 student = new StudentPlayDecoractor(student);//添加了一个功能 student = new StudentSleeepDecorator(student);//添加了一个功能 student.Finish();//调用 抽象类和具体类 public abstract class AbstractStudent123456789101112131415161718192021public abstract class AbstractStudent { public int Id { get; set; } public string Name { get; set; } public abstract void Finish(); } public class StudentCommon:AbstractStudent { public override void Finish() { Console.WriteLine($\"{base.Name} finished learning\"); } public class StudentPreview: StudentCommon { public override void Finish() { base.Finish(); Console.WriteLine(\"先进行复习\"); } } } 运行结果： 深入分析 [ ] 当我们在注册方法时，student（不同类型）对象会被保存在基类中 [ ] 当我们最后调用finish方法时，会先调用StudentSleeepDecorator的finish方法，finish方法又会调用基类的finish方法，而基类的finish方法会调用之前缓存的student的finish方法…..，从而形成了一系列的调用，相当于一个链表结构。 [ ] 在我们实现具体的装饰器时，==base.Finish()和你要实现的逻辑的顺序直接影响到这些逻辑调用的顺序==。当你要实现的逻辑放在前面时，相当于堆栈，遵从先进后出的原则，因此先注册的方法会最后执行（1）；当base.Finish()放在前面时，相当于队列，遵从先进先出，因此先注册的方法最先执行（2）。 [ ] 所以当我们要实现在主逻辑（这里为Console.WriteLine($”{base.Name} finished learning”)，即已有对象的方法）前增加若干方法，在主逻辑后也增加若干方法时： 在编写装饰器时时，对于主逻辑之前要执行的方法应按上述（1）来编写装饰器；而对于主逻辑之后要执行的方法应按上述（2）来编写装饰器。 在注册时，对于主逻辑之前要执行的方法要逆序注册；对于主逻辑之后要执行的方法要顺序注册 tips 观察者模式较其他设计模式来说要更难以理解，相要真正理解还是得自己敲一下代码，断点运行一下。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/06/27/Decoractor-Pattern/","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://zhumingcj.github.io/tags/设计模式/"}]},{"title":"设计模式-观察者模式","date":"2019-06-26T16:52:38.000Z","text":"设计模式之观察者模式 什么是观察者模式形象的来说，观察者模式包含一个被观察者（subject）以及若干观察者（observer），observer观察subject，当subject发出一个动作时，observer观察到后作出相应反应。在程序中则是某个类（subject）达到某种触发条件后向其他类发送通知（通常是执行某些方法的信息），然后这些类执行相应的方法。 观察者模式的作用 用于程序的解耦。观察者模式通过依赖于抽象的接口来减少类与类之间的直接依赖。 可以作为一种通知的机制，将更新通知给其它的对象。 观察者模式的缺点 当一个被观察者有很多的直接或间接的观察者时，要通知到所有的观察者需要耗费很多的时间。 当被观察者之间循环依赖时（比如：A通知B改变C，C的改变引起A的改变，继而又触发了A通知B），程序会进入循环调用，导致系统崩溃。 观察者模式的实现要点 要创建一个接口用以约束所有被观察者，提供消息传递的通道 被观察者需要有一个存放消息的容器，一般是接口的一个列表；同时被观察者要具有订阅观察者和取消订阅的方法，用以动态的增加减少观察者的数量。 实现消息的传递——通过调用接口列表中的各个方法。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 class Program { static void Main(string[] args) { Cat cat = new Cat(); cat.Add(new Dog()); cat.Add(new Duck()); cat.Add(new mouse()); cat.Add(new people()); cat.Miao(); Console.Read(); } }interface Ioberver{ void Action();} class Chicken:Ioberver { public void Action() { this.Woo(); } public void Woo() { Console.WriteLine(\"{0} Woo\", this.GetType().Name); } } class Dog : Ioberver { public void Action() { this.Wang(); } public void Wang() { Console.WriteLine($\"{this.GetType().Name} 汪汪汪\"); } } class Duck : Ioberver { public void Action() { this.Gaga(); } public void Gaga() { Console.WriteLine($\"{this.GetType().Name} 嘎嘎嘎\"); } } class mouse : Ioberver { public void Action() { this.Zhi(); } public void Zhi() { Console.WriteLine($\"{this.GetType().Name} 吱吱吱\"); } }class Cat{ public void Miao() { Console.WriteLine(\"{0} miao\",this.GetType().Name); if(this._ObserverList!=null &amp;&amp; this._ObserverList.Count &gt; 0) { foreach (var observer in _ObserverList) { observer.Action(); } } } public List&lt;Ioberver&gt; _ObserverList = new List&lt;Ioberver&gt;(); public void Add(Ioberver observer) { this._ObserverList.Add(observer); } public void Remove(Ioberver observer) { this._ObserverList.Remove(observer); }} 运行结果： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/06/27/Observer Pattern/","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://zhumingcj.github.io/tags/设计模式/"}]},{"title":"ShortCut Key for Typora","date":"2019-06-21T05:36:41.000Z","text":"刚建立了自己的博客，来发一篇文章😃 最近刚学会使用Typora，刚好把一些快捷键整理一下。 常用快捷键 标题 ctrl+1/2/3… 数字表示标题的级数 下划线 ctrl+u 效果：这是下划线 删除线 shift+alt+5 效果：这是删除线 字体加粗 ctrl+b 效果：加粗了 字体倾斜 ctrl+i 效果：倾斜的字 无序列表 -+space+内容 效果 牛奶 面包 巧克力（可嵌套） 引用 &gt;+space或ctrl+shift+q 效果：这是引用 插入地址 ctrl+k 百度 插入表格 ctrl+t 效果： 周一 周二 周三 周四 周五 微积分 放假 放假 放假 放假 大学物理 放假 放假 放假 放假 英语 放假 放假 放假 放假 回到文章顶部 ctrl+home 效果：无法展示😂 自动产生目录 [TOC]+enter 效果：(只有一个标题，将就看一下效果) [TOC] 选中一整行 ctrl+l 额，无法展示效果 插入代码块 ctrl+alt+b(可能需要自己设置) 效果： 1234567891011using System;using System.Collections.Generic;using System.Diagnostics;using System.Linq;using System.Text;using System.Threading;using System.Threading.Tasks;public static void main(string[]args){ ConSole.WriteLine(\"Hello World\");} 搜索内容 ctrl+f 替换 ctrl+h 效果：无 强调、着重标记 ctrl+shift+~(tab上面那个) 效果：这是重点 这是重点 则是重点 分隔线 —-+enter或*+enter 效果： 数学公式 $$+enter 效果： |i j k | a+b+c^5=2ab 表情 :+表情的英文单词 效果：🛰 快速创建新文件 ctrl +n 快速关闭 ctrl+w 显示/隐藏大纲 ctrl+shift+l 高亮 == 文字 ==（中间没有空格） 标题变为普通文本 ctrl+0 脚注 效果：这是一个脚注1 行内数学公式 $+esc(然后输入Tex命令) $\\lim_{x\\to\\infty}\\exp(-x)=0$ 上下标 x^2^2 H~2~O 效果：x^2^ H~2~O 1. 注释 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/06/21/Tips for Typora/","tags":[{"name":"文本编辑","slug":"文本编辑","permalink":"http://zhumingcj.github.io/tags/文本编辑/"}]},{"title":"my first blog","date":"2019-06-21T00:32:12.000Z","text":"这是我的第一篇blog序章终于成功了很开心 :happy: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"","permalink":"http://zhumingcj.github.io/2019/06/21/my-first-blog/","tags":[]}]